[
  {
    "rule": "Rule 6.4.1 \u2014 depends on the names and scopes of identi9ers;\n\n\u25cf"
  },
  {
    "rule": "Rule 8.2.7 \u2014 depends on the type being cast;\n\n\u25cf"
  },
  {
    "rule": "Rule 19.3.4 \u2014 depends on the result of a macro expansion.\n\n6\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n \n\fStatic analysers vary in their ability to detect violations of undecidable rules:\n\n\u25cf A reported violation of an undecidable rule may not necessarily indicate a real violation; some \nanalysers take the approach of reporting possible violations to remind users of the uncertainty;\n\n\u25cf No reported violation of an undecidable rule does not necessarily indicate that there are no \n\nviolations in the code being analysed.\n\nNote: if a tool produces a diagnostic for a violation of an undecidable guideline (regardless of category), \nand a justi9cation can be provided to show that a violation cannot occur at run time, then the  \ndiagnostic does not actually indicate a violation. In that case, the justi9cation should be recorded to \nsupport the claim that there is no violation of a MISRA guideline. See MISRA Compliance [1].\n\nSome examples of undecidable rules are:\n\n\u25cf"
  },
  {
    "rule": "Rule 8.2.10 \u2014 depends on knowing which functions are called when function pointers are used;\n\n\u25cf"
  },
  {
    "rule": "Rule 11.6.2 \u2014 depends on data-dependent control ^ow.\n\nAs indicated in MISRA Compliance [1], a process should be developed for analysing the results of static \nanalysis and recording the outcome. Particular attention should be paid to the process for analysing \nany output that relates to undecidable rules.\n\n3.6\n\nAnalysis scope\n\nEach rule is classified according to the amount of code that needs to be checked in order to detect  \nviolations. As for decidability, the concept of analysis scope is not applied to directives.\n\nThe analysis scopes that may be applied to rules are \u201cSingle Translation Unit\u201d and \u201cSystem\u201d.\n\nIf a rule is classi9ed as capable of being checked on a \u201cSingle Translation Unit\u201d basis then it is possible \nto detect all violations within a project by checking each translation unit independently. For example, \nthe presence of switch statements that do not contain default labels ("
  },
  {
    "rule": "Rule 9.4.2) within one translation \nunit has no eCect on whether other translation units contain such switch statements.\n\nIf a rule is classi9ed as needing to be checked on a \u201cSystem\u201d basis then identifying violations of a rule  \nwithin a translation unit requires checking more than the translation unit in question. Rules that are \nclassified as \u201cSystem\u201d are best checked by analysing all the source code, although it will be possible to \nidentify some violations when checking a subset of the whole source. For example, if a project has  \ntwo translation units A and B, it is possible to check that all declarations of a function within each \ntranslation unit  have compatible types ("
  },
  {
    "rule": "Rule 6.2.2). However, this does not guarantee that the \ndeclarations in A are compatible with those in B. All of the source code that will be compiled and linked \ninto the executable therefore needs to be checked to guarantee compliance with this rule.\n\nMost undecidable rules need to be checked on a \u201cSystem\u201d basis because, in the general case,  \ninformation about the behaviour of other translation units will be needed. For example, whether or \nnot the value of the automatic object x is set before x is used ("
  },
  {
    "rule": "Rule 11.6.2) in the function g, below, \nwill depend on the behaviour of the function f which is de9ned in another translation unit: \n\nextern void f ( uint16_t * p );\n\nuint16_t  y;\n\nvoid g ( void )\n{\n  uint16_t  x;  // x is not given a value\n\n  f ( &x );     // f might modify the object pointed to by its parameter\n  y = x;        // x may or may not be unset\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\ng\ne\nh\nt\no\nt\nn\no\ni\nt\nc\nu\nd\no\nr\nt\nn\n\nI\n\n:\n\n3\nn\no\ni\nt\nc\ne\nS\n\n7\n\n \n \n \n \n \n\fS\ne\nc\nt\ni\no\nn\n3\n\n:\n\n3.7\n\nApplicability\n\n3.7.1\n\nConditional compilation\n\nUnless otherwise stated, the guidelines shall only be applied to code that remains after preprocessing \nof a translation unit.\n\nNote: this requires that the values of all macros used to control conditional compilation be made  \navailable to an analysis tool, including those that are defined outside of the source code (e.g. those  \nde9ned by means of a command line parameter, or that are de9ned by the compiler).\n\n3.7.2\n\nClasses\n\nUnless otherwise stated, any reference to \u201ca class\u201d within the guidelines refers to any type introduced \nwith the class or struct keyword. Note that the C++ Standard also includes types introduced with \nthe union keyword when referring to class types, but that is not the case within the guidelines.\n\nI\n\nn\nt\nr\no\nd\nu\nc\nt\ni\no\nn\nt\no\nt\nh\ne\ng\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n3.7.3\n\nTemplates\n\nUnless otherwise stated, the guidelines shall only be applied to fully instantiated templates.\n\n3.7.4\n\nCompiler generated code\n\nUnless otherwise speci9ed, all guidelines shall apply to implicitly-declared or implicitly-de9ned special \nmember functions.\n\n3.7.5\n\nAutomatically generated code\n\nThe MISRA C++ guidelines are applicable to code that has been generated automatically. Responsibility \nfor compliance lies both with the developer of the automatic code generation tool, and with the \ndeveloper of the model from which code is being generated. Since there are several modelling  \npackages, each of which may have several automatic code generators, it is not possible to allocate  \nthis responsibility individually for each MISRA C++ guideline. It is expected that users of modelling \npackages and code generators will employ relevant guidelines such as MISRA AC GMG [4]  and \nMISRA AC SLSF [5].\n\nNote: the guidance given in the current edition of MISRA Compliance [1] shall be followed when making \na claim that automatically generated code is compliant with MISRA C++.\n\n8\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n \n\f3.8\n\nPresentation of guidelines\n\ns\ne\nn\n\nThe guidelines within this document are presented in a number of sections, with the headings of  \nthose sections tracking the headings of the sections within the C++ Standard that cover the language \nbehaviours to which the guidelines they contain are related. The headings also include the  stable \nnames from the C++ Standard that allow content to be located even if the sections are renumbered \n(e.g. between versions). Sections with the [misra] stable name are an exception, and are used to \nidentify sections of best-practice guidance that is not directly attributable to language behaviours.\n\nWithin the sections, the individual guidelines have the following format:\n\nIdent\n\nHeadline\n\nCategory Category\n\nAnalysis Decidability, Scope\n\nwhere:\n\n[Source ref]\n\ni\nl\n\ni\n\ne\nd\nu\ng\ne\nh\nt\no\nt\nn\no\ni\nt\nc\nu\nd\no\nr\nt\nn\n\nI\n\n:\n\n3\nn\no\ni\nt\nc\ne\nS\n\n\u25cf Ident is a unique identi9er for the guideline of the form pre2x a.b.c, where:\n\n\u25ac pre2x is either \u201cDir\u201d or \u201cRule\u201d, as appropriate to the guideline\u2019s classi9cation;\n\n\u25ac a.b re^ects the section number within the C++ Standard to which the guideline is related; \n\n\u25ac c is a sequence number for guidelines related to the above section;\n\n\u25cf Headline is a summary of the guideline;\n\n\u25cf Source ref indicates the primary source(s) which led to this item or group of items, where  \n\napplicable, as explained in Section 3.9;\n\n\u25cf Category is one of \u201cMandatory\u201d, \u201cRequired\u201d or \u201cAdvisory\u201d, as explained in Section 3.2;\n\n\u25cf Decidability is one of \u201cDecidable\u201d or \u201cUndecidable\u201d, as explained in Section 3.5;\n\n\u25cf Scope is one of \u201cSystem\u201d or \u201cSingle Translation Unit\u201d, as explained in Section 3.6;\n\nNotes:\n\n1. As guidance is not given for every section within the C++ Standard, the numbering of the \n\ndesignators a.b and the section headings within this document are not contiguous;\n\n2. Section 0.b contains general guidance that does not relate to any speci9c area within the C++ \n\nStandard;\n\n3. Sections of the form a.0 give guidance that relates to section a of the C++ Standard, but which \n\nis not directly attributable to any particular language construct within that section.\n\n4. The \u201cAnalysis\u201d line is omitted from directives as decidability and analysis scope do not apply.\n\nIn addition, supporting text is provided for each item or group of related items. The text gives, where \nappropriate, some explanation of the underlying issues being addressed by the guideline(s), and \nexamples of how to apply them.\n\nWithin the supporting text, there may be a heading titled \u201cAmplification\u201d, followed by text that provides \na more precise description of the guideline. An amplification is normative; where its requirements  \ndiCer from those of the headline, the ampli9cation takes precedence. This mechanism is convenient \nas it allows a complicated concept to be conveyed using a short headline.\n\nWithin the supporting text, there may be a heading titled \u201cException\u201d, followed by text that describes \nsituations in which the guideline does not apply. The use of exceptions permits the description of some \nguidelines to be simpli9ed. It is important to note that an exception is a situation in which the guideline \ndoes not apply. Code that complies with a guideline by virtue of an exception does not require a  \ndeviation.\n\n9\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n \n\fS\ne\nc\nt\ni\no\nn\n3\n\n:\n\nI\n\nn\nt\nr\no\nd\nu\nc\nt\ni\no\nn\nt\no\nt\nh\ne\ng\nu\nd\ne\n\ni\n\nl\ni\n\nThe supporting text is not intended as a tutorial in the relevant language feature, as the reader is  \nassumed to have a working knowledge of the language. Further information on the language features \ncan be obtained by consulting the relevant section of the C++ Standard or other C++ language \nreferences. Where a source reference is given for one or more of the undesirable behaviours listed  \nin the C++ Standard, then the original issue raised in it may provide additional help in understanding \nthe guideline.\n\nWithin the guidelines, and their supporting text, the following font styles are used to represent \nkeywords and code:\n\n\u25cf Items de9ned in the C++ Standard or the Glossary appear in italic text;\n\n\u25cf Keywords and language constructs appear in a monospaced font;\n\n\u25cf Code also appears in a monospaced font, either within other text; or\n\n        As separate code fragments\n\nWithin the code examples:\n\n\u25cf For the sake of brevity, code fragments may be incomplete (for example, implicit use of Standard \n\nn\ne\ns\n\nLibrary header 9les, if statements without a body).\n\n\u25cf Use is made of the 9xed-width integer types from <cstdint>.\n\n\u25cf Where an object\u2019s declaration is omitted, its type can be deduced from its name, with the  \n\nintroductory characters indicating the type:\n\n\u25ac A name starting with u8, s8, u16, etc. has type uint8_t, int8_t, uint16_t, etc.\n\n\u25ac A name starting with f, d or ld has type float, double or long double.\n\n3.9\n\nUnderstanding the source references\n\n3.9.1\n\nReferences to the C++ Standard\n\nReferences into the C++ Standard are used to identify vulnerabilities which need to be mitigated:\n\n\u25cf Undefined behaviour \u2014 Behaviour for which the C++ Standard imposes no requirements (see \n[defns.undefined]). These are essentially programming errors for which the compiler is not \nobliged to issue a diagnostic (error message), and are particularly important from a safety point \nof view, as they represent programming errors which may not be diagnosed by the compiler.  \nFor example,"
  },
  {
    "rule": "Rule 6.8.1 covers object lifetime violations.\n\n\u25cf Unspecified behaviour \u2014 Behaviour within the C++ Standard that depends on the implementation \n(see [defns.unspecified]). These are language constructs that must compile successfully, but \nthe implementation may choose from a set of appropriately defined behaviours. For example,"
  },
  {
    "rule": "Rule 8.2.6 covers casting to pointer types.\n\n\u25cf Implementation-defined behaviour \u2014 Behaviour within the C++ Standard that depends on, and is \ndocumented by, the implementation (see [defns.impl.defined]). These are similar to unspeci%ed  \nbehaviour, except that the behaviour must be consistent and documented. However, the related \nbehaviour can vary from one compiler to another. For example,"
  },
  {
    "rule": "Rule 6.9.2 covers the sizes of \nthe integral types.\n\n\u25cf Conditionally-supported behaviour \u2014 A program construct defined within the C++ Standard that \nan implementation is not required to support (see [defns.conf.supp]). These are language  \nconstructs that may not be provided by all compilers. An implementation is required to  \ndocument those features that are not supported and to issue a diagnostic if an unsupported \nconstruct is used within the code. For example,"
  },
  {
    "rule": "Rule 10.4.1 covers the use of asm.\n\n10\n\n\u25cf No diagnostic required \u2014 Behaviour within the C++ Standard for which no diagnostic is required \n(see [intro.compliance]/1). These are conditions that may lead to program errors, but for which \n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n \n\fthe C++ Standard explicitly states that the implementation is not required to issue a diagnostic \n(error message). For example,"
  },
  {
    "rule": "Rule 6.2.1 covers the one-de%nition rule.\n\nA guideline providing mitigation for such a vulnerability will include a reference into the C++ Standard \nhaving the form: \n\n   [Stable-name] Vulnerability Paragraph\n\nwhere:\n\n\u25cf Stable-name is an identi9er used within the C++ Standard to identify a speci9c section.\n\n\u25cf Vulnerability is as indicated above.\n\n\u25cf Paragraph identi9es the paragraph within the section where the vulnerability occurs.\n\nFor example, a reference of:\n\n   [intro.execution] Undefined 17\n\nwould indicate that a guideline targets the undefined behaviour found in paragraph 17 of the  \n[intro.execution] section of the C++ Standard.\n\nIn addition, supporting context for a guideline\u2019s rationale will use a reference having the form: \n\n   [Stable-name] / Paragraph\n\n3.9.2 Other references\n\nReferences to other sources may be consulted by a reader wishing to gain a fuller understanding of \nthe rationale behind a guideline (for example when considering a request for a deviation). These  \nreferences have the form: \n\n   [Reference] Location\n\nwhere:\n\n\u25cf Reference identi9es the referenced material.\n\n\u25cf Location identi9es a page, section or paragraph within the document.\n\nThe following source references are used: \n\nReference\n\nSource\n\nC11\n\nISO/IEC 9899:2011 [6]\n\nISO/IEC/IEEE 60559\n\nISO/IEC/IEEE 60559:2011 [10]\n\nIEC 61508\n\nISO 26262\n\nDO-178C\n\nIEC 61508 [11]\n\nISO 26262 [9]\n\nDO-178C [12]\n\nMISRA Guidelines\n\nMISRA Development guidelines for vehicle based software [3]\n\nKoenig\n\nC Traps and Pitfalls [14]\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\ng\ne\nh\nt\no\nt\nn\no\ni\nt\nc\nu\nd\no\nr\nt\nn\n\nI\n\n:\n\n3\nn\no\ni\nt\nc\ne\nS\n\n11\n\n \n \n \n \n \n\f4 Guidelines\n\n4.0\n\nLanguage independent issues\n\n4.0.0\n\nPath feasibility \n\n [misra]"
  },
  {
    "rule": "Rule 0.0.1\n\nA function shall not contain unreachable statements\n\n[IEC 61508-7] / C.5.9\n[DO-178C] / 6.4.4.3.c\n[ISO 26262-6] / 9.4\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA statement is unreachable if the block containing it is not reachable from the entry block of the Control \nFlow Graph (CFG) for the function.\n\nFor the purpose of this rule:\n\n\u25cf Both  operands  of  a  reachable  logical  AND  (&&)  or  logical  OR  (||)  operator  are  considered \n\nreachable; and\n\n\u25cf All three operands of a reachable conditional operator (?:) are considered reachable; and\n\n\u25cf The blocks linked by the edges from a condition of a selection-statement or an iteration-statement \nare all considered reachable, except when the condition is a constant expression, in which case \nonly the blocks linked by edges selected by the condition are considered reachable; and\n\n\u25cf A call to a function declared [[noreturn]] has no CFG out edge; and\n\n\u25cf If a try compound-statement of a (function-)try-block does not contain a reachable, potentially-\nthrowing  statement, then all  catch-handlers  are  unreachable, otherwise all  catch-handlers  are \nconsidered reachable subject to the restriction that a catch-handler that appears after a more \ngeneric handler of the same try-block is not reachable.\n\nThe rule does not apply to statements in the discarded branch of a constexpr if statement.\n\nRationale\n\nUnreachable code often indicates a defect in the program, as, assuming that the program does not \nexhibit any unde%ned behaviour, unreachable code cannot be executed and cannot have any eCect on \nthe program\u2019s outputs.\n\nIn order to avoid crosstalk with"
  },
  {
    "rule": "Rule 0.0.2, the handling of logical and conditional operators in the \nconceptual CFG used by this rule diCers from that in a traditional CFG.\n\n12\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n\fExample\n\nbool f0();\n\nint32_t f1( int32_t c, int32_t & res )\n{\n  if ( false && f0() ) { }  // Compliant - statement is considered to be reachable\n\n  return res;\n\n  res = c;                  // Non-compliant - not reachable from entry block\n\n  bool result;              // Non-compliant - not reachable from entry block\n}\n\nvoid f2( int32_t i )\n{\n  while ( true )            // Constant condition - single edge into body of loop\n  {\n    if ( i != 0 )\n    {\n      break;                // Adds edge to statements following the loop body\n    }\n  }\n\n  ++i;                      // Compliant - reachable via 'break'\n\n  while ( true )            // Constant condition - single edge into body of loop\n  {\n    f();\n  }\n\n  ++i;                      // Non-compliant - not reachable from entry block\n}\n\nvoid f3( int32_t i )\n{\n  goto LABEL;\n  ++i;                      // Non-compliant - no edge to this block\n\nLABEL:\n  ++i;                      // Compliant\n}\n\nclass BaseException {};\nclass DerivedException: public BaseException {};\n\nvoid f4()\n{\n  try { /* ... */ }\n  catch ( BaseException    & b ) { }\n  catch ( DerivedException & d ) { }   // Non-compliant - will be caught above\n}\n\nvoid f5() noexcept;\n\nvoid f6()\n{\n  try { f5(); }\n  catch ( int32_t ) { }     // Non-compliant - f5 is not potentially-throwing\n  catch ( ... )     { }     // Non-compliant - f5 is not potentially-throwing\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n13\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nvoid f7( int32_t i )\n{\n  try\n  {\n    throw i;\n    ++i;                    // Non-compliant - no edge to this block\n  }\n  catch ( int32_t ) { }     // Compliant - all catch-handlers are reachable\n  catch ( int16_t ) { }     // Compliant - all catch-handlers are reachable\n\nn\ne\ns\n\n  ++i;                      // Compliant\n}\n\nvoid f8();\n\nint32_t f9( int32_t i )\n{\n  try\n  {\n    f8();                   // Potentially-throwing\n    return i * 2;           // Compliant\n  }\n  catch( int32_t ) { }      // Compliant - all catch-handlers are reachable\n\n  return 0;                 // Compliant - even if f8 throws a type\n}                           //             other than int32_t\n\n[[noreturn]] void f10() noexcept;\n\nint32_t f11()\n{\n  f10();                    // Does not return\n  return 0;                 // Non-compliant\n}"
  },
  {
    "rule": "Rule 0.0.2\n\nControlling expressions should not be invariant\n\n[IEC 61508-7] / C.5.9\n[DO-178C] / 6.4.4.3.c\n[ISO 26262-6] / 9.4.5\n\nCategory Advisory\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nThis rule applies to:\n\n\u25cf Controlling expressions of if, while, for, do ... while and switch statements; and\n\n\u25cf The 9rst operand of the conditional operator (?:); and\n\n\u25cf The left hand operand of the logical AND (&&) and logical OR (||) operators.\n\nIt does not apply to controlling expressions of constexpr if statements.\n\nA function\u2019s compliance with this rule is determined independently of the context in which the function \nis called. For example, a Boolean parameter is treated as if it may have a value of  true or false, \neven if all the calls expressed in the current program use a value of true.\n\n14\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fRationale\n\nIf a controlling expression has an invariant value, it is possible that there is a programming error. Any \ncode in an infeasible path may be removed by the compiler, which might have the eCect of removing \ncode that has been introduced for defensive purposes.\n\nThis rule does not apply to constexpr if, as this is intended to be evaluated at compile time and \nrequires a constant expression.\n\nException\n\n1. A  while  statement   with   a   constant   expression   evaluating   to  true  is   permitted   as   this   is \n\ncommonly used in real time systems.\n\n2. Macros are permitted to expand to a do-while statement of the form do { } while ( false ), \n\nallowing a macro expansion to be used as a statement that includes a local scope.\n\nExample\n\ns8a = ( u16a < 0u ) ? 0 : 1;               // Non-compliant - u16a always >= 0\n\nif ( u16a <= 0xffffu ) { }                 // Non-compliant - always true\nif ( 2 > 3 ) { }                           // Non-compliant - always false\nif ( ( s8a < 10 ) && ( s8a > 20 ) ) { }    // Non-compliant - always false\nif ( ( s8a < 10 ) || ( s8a > 5  ) ) { }    // Non-compliant - always true\nif ( ( s8a < 10 ) && \n     ( s8a > 20 ) ||                       // Non-compliant - left operand of ||\n     ( s8b == 5 ) ) { }                    //                 always false\n\nconst uint8_t N = 4u;\n\nif ( N == 4u )                             // Non-compliant - compiler is permitted\n{                                          // to assume that N always has value 4\n}\n\nextern const volatile uint8_t M;\n\nif ( M == 4u )                             // Compliant - compiler assumes M may\n{                                          // change, even though the program\n}                                          // cannot modify its value\n\nwhile ( s8a > 10 )\n{\n  if ( s8a > 5 ) { }                       // Non-compliant - s8a always > 5\n\n  --s8a;\n}\n\nfor ( s8a = 0; s8a < 130; ++s8a ) { }      // Non-compliant - always true\n\nwhile ( true ) { /* Do something */ }      // Compliant by exception #1\n\ndo { } while ( false );                    // Compliant by exception #2 \n                                           //   - if expanded from a macro\n\nuint16_t n;                                // Assume 10 <= n <= 100\nuint16_t sum;\n\nsum = 0;\n\nfor ( uint16_t i = ( n - 6u ); i < n; ++i )\n{\n  sum += i;\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n15\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nif ( ( sum % 2u ) == 0u )\n{\n  // Non-compliant - the sum of six, consecutive, non-negative integers is always\n  // an odd number, so the controlling expression will always be false.\n}\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n16\n\ntemplate< typename T >\nvoid foo()\n{\n  if constexpr ( std::is_integral< T >() ) // Rule does not apply\n  {\n    // Handle integral case\n  }\n  else\n  {\n    // Handle other case\n  }\n}\n\ntemplate void foo< int >();\ntemplate void foo< float >();\n\nSee also"
  },
  {
    "rule": "Rule 0.0.1\n\n4.0.1\n\nUnused values \n\n [misra]"
  },
  {
    "rule": "Rule 0.1.1\n\nA value should not be unnecessarily written to a local object\n\nCategory Advisory\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nThis rule applies to all accesses, either direct or through a pointer or reference, to objects with \nautomatic storage duration that:\n\n1. Have trivially destructible types (including basic types and enumeration types); or\n\n2. Are arrays of trivially destructible types; or\n\n3. Are STL containers (including std::string), where the value_type is trivially destructible.\n\nThe rule also applies to accesses to subobjects or elements of such objects.\n\nAn object is unnecessarily written when on each feasible path:\n\n1. The object is destroyed before being observed; or\n\n2. The object is written to again before being read.\n\nAn object is observed within an expression if its value aCects the external state of the program, the \ncontrol ^ow of the program, or the value of a diCerent object.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nThe following examples illustrate diCerent types of access to an object i: \n\nint32_t f( int32_t j );\n\nint32_t i = f( 1 );    // Written\ni;                     // Read\ni = 0;                 // Written (even if 'i' was 0 before the assignment)\nauto j = i;            // Read and observed\n++i;                   // Read and written\ni += 3;                // Read and written\ni = i + j;             // Read and written\nauto k1 = ++i;         // Read, written, read and observed\nauto k2 = i++;         // Read, observed and written \narr[ i ] = f( 1 );     // Read and observed \nif ( i ) { }           // Read and observed\n( void )f( i );        // Read and observed\n\nObserving any element of a container is considered to observe the full container and all of its elements. \nObserving a subobject is considered to observe the full object and all of its subobjects. Additionally, an \nobject that is created outside of an iteration statement is considered to be observed (but not read) at \nthe end of the iteration statement, provided it is also observed during any iteration.\n\nA function\u2019s compliance with this rule is determined independently of the context in which the function \nis called. For example, a Boolean parameter is treated as if it may have a value of  true or false, \neven if all the calls expressed in the current program use a value of true \u2014 see example f4, below.\n\nRationale\n\nGiving an object a value that is never subsequently used is ine[cient, and may indicate that a coding \ndefect is present. Such writes are referred to as data+ow anomalies:\n\n1. A DU (De%ne\u2013Use) data+ow anomaly is present if a value that is written is never observed;\n\n2. A DD (De%ne\u2013De%ne) data+ow anomaly is present if a value overwrites another value before it \n\nhas been read.\n\nWithin a loop, a value may be written to an object with the intent that it will be  observed during the \nnext iteration, meaning that the value written on the last iteration may never be observed. Whilst it is \npossible to restructure the loop to avoid this behaviour, there is a risk that the resulting code may be \nof lower quality (less clear, for example). This rule therefore considers observation during any iteration \nto apply to all values written to such an object, including a value written during the last iteration of a \nloop that is not actually observed \u2014 see example f3, below.\n\nObserving part of a bigger object is considered to observe the object in its entirety; it is common to have \ncode that operates on objects as a whole (initializing or writing to all subobjects), even if the value of  \nonly some of its subobjects are actually read. Requiring fine-grained writes would break encapsulation \n\u2014 see examples f5 and f6, below.\n\nA function, assuming its preconditions are respected, should always behave as speci9ed. This is true  \nirrespective of the calling context, including possible contexts that are not expressed in the current  \nprogram. For this reason, path feasibility (within this rule) is determined without taking the actual calling \ncontexts into consideration.\n\nException\n\nEven though the values passed as arguments to functions are written to their corresponding parameter \nobjects, it is permitted for function parameters to remain  unobserved when the function returns. \nThis exception prevents crosstalk with"
  },
  {
    "rule": "Rule 0.2.2 which requires, in a decidable way, that function \nparameters are used. Note that writing to an unread parameter in a function body is a DD anomaly, \nwhich is a violation of this rule.\n\n17\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n18\n\nExample\n\nint32_t f1( int32_t i )\n{\n  auto j = i;       // Non-compliant - j is not observed after being written\n\n  i++;              // Non-compliant - i is not observed after being written\n\n  return 0;\n}\n\nint32_t f2( int32_t i )\n{\n  auto & j = i;     // Rule does not apply to j, which is not an object\n\n  j++;              // Compliant - writes object i that is observed in the return\n\n  return i;\n}\n\nint32_t f3( int32_t j, int32_t k, int32_t m )\n{ \n  for ( int32_t i = 0; i < 10; ++i )  // Compliant - i is observed in i < 10\n  {\n    m = 10;         // Non-compliant - when looping, overwrites incremented value\n    ++k;            // Non-compliant - k is never observed\n\n    use( j );       // Observation of j inside of the loop\n\n    ++j;            // Compliant - observation above is sufficient for final write\n\n    ++m;            // Compliant - observed in the return\n  }                 // j is considered observed here as it was observed in the loop\n\n  return m;\n}\n\nint32_t f4( bool    b,\n            int32_t i,\n            int32_t j )  // Compliant by exception - j is never observed\n{\n  i = 0;             // Non-compliant - value passed is overwritten\n\n  int32_t k = 4;     // Compliant - value is observed in one feasible path\n\n  if ( b )           // Both branches are considered feasible, even if the function\n  {                  // is only called with b set to true\n    return i;\n  }\n  else \n  { \n    return k;\n  }\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fstruct Point { int32_t x; int32_t y; int32_t z; int32_t t; };\n\nint32_t f5()\n{\n  Point p {};        // Compliant - p and its subobjects are observed in the return\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n  p.x = 2;\n  p.x = 3;           // Non-compliant - overwrite the value 2 that is never read\n  p.z = 4;           // Compliant - p.z is observed in the return\n\n  return p.y;        // Observation of p.y also observes p, p.x, p.z and p.t\n}\n\nint32_t f6()\n{\n  std::vector< int32_t > v( 4, 0 );  // Compliant - v and its elements are observed\n                                     //             in the return\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n  v[ 0 ] = 2;\n  v[ 0 ] = 3;        // Non-compliant - overwrite the value 2 that is never read\n  v[ 2 ] = 4;        // Compliant - v[ 2 ] is observed in the return\n\n  return v[ 1 ];     // Observation of v[ 1 ] observes v and all of its elements\n}\n\nvoid f7( std::mutex & m )\n{\n  std::scoped_lock lock { m };  // Rule does not apply - destructor is non-trivial\n}\n\nchar f8( bool b )\n{\n  char c = f( 1 );   // Non-compliant - assigned value never read\n\n  if ( b )\n  {\n    c = 'h';         // The value of c is overwritten here\n\n    return c;\n  }\n  else\n  {\n    return '\\0';     // The value of c is not observed here\n  }\n}\n\nvoid callee( int32_t & ri )\n{\n  ri++;              // Rule does not apply - reference is not an object\n}\n\nvoid caller()\n{\n  int32_t i = 0;\n\n  callee( i );       // Non-compliant - i written and not subsequently observed\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n19\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 0.1.2\n\nThe value returned by a function shall be used\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule only applies when the function is called explicitly using function call syntax.\n\nn\ne\ns\n\nRationale\n\nIt is possible to call a function without using the return value, which may be an error. If the return value \nof a function is intended to be explicitly discarded, it should be cast to void to ensure that it is used.\n\nOverloaded operators are excluded from this requirement, as they should behave in the same way as  \nbuilt-in operators.\n\nNote: this rule effectively requires all non-void functions to be treated as if they were declared \n[[nodiscard]].\n\nExample\n\nuint16_t func();\n\nvoid discarded()\n{\n  func();                         // Non-compliant - implicitly discarded\n  ( void )func();                 // Compliant - void cast is a use\n  auto b = func();                // Compliant - used as initializer\n}\n\nvoid f1( std::string q )\n{\n  std::string s { q } ;           // Rule does not apply - not function call syntax\n  s = q;                          // Rule does not apply - not function call syntax\n  s.operator=( q );               // Non-compliant \n}\n\nvoid f2( std::function< int() > & f )\n{\n  f();                            // Non-compliant - using function call syntax\n\n  auto a = []() { return 10; };\n  a();                            // Non-compliant - using function call syntax  \n}\n\nSee also"
  },
  {
    "rule": "Rule 28.6.4\n\n4.0.2\n\nUnused declarations \n\n [misra]"
  },
  {
    "rule": "Rule 0.2.1\n\nVariables with limited visibility should be used at least once\n\n20\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA variable has limited visibility if it is not a function parameter, and it has internal linkage or no linkage.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fA variable is used when:\n\n1.\n\nIt is part of an id-expression; or\n\n2. The variable is of class type and has a user-provided constructor or a user-provided destructor.\n\nRationale\n\nVariables that are declared and never used within a project do not contribute to program output; they \nconstitute noise and may indicate that the wrong variable name has been used or that one or more \nstatements are missing.\n\nNote: this rule allows the introduction of variables for the sole purpose of providing scoped resource  \nallocation and release. For example: \n\n{\n  std::lock_guard< std::mutex > lock { mutex };    // Compliant - has user-provided\n                                                   //             constructor\n  // ...\n} // User-provided destructor implicitly called here\n\nException\n\nThis rule does not apply to:\n\n1. Variables that have at least one declaration with the [[maybe_unused]] attribute.\n\n2. Constant variables at namespace scope that are declared within a header %le.\n\nExample\n\nclass C { };                  // No user-provided constructor or destructor\n\nnamespace\n{\n  C c;                        // Non-compliant - unused\n}\n\nvoid maybeUnused( int32_t a )\n{\n  [[maybe_unused]]\n    bool b = a > 0;           // Compliant (by exception #1 if NDEBUG is defined)\n\n  assert( b );                // Does not use b if NDEBUG is defined\n\n  usefn( a );\n}\n\nconst int16_t x = 19;         // Compliant - x is read in initializedButNotUsed\nconst int16_t y = 21;         // Non-compliant - would be compliant by exception #2\n                              //                 if declared in a header file\n\nvoid initializedButNotUsed()\n{\n  int16_t local_1 = 42;       // Non-compliant - local_1 is never read\n  int16_t local_2;            // Compliant\n\n  local_2 = x;                // Use of local_2 for the purposes of this rule\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n21\n\n \n \n\fvoid userProvidedCtor()\n{\n  std::ifstream fs { \"cfg.ini\" };    // Compliant - user-provided constructor\n}\n\nS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nSee also"
  },
  {
    "rule": "Rule 0.2.2\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns"
  },
  {
    "rule": "Rule 0.2.2\n\nA named function parameter shall be used at least once\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule does not apply to parameters that are declared [[maybe_unused]].\n\nNote: this rule also applies to the parameters of a lambda.\n\nRationale\n\nIt is expected that most functions will use their parameters. If a function parameter is unused, it is \npossible that the implementation of the function may not satisfy its requirements. This rule helps to  \nhighlight such potential mismatches.\n\nIn cases where an unused parameter is required, for example when de9ning a virtual function or a \ncallback function, the parameter can be left unnamed. Where the use of a parameter depends on the \nexpansion of a macro or varies between diCerent template instantiations, then the parameter can be \ndeclared [[maybe_unused]].\n\nExample\n\nclass B\n{\npublic:\n  virtual int16_t f( int16_t a, int16_t b );\n};\n\nclass D1 : public B\n{\npublic:\n  int16_t f( int16_t a, int16_t b ) override         // Non-compliant - 'b' unused\n  {\n    return a;\n  }\n};\n\nclass D2 : public B\n{\npublic:\n  int16_t f( int16_t a,                  // Compliant - 'a' is used\n             int16_t ) override          // Rule does not apply - unnamed parameter\n  {\n    return a;\n  }\n};\n\n22\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nclass D3 : public B\n{\npublic:\n  int16_t f( int16_t a, int16_t b ) override         // Compliant\n  {\n    return a + b;\n  }\n};\n\nclass D4 : public B\n{\npublic:\n  int16_t f( int16_t a,                              // Compliant\n             int16_t b [[maybe_unused]] ) override   // Rule does not apply -\n                                                     //   declared [[maybe_unused]]\n  {\n    assert( b > 0 );                     // assert macro may expand to nothing,\n                                         // leaving 'b' unused.\n    return a;\n  }\n};\n\nvoid f1(int32_t i,                       // Non-Compliant\n        int32_t j )                      // Compliant - explicitly cast to void\n{\n  ( void )j;\n\n  auto l = []( int32_t m,                // Compliant\n               int32_t n )               // Non-compliant\n  {\n    return m;\n  };\n}\n\ntemplate< bool b >\nint32_t f2( int32_t i,                   // Non-compliant for f2< false >\n            int32_t j [[maybe_unused]] ) // Rule does not apply - [[maybe_unused]]\n{\n  if constexpr ( b )\n  {\n    return i + j;\n  }\n\n  return 0;\n}\n\nSee also"
  },
  {
    "rule": "Rule 0.2.1"
  },
  {
    "rule": "Rule 0.2.3\n\nTypes with limited visibility should be used at least once\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA type has limited visibility if it is declared in block scope or in unnamed namespace scope.\n\nFor the purposes of this rule:\n\n\u25cf Type aliases, primary class templates, and alias templates are considered types.\n\n\u25cf The closure type associated with a lambda is always used.\n\n23\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n24\n\n\u25cf A type is used if it is referenced within the translation unit outside of its de9nition.\n\n\u25cf An enumeration type is used if any of its enumerators are used.\n\n\u25cf An anonymous union is used if any of its members are used.\n\n\u25cf The de9nition of a type includes the de9nition of its members and hidden friends.\n\n\u25cf The de9nition of a class template includes its partial and explicit specializations.\n\nRationale\n\nIf a type is declared but not used, then it is unclear to a reviewer if the type is redundant or it has been \nleft unused by mistake.\n\nException\n\nThis rule does not apply to:\n\n1. Types that have at least one declaration with the [[maybe_unused]] attribute.\n\n2. Template parameters.\n\n3. Partial or explicit specializations of class templates.\n\nExample\n\nint16_t f1()\n{\n  using T1 = int16_t;                   // Non-compliant\n  using T2 [[maybe_unused]] = int32_t;  // Compliant by exception #1\n\n  return 67;\n}\n\nnamespace\n{\n  struct A1 { A1 f(); };                // Compliant\n  struct A2 { A2 f(); };                // Non-compliant\n\n  struct A2;                            // Not a use of A2\n\n  A2 A2::f() { return *this; }          // Not a use of A2\n\n  template< typename T >                // Compliant by exception #2\n  void foo()\n  {\n    A1 a;                               // Use of A1\n    a.f();                              //  - even if foo is not instantiated\n  }\n}\n\ntemplate< bool cond >\ninline auto foo()\n{\n  struct res { int32_t i; };            // Compliant\n\n  if constexpr ( cond )\n  {\n    return 42;\n  }\n  else\n  {\n    return res { 42 };                  // res is utilized, even if cond is true\n  }\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\ftemplate< typename >\nint32_t bar()\n{\n  return 42;\n}\n\nint32_t f2()\n{\n  return bar< struct P >();             // Compliant - P is used\n}\n\nnamespace\n{\n  template< typename > struct C1 {};    // Non-compliant\n                                        //  - C1 only utilized in its definition\n\n  template<> struct C1< int32_t >       // Compliant by exception #3\n  {\n    void mbr()\n    {\n      C1< char > cc;\n    }\n  };\n}\n\nnamespace\n{\n  template< typename > struct C2 {};    // Compliant - C2< float > used\n\n  template<> struct C2< int32_t >;      // Compliant by exception #3\n\n  C2< float > cf;                       // Use of C2\n}\n\nnamespace\n{\n  static union                          // Non-compliant\n  {\n    int32_t i1;\n    int32_t j1;\n  };\n\n  static union                          // Compliant\n  {\n    int32_t i2;\n    int32_t j2;\n  };\n}\n\nvoid f3()\n{\n  ++i2;                                 // Uses the anonymous union holding i2\n}\n\nnamespace\n{\n  void f4()\n  {\n    []( auto ){};                       // Compliant - closure type is always used\n  }\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n25\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 0.2.4\n\nFunctions with limited visibility should be used at least once\n\nCategory Advisory\n\nAnalysis Decidable, System\n\nAmpli2cation\n\nA function has limited visibility if it:\n\nn\ne\ns\n\n1.\n\nIs declared in an anonymous namespace; or\n\n2.\n\nIs a member of a class in an anonymous namespace; or\n\n3. Has namespace scope and is declared static; or\n\n4.\n\nIs a private, non-virtual member.\n\nA function is used when:\n\n1.\n\nIts address is taken (including by reference); or\n\n2.\n\nIt is called; or\n\n3.\n\nIt is an operand of an expression in an unevaluated context; or\n\n4. Another function in the same overload set is used.\n\nThis rule does not apply to:\n\n1. Special member functions;\n\n2. Functions de9ned as = delete.\n\nRationale\n\nFunctions with limited visibility are not generally used within an extensible API. If they are present but \nremain unused, then there may be an issue in the software design. \n\nUnused functions in an overload set are acceptable as it allows the set to be internally consistent.\n\nException\n\nFunctions that have at least one declaration with the [[maybe_unused]] attribute are permitted to \nbe unused as the intent is explicit.\n\nExample\n\nstruct Foo\n{\n  int32_t m1()                      // Public - rule does not apply\n  {\n    return -1;\n  }\n\n  static int32_t m2()               // Class scope - rule does not apply\n  {\n    return 42;\n  }\n\n  Foo()\n  {\n    m3();\n  }\n\n26\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nprivate:\n  void m3() { }                     // Compliant - called\n  void m4() { }                     // Non-compliant - not used\n  void m5() { }                     // Compliant - used by a friend\n\n  friend void ( *f4() )();\n\nprotected:\n  void m6() { }                     // Protected - rule does not apply\n};\n\nstatic void f1() { }                // Non-compliant - not used\n\nnamespace\n{\n  void f2() { }                     // Non-compliant - not used\n}\n\nstatic void f3() { }                // Compliant - address taken in f4()\n\nvoid ( *f4() )()                    // Rule does not apply - visibility not limited\n{\n  Foo bar;\n\n  bar.m5();\n\n  return &f3;\n}\n\nnamespace A\n{\n  struct C1 {};\n  static void swap( C1 &, C1 & );   // Compliant - overload set for call in f5\n}\n\nnamespace B\n{\n  struct C2 {};\n  static void swap( C2 &, C2 & );   // Non-compliant\n}\n\nnamespace\n{\n  template< typename T >\n  void swap( T &, T & );            // Compliant - overload set for call in f5\n}\n\nvoid f5( A::C1 c1, A::C1 c2 )       // Rule does not apply - visibility not limited\n{\n  swap( c1, c2 );\n}\n\n4.0.3\n\nRuntime failures \n\n [misra]\n\nDir 0.3.1\n\nFloating-point arithmetic should be used appropriately\n\n[ISO/IEC/IEEE 60559]\n\nCategory Advisory\n\nAmpli2cation\n\nA tool should highlight all suspicious uses of ^oating-point arithmetic.\n\n27\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nRationale\n\nThe safe use of ^oating-point arithmetic requires a high level of numerical analysis skills and in-depth \nknowledge of the compiler and target hardware.\n\nThe incorrect use of floating-point may lead to problems related to the presence of positive and  \nnegative zero, loss of precision, NaNs (quiet and signalling), infinities, overflow, underflow, catastrophic \ncancellation, etc.\n\nn\ne\ns\n\nExample\n\nbool myIsNaN( double d )\n{\n  return d == std::numeric_limits< double >::quiet_NaN();  // Always returns false\n}\n\nvoid f()\n{\n  float f1 = 1E38f;\n  float f2 = 10.0f;\n  float f3 = 0.1f;\n  float f4 = ( f1 * f2 ) * f3;\n  float f5 = f1 * ( f2 * f3 );   // Values in f4 and f5 are significantly different\n}\n\nDir 0.3.2\n\nA function call shall not violate the function\u2019s preconditions\n\nCategory Required\n\nRationale\n\nViolating a function\u2019s implicit or explicit preconditions may lead to it exhibiting unexpected results or \nhaving unde%ned behaviour.\n\nExample\n\nfloat f( float a )\n{\n  return fmodf( a, 0.0f );      // 'fmodf' requires a non zero value\n}\n\n// Precondition for 'b1' is that 'v' is not empty\nint32_t b1( std::vector< int32_t > const & v )\n{\n  return v.front ();\n}\n\nint32_t b2()\n{\n  std::vector< int32_t > v;\n\n  return b1( v );            // Violates the precondition of b1\n}\n\n28\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f4.4\n\nGeneral principles\n\ns\ne\nn\n\n4.4.1\n\nImplementation compliance \n\n [intro.compliance]"
  },
  {
    "rule": "Rule 4.1.1\n\nA program shall conform to ISO/IEC 14882:2017 (C++17)\n\n[defns.well.formed]\n[intro.compliance]\n[MISRA Guidelines] / Table 3\n[IEC 61508-7] / Table C.1\n[ISO 26262-6] / Table 1\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nA conforming program shall be well-formed, meaning that it shall be constructed according to the \nsyntax rules, diagnosable semantic rules, and the one-definition rule, as specified for C++17 within \nISO/IEC 14882:2017 [8]. In addition, the program shall use only those features of the C++ language  \nand its library that are specified within the C++ Standard.\n\nThe use of language extensions is not permitted by this rule.\n\nNote: a conforming implementation usually generates a diagnostic if a program is not well-formed, but \nbe aware that:\n\n\u25cf The C++ Standard does not require a diagnostic for all constructs that are not well-formed;\n\n\u25cf A diagnostic need not necessarily be an error but could, for example, be a warning;\n\n\u25cf The program may be translated and an executable generated, even if the program is not well-\n\nformed.\n\nRationale\n\nUndesirable behaviours associated with language features that are extensions or which are speci9ed \noutside of the C++ Standard have not been considered during the development of the guidelines within \nthis document.\n\nThe behaviour of a program that is not well-formed is unpredictable.\n\nIt is recognized that it is sometimes necessary to use language extensions in embedded systems. If  \nan extension is used (subject to a deviation), then appropriate steps shall be taken to guarantee  \npredictable behaviour. This may be documented in a deviation permit to aid reuse, as explained in  \nMISRA Compliance [1].\n\nExample\n\n#warning \"declaring an interrupt handler\"    // Non-compliant\n__interrupt void handler();                  // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n29\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 4.1.2\n\nDeprecated features should not be used\n\n[depr]\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nn\ne\ns\n\nDeprecated features are those identi9ed in Annex D of the C++ Standard, excluding those in \n[depr.c.headers].\n\nRationale\n\nFeatures   are   deprecated   by   the   C++   Standard   when   they   are   superseded   by   safer   or   better \nalternatives, or are considered to exhibit undesirable behaviour. Features deprecated by a particular \nversion of the C++ Standard may be withdrawn in a later version.\n\nFor example:\n\n\u25cf The <codecvt> header was deprecated in C++17; and\n\n\u25cf The noexcept-speci%er throw was deprecated in C++17 (and removed in C++20).\n\nNote: use of the C versions of the C++ Standard Library headers ([depr.c.headers]) is not prohibited \nas these headers provide features that are equivalent to the ones in the C++ versions. \n\nExample\n\n#include <codecvt>        // Non-compliant - [depr.locale.stdcvt]\n\nvoid foo() throw()        // Non-compliant - [depr.except.spec]\n{\n}\n\nIn the following example, the generation of the copy constructor of   C1  is deprecated when the \ndestructor is user-declared: \n\nstruct C1\n{\n  ~C1() = default;\n};\n\nC1 c1a {};                // Compliant - no use of copy constructor\nC1 c1b { c1a };           // Non-compliant - [depr.impldec]"
  },
  {
    "rule": "Rule 4.1.3\n\nThere shall be no occurrence of unde%ned or critical unspeci%ed \nbehaviour\n\n[intro.abstract]\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nMany undefined and unspecified behaviours are covered by specific guidelines. This rule targets all other \nunde%ned and critical unspeci%ed behaviour.\n\n30\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nAn  unspeci%ed behaviour  within the C++ Standard is considered to be  critical  when it impacts the \nobservable behaviour of the abstract machine.\n\nFor example:\n\n\u25cf [expr.static.cast]/9 states that the value resulting from the explicit conversion of a scoped  \nenumeration type to an integral type is unspeci%ed if the value cannot be represented \u2014 this is \ncritical as it will have an impact on observable behaviour.\n\n\u25cf [global.functions]/1 states it is  unspecified  whether any non-member functions in the C++ \nStandard Library are defined as inline \u2014 this is not critical as it will not have an impact on \nobservable behaviour.\n\nRationale\n\nIt is not possible to reason about the behaviour of any program that contains instances of unde%ned  \nbehaviour. In addition, any program that contains instances of unspecified behaviour is not guaranteed \nto behave predictably. These types of behaviour can be particularly di[cult to detect during testing \nas the program may appear to behave as expected for a given set of test data.\n\nMany of the guidelines within this document have been designed to help ensure that certain undefined \nand unspecified behaviours are avoided. However, other behaviours are not covered by specific guidelines \n\u2014 for example, because there is no practical guidance that can be given, other than the obvious \nstatement that the behaviour should be avoided.\n\nNote: an implementation is permitted to provide well-defined behaviour for a behaviour that is otherwise \nstated within the C++ Standard as being undefined or unspecified. It will be necessary to raise a deviation \nagainst this rule if any such well-de9ned behaviour is relied upon, including by means of the use of a \nlanguage extension.\n\nExample\n\nThe following examples are non-compliant: \n\nu32a >> u32b                  // Undefined behaviour if u32b > 31\nstatic_cast< int8_t >( 128 )  // Unspecified - 128 is not representable as int8_t\n\n4.4.6\n\nProgram execution \n\n [intro.execution]"
  },
  {
    "rule": "Rule 4.6.1\n\nOperations on a memory location shall be sequenced appropriately\n\n[intro.execution] Unde9ned 17\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nA side effect on a memory location shall not be unsequenced or indeterminately sequenced with respect \nto any other side eCect on the same memory location, or any value computation using the value of \nany object in the same memory location.\n\nFor the purposes of this rule, all volatile accesses are considered to access a single, unique memory  \nlocation.\n\nRationale\n\nUnsequenced accesses to a memory location when one of the accesses has side effects results in  \nunde%ned behaviour.\n\n31\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n32\n\nAdditionally, indeterminately sequenced accesses could result in an expression yielding a different value \nfor diCering program states. This rule ensures that a program\u2019s behaviour is independent of the  \nevaluation order (such as the evaluation of function arguments) chosen by the compiler.\n\nAn access to a volatile v1 may have an eCect on another, seemingly unrelated, volatile v2. For this \nreason, this rule considers all volatile accesses as if they were to a single, unique memory location.\n\nNote: C++17 changed the evaluation order of several expressions from indeterminately sequenced to \nsequenced before, which means that code that is compliant with this rule may not work correctly with  \nearlier versions of C++.\n\nExample\n\nchar f( char & c, char a ) \n{\n  c = a;\n\n  return c;\n}\n\nvoid h( char a, char b );\n\nchar a;\n\nh( f( a, 'a' ), f( a, 'b' ) );   // Non-compliant - value of a could be 'a' or 'b'\n\nIn the following example, i is read twice and modi9ed twice. However, since C++17, the evaluation of \nthe right-hand side of an assignment is  sequenced before  the evaluation of the left-hand side (see \n[expr.ass]), so all accesses to i occur in a de9ned order: \n\na[ i++ ] = b[ i++ ];             // Compliant in C++17\n\nEven though there is no  unde%ned behaviour  in the following examples, they are non-compliant as \nthe uses of i are indeterminately sequenced with respect to their increments: \n\nx = b[ i ] + i++;                // Non-compliant\nx = func( i++, i );              // Non-compliant\n\nIn the following example, all accesses to volatile variables are considered to have side eCects on the \nsame memory location: \n\nextern volatile uint16_t v1;\nextern volatile uint16_t v2;\n\nuint16_t t = v1 + v2;            // Non-compliant - indeterminately sequenced\n\nv1 = v1 & 0x80u;                 // Compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f4.5\n\nLexical conventions\n\ns\ne\nn\n\n4.5.0 MISRA \n\n [misra]"
  },
  {
    "rule": "Rule 5.0.1\n\nTrigraph-like sequences should not be used\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nTrigraph-like sequences occur when the following character sequences appear in the source code: \n\n??=  ??/  ??'  ??(  ??)  ??!  ??<  ??>  ??-\n\nRationale\n\nTrigraphs were removed from the language in C++17. However, to prevent possible confusion, the \nsequences should not be used as it is unclear whether their replacement is expected.\n\nExample\n\nconst char * msg = \"(Date format is ??-??-??)\";     // Non-compliant\nconst char * msg = \"(Date format is ?\\?-?\\?-?\\?)\";  // Compliant\n\nSee also"
  },
  {
    "rule": "Rule 4.1.2\n\n4.5.7\n\nComments \n\n [lex.comment]"
  },
  {
    "rule": "Rule 5.7.1\n\nThe character sequence /* shall not be used within a C-style \ncomment\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nC++ does not support the nesting of C-style comments, even though some compilers support this as  \na non-portable language extension. A comment beginning with  /*  continues until the 9rst  */  is \nencountered.\n\nAny /* sequence occurring inside a C-style comment is a violation of this rule.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n33\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nExample\n\nConsider the following code fragment:\n\n/* Some comment, end comment marker accidentally omitted\n\nPerform_Critical_Safety_Function( X );\n/* <- this is non-compliant */\n\nIn reviewing the code containing the call to the function, the assumption is that it is executed. However, \nbecause the end comment marker is missing, the call to Perform_Critical_Safety_Function \nwill not be executed.\n\nDir 5.7.2\n\nSections of code should not be \u201ccommented out\u201d\n\nCategory Advisory\n\nAmpli2cation\n\nThis directive applies to the use of both // and /* ... */ style comments. \n\nFor the purposes of this directive, the use of #if 0 is also considered to be \u201ccommenting out\u201d.\n\nRationale\n\nComments should only be used to explain aspects of the source code; they should not be used to  \nrecord the history of changes to the source code.\n\nIn addition, whilst the nesting of C-style comments is not supported by the C ++ Standard, it is \nsupported by some compilers. This means that the commenting out of any code that contains  \ncomments may behave diCerently with diCerent compilers (see"
  },
  {
    "rule": "Rule 5.7.1).\n\nThis directive is generally undecidable, as it is not always possible for a tool to determine if a comment \ncontains explanatory text, a code example or commented out code.\n\nNote: it is acknowledged that it may be useful to quote statements or expressions as part of a larger  \ncomment in order to document and explain some aspect of the program (e.g. clarifying the use of a  \nfunction, or explaining the algorithm being implemented). Such usage is not the intended target of  \nthis directive.\n\nExample\n\nThe following compliant example documents an API with the use of pseudo-code. It is assumed that \ncode wrapped within the  ```  markup is recognized as documentation and is not commented out \ncode. \n\n// You should not call lock/unlock directly, but through RAII:\n// ```\n//   void f( Data & d, MyMutex & m )\n//   {\n//     std::scoped_lock lock { m };\n//     d.doSomething();\n//   }  // m is automatically unlocked\n// ```\n\nstruct MyMutex\n{\n  void lock();\n  void unlock();\n};\n\n34\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fThe following non-compliant example uses a comment to record code history. \n\ns\ne\nn\n\n// Bug 42 - this call used to be:\n//   calculate ( z , y + 1 );\ncalculate ( x , y - 1 );\n\nenum E\n{\n#if 0    // Non-compliant\n  E_0    // - this is considered to be commented out code\n#else\n  E_1\n#endif\n};\n\nSee also"
  },
  {
    "rule": "Rule 5.7.1"
  },
  {
    "rule": "Rule 5.7.3\n\nLine-splicing shall not be used in // comments\n\n[lex.phases] Unde9ned 1\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule is applied in translation phase 2, after multibyte characters have been mapped to the basic  \nsource character set during translation phase 1 (see [lex.phases]).\n\nRationale\n\nLine-splicing occurs when the \\ character is immediately followed by a new-line character. If a source \nline containing a // comment ends with a \\ character in the basic source character set, the next line \nbecomes part of the comment. This may result in the unintentional removal of code. \n\nExample\n\nIn the following non-compliant example, the physical line containing the if keyword is logically part \nof the previous line and is therefore part of a comment. \n\nvoid f( bool b )\n{\n  uint16_t x = 0U;   // comment \\\n  if ( b )\n  {\n    ++x;             // This is always executed\n  }\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n35\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\n4.5.10 Identi2ers \n\n [lex.name]"
  },
  {
    "rule": "Rule 5.10.1 User-de9ned identi9ers shall have an appropriate form\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\n[macro.names] Unde9ned 2\n[lex.name] NDR 3\n[lex.key]\n[extern.types]\n[usrlit.su[x]\n[namespace.std] Unde9ned 1\n[namespace.posix] Unde9ned 1\n\nWhen introducing an identi9er, it shall be formed according to the following rules:\n\n1. A universal-character-name used at the start of an identi9er shall be:\n\na.\n\nIn the range [a-z], [A-Z] or _ or\n\nb. Within the character class XID_Start, as de9ned by the Unicode standard UAX #44 [13].\n\n2. A universal-character-name within an identi9er shall be:\n\na. One of the characters allowed at the start of an identi9er; or\n\nb. Within the character class XID_Continue, as de9ned by the Unicode standard UAX #44 [13].\n\n3. All identi9ers shall conform to Normalization Form C, as speci9ed in ISO/IEC 10646 [7].\n\n4. An identi9er shall not contain a double underscore __.\n\n5. An identi9er that is not used as a literal su[x shall not start with _.\n\n6. A user-de9ned literal su[x shall start with a single _ and shall not be preceded by a space.\n\nA macro identifier shall additionally only be formed using characters in the ranges [A-Z], [0-9] and _.\n\nOther identi9ers shall additionally:\n\n1. Not be de9ned in namespace std, posix, or stdN, where 'N' is any number; and\n\n2. Not appear in the list defined, final, override, clock_t, div_t, FILE, fpos_t, lconv, \n\nldiv_t, mbstate_t, ptrdiff_t, sig_atomic_t, size_t, time_t, tm, va_list,  \nwctrans_t, wctype_t or wint_t.\n\nNote: this rule does not apply to template specializations, as they do not introduce new identi9ers \u2014  \nsee [temp.expl.spec].\n\nRationale\n\nThis rule prohibits the introduction of an identi9er with a reserved name, and restricts the characters \npermitted within identi9ers to a subset of those that are currently permitted by the C++ Standard. \nThis subset is aligned with Unicode recommendations that are expected to be adopted in a future \nrevision of the C++ Standard.\n\nFor macro names, this rule further restricts the set of permitted characters for the following reasons:\n\n1.\n\nIt enforces commonly accepted coding style;\n\n2.\n\nIt helps distinguishing macros from other identi9ers;\n\n36\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f3.\n\nIt prevents collision with the name of an attribute de9ned within the C++ Standard or with any \nname de9ned in the C++ Standard Library, preventing undefined behaviour (even when the \ncorresponding header %le is not explicitly included);\n\n4.\n\nIt prevents collision with keywords or alternative representations, preventing undefined behaviour.\n\nThe restrictions always prohibit the use of identifiers that are only prohibited by the C ++ Standard \nwithin certain contexts (and for which no diagnostic is required in some cases). This rule broadens  \nthe context in which these identi9ers are not acceptable in order to reduce the risk of confusion.\n\nExample\n\nint32_t i\ufd3e = 2;                    // Non-compliant - character \\ufd3e (even though\n                                   // it may compile)\n\n#define identity(a) a              // Non-compliant - shall be in uppercase\n\nvoid f()\n{\n  auto _i = 0;                     // Non-compliant - using a leading _, even at \n                                   // local scope, is prohibited\n}\n\nvoid operator \"\"_km( long double );     // Compliant - will be called for 1.0_km\nvoid operator \"\"mil( long double );     // Non-compliant - user-defined literal \n                                        // suffixes shall start with _\n\ndouble operator \"\"_Bq ( long double );  // Compliant\ndouble operator \"\" _Bq( long double );  // Non-compliant - _Bq is preceded by a\n                                        // space, making it a reserved identifier\n\nnamespace std42\n{\n  inline namespace a\n  {\n    int i;                         // Non-compliant - defined within namespace stdN\n  }\n}\n\nauto final = 42;                   // Non-compliant\n\n#include <cstdio>                  // Compliant - even though it introduces FILE\n\nnamespace std\n{\n  template <> struct hash< A >     // Rule does not apply\n  {\n    size_t operator()( const A & x ) const;\n  };\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n37\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\n4.5.13 Literals \n\n [lex.literal]"
  },
  {
    "rule": "Rule 5.13.1 Within character literals and non raw-string literals, \\ shall only be \n\nused to form a de9ned escape sequence or universal character \nname\n\n[lex.ccon] Implementation 7, 9\n[lex.string] / 15\n\nn\ne\ns\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe escape sequences de9ned within the C++ Standard are: \n\n\\n, \\t, \\v, \\b, \\r, \\f, \\a, \\\\, \\?, \\', \\\", \\<Octal Number>, \\x<Hexadecimal Number>\n\nThe universal character names are: \n\n\\u hex-quad, \\U hex-quad hex-quad\n\nRationale\n\nThe use of an unde9ned escape sequence results in implementation-de%ned behaviour.\n\nExample\n\nvoid fn()\n{\n  const char * a = \"\\k\";          // Non-compliant\n  const char * b = \"\\b\\u00E9\";    // Compliant\n}"
  },
  {
    "rule": "Rule 5.13.2 Octal escape sequences, hexadecimal escape sequences and \nuniversal character names shall be terminated\n\n[lex.charset]\n[lex.icon] Implementation 2, 3\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nAn octal escape sequence, hexadecimal escape sequence or universal character name shall be  \nterminated by either:\n\n\u25cf The start of another escape sequence or universal character name; or\n\n\u25cf The end of the character constant or the end of a string literal.\n\nRationale\n\nThere is potential for confusion if an octal escape sequence, hexadecimal escape sequence or universal \ncharacter name is followed by other characters. For example, the string literal  \"\\x1f\"  is a single-\ncharacter, zero-terminated string, whereas \"\\x1g\" includes the two characters '\\x1' and 'g'. The \n\n38\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fpotential for confusion is reduced if every octal escape sequence, hexadecimal escape sequence or \nuniversal character name in a character constant or string literal is terminated.\n\nExample\n\nconst char * s1 = \"\\1234\";       // Non-compliant - \\123 is not terminated\n\nIn the following, the strings pointed to by s2, s3 and s4 are equivalent to \"Ag\". \n\nconst char * s2 = \"\\x41g\";       // Non-compliant\nconst char * s3 = \"\\x41\" \"g\";    // Compliant - terminated by end of literal\nconst char * s4 = \"\\x41\\x67\";    // Compliant - terminated by another escape\n\nIn the following, s5 contains a universal character name consisting of four hex digits (\\u), whilst s6 \ncontains a universal character name consisting of eight hex digits (\\U). \n\nconst char * s5 = \"\\u0001F600\";  // Non-compliant - \\u0001 is not terminated\nconst char * s6 = \"\\U0001F600\";  // Compliant - terminated by end of literal\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS"
  },
  {
    "rule": "Rule 5.13.3 Octal constants shall not be used\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nAny integer constant beginning with a 0 (zero) is an octal constant. Because of this, a zero-pre9xed \nconstant that is intended to be a decimal number may be interpreted as an octal number, contrary \nto developer expectations. \n\nNote: this rule does not apply to octal escape sequences because the use of a leading  \\ character \nmeans that there is less scope for confusion.\n\nException\n\nThe integer constant 0 (written as a single numeric digit) is an octal constant, but its use is permitted \nas an exception to this rule.\n\nExample\n\ncode[ 1 ] = 109;      // Compliant     - decimal 109\ncode[ 2 ] = 100;      // Compliant     - decimal 100\ncode[ 3 ] = 052;      // Non-compliant - equivalent to decimal 42, not 52\ncode[ 4 ] = 071;      // Non-compliant - equivalent to decimal 57, not 71\ncode[ 5 ] = 0;        // Compliant by exception\ncode[ 6 ] = 000;      // Non-compliant - exception does not apply\ncode[ 7 ] = '\\123';   // Rule does not apply"
  },
  {
    "rule": "Rule 5.13.4 Unsigned integer literals shall be appropriately su[xed\n\n[lex.icon]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to any integer-literal that exists after preprocessing. It does not apply to user-de%ned-\ninteger-literals.\n\n39\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nAn unsigned integer-suffix is required when the type of the integer literal, as specified by the C++ \nStandard in [lex.icon], is unsigned.\n\nNote:  this rule does not depend on the context in which a literal is used; promotion and other  \nconversions that may be applied to the value are not relevant in determining compliance with this rule.\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nRationale\n\nThe type of an integer literal is a potential source of confusion, because it is dependent on a complex \ncombination of factors including:\n\n\u25cf The magnitude of the constant;\n\n\u25cf The implemented sizes of the integer types;\n\n\u25cf The presence of any su[xes;\n\n\u25cf The number base that is used.\n\nFor example, the decimal  integer literal  32768  always has signed type. However, the  integer literal \n0x8000  is of type  unsigned int  in a 16-bit environment, but of type  signed int  in a 32-bit \nenvironment. Adding a U or u su[x to the integer literal makes the signedness of the value explicit on \na 16-bit platform.\n\nNote: compliance checks against this rule will only be valid if an analysis tool has been con9gured with \nthe same integer sizes as the compiler that is being used within the project.\n\nExample\n\nThe following examples assume that int is 16 bits: \n\n    auto x = 32768;     // Compliant - signed type\n    auto y = 0x8000;    // Non-compliant - unsigned type\nuint16_t z = 123;       // Compliant - 'u' is not required as '123' is signed\n\nvoid f( uint16_t );     // #1\nvoid f(  int16_t );     // #2\n\nvoid b()\n{\n  f( 0x8000  );         // Non-compliant - calls #1 as 0x8000 is unsigned\n  f( 0x8000u );         // Compliant - calls #1\n  f( 0x7FFF  );         // Compliant - calls #2 as 0x7FFF is signed\n  f( 0x7FFFu );         // Compliant - calls #1\n}"
  },
  {
    "rule": "Rule 5.13.5\n\nThe lowercase form of L shall not be used as the 9rst character in a \nliteral su[x\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule does not apply to user-de%ned-literals.\n\nRationale\n\nUsing the uppercase su[x L removes the potential ambiguity between 1 (digit 1) and l (lowercase L) \nwhen declaring numeric literals. The ambiguity only occurs when lowercase L is used as the first letter \nof a suffix.\n\n40\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fExample\n\nint64_t const    a = 0L;      // Compliant\nint64_t const    b = 0l;      // Non-compliant\n\nuint64_t const   c = 1Lu;     // Compliant\nuint64_t const   d = 1lU;     // Non-compliant\n\nuint64_t const   e = 2uLL;    // Compliant\nuint64_t const   f = 2Ull;    // Compliant\n\nlong long const  g = 3LL;     // Compliant\nlong long const  h = 3ll;     // Non-compliant\n\nlong double const i = 1.2L;   // Compliant\nlong double const j = 3.4l;   // Non-compliant\n\nconstexpr Litre operator\"\" _l( long double val ) noexcept \n{ \n  return Litre { val };       // Assumes type Litre is defined\n}\n\nauto volume = 42.1_l;         // Rule does not apply"
  },
  {
    "rule": "Rule 5.13.6 An integer-literal of type long long shall not use a single L or l in \n\nany su[x\n\n[lex.icon]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to both signed long long and unsigned long long literals.\n\nNote: this rule does not apply to user-de%ned-literals.\n\nRationale\n\nA literal with a suffix that has a single L could be a signed or unsigned long long. Use of the LL \nsu[x for long long literals is more explicit and less error-prone.\n\nExample\n\nAll of the following examples assume that long is 32-bits and long long is 64-bits. \n\nauto k1 = 12345678998L;        // Non-compliant\nauto k2 = 12345678998UL;       // Non-compliant\nauto k3 = 12345678998ull;      // Compliant\nauto k4 = 0xfeeddeadbeefL;     // Non-compliant\nauto k5 = 0xfeeddeadbeefLL;    // Compliant\n\nThe rule does not apply to the following as the value is not long long: \n\nauto k6 = 12345L; \nauto k7 = 12345UL;\nauto k8 = 0x0badc0deL;\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n41\n\n \n \n\fThe rule does not apply to the following as they do not have L or l su[xes:\n\nauto k9 = 12345678998;\nauto kA = 12345678998U;\n\nSee also"
  },
  {
    "rule": "Rule 5.13.5\n\nS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns"
  },
  {
    "rule": "Rule 5.13.7\n\nString literals with diCerent encoding pre9xes shall not be \nconcatenated\n\n[lex.string] Implementation 13\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe encoding pre9xes are:\n\n\u25cf L \u2014 wide string literal;\n\n\u25cf u8 \u2014 UTF-8 string literal;\n\n\u25cf u \u2014 char16_t string literal;\n\n\u25cf U \u2014 char32_t string literal.\n\nFor the purposes of this rule, an empty encoding-pre9x is considered to be diCerent to a non-empty  \nencoding-pre9x, even when they have the same meaning. \n\nNote: the R pre9x is not an encoding-pre9x.\n\nRationale\n\nConcatenation of string literals with diCerent encoding pre9xes is either  ill-formed  or  conditionally-\nsupported with implementation-defined behaviour. The behaviour related to the concatenation of string \nliterals with and without encoding prefixes has changed as the C++ Standard has evolved. Concatenations \nof  these  forms  are  not  permitted  to  ensure  that  the  behaviour  is  as  expected,  especially  in  the \npresence of legacy code.\n\nWhen concatenating a string literal with a pre9x with one having no pre9x, the behaviour is as if both \nhave the same encoding pre9x. For example, the concatenation  u8\"\" \"\\u00fc\" is equivalent to \nu8\"\\u00fc\" (0xc3 0xbc \u2014 for some character set) and not \"\\u00fc\" (0xfc), which may not meet \ndeveloper expectations. This rule is therefore stricter than the C++ Standard, and considers an empty \nencoding-pre9x to be diCerent to a non-empty encoding-pre9x.\n\nNote: concatenation of string literals with diCerent encoding pre9xes is likely to become ill-formed in a \nfuture version of the C++ Standard.\n\nExample\n\nconst char    * s0 =  \"Hello\"  \"World\";         // Compliant\nconst wchar_t * s1 = L\"Hello\" L\"World\";         // Compliant\n\nconst wchar_t * s2 =   \"Hello\" L\"World\";        // Non-compliant\nconst wchar_t * s3 =  u\"Hello\" L\"World\";        // Non-compliant - may not compile\n                  // u8\"Hello\" L\"World\";        // Ill-formed\n\n42\n\nconst char    * s4 = u8R\"#(Hello)#\" u8\"World\";  // Compliant\nconst char    * s5 = u8R\"#(Hello)#\"   \"World\";  // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f4.6\n\nBasic concepts\n\n4.6.0 MISRA \n\n [misra]"
  },
  {
    "rule": "Rule 6.0.1\n\nBlock scope declarations shall not be visually ambiguous\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA block scope declaration is visually ambiguous when:\n\n\u25cf It declares a function; or\n\n\u25cf It declares an object with redundant parentheses surrounding the object\u2019s name.\n\nNote: this rule does not apply to Lambda expressions as they are not function declarations.\n\nRationale\n\nDue to the syntactic similarity of function declarations and object de9nitions that use parentheses for \ninitialization, it is possible that a declaration may be misinterpreted by the developer. For example, a \nfunction declaration may be interpreted as an object de9nition, which is sometimes referred to as \nthe most-vexing parse. \n\nThe C++ grammar allows for redundant parentheses around a declarator, where what appears to be \nthe construction of an object with a single argument to the constructor is actually the declaration of \nan object of that \u201cargument\u201d name and a call to the default constructor.\n\nNote: using braces instead of parentheses for object initialization, where possible, avoids the most-\nvexing parse.\n\nExample\n\nclass A {};\n\nvoid f1()\n{\n  void f2();       // Non-compliant - function declaration at block scope\n  A a1();          // Non-compliant - appears to declare an object with no\n                   // arguments to constructor, but it declares a function\n                   // 'a1' returning type 'A' and taking no parameters.\n  A a2;            // Compliant\n}\n\nint32_t j;\n\nvoid f3()\n{\n  int32_t ( j );   // Non-compliant - declares 'j' (using redundant parentheses)\n  int32_t { j };   // Compliant with this rule, but violates \"See also\"\n}                  //   - Creates a temporary object with value 'j'.\n\nSee also"
  },
  {
    "rule": "Rule 9.2.1\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n43\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 6.0.2 When an array with external linkage is declared, its size should be \n\nexplicitly speci9ed\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nn\ne\ns\n\nThis rule applies to non-de9ning declarations only. It is possible to de9ne an array and specify its size \nimplicitly by means of initialization.\n\nRationale\n\nAlthough it is possible to declare an array with incomplete type and access its elements, it is safer to \ndo so when the size of the array may be explicitly determined. Providing size information for each  \ndeclaration permits them to be checked for consistency. It may also permit a static checker to perform  \nsome array bounds analysis without needing to analyse more than one translation unit.\n\nExample\n\n       int32_t array1[ 10 ];                // Compliant\nextern int32_t array2[ ];                   // Non-compliant\n       int32_t array3[ ] = { 0, 10, 15 };   // Compliant\nextern int32_t array4[ 42 ];                // Compliant"
  },
  {
    "rule": "Rule 6.0.3\n\nThe only declarations in the global namespace should be main, \nnamespace declarations and extern \"C\" declarations\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule also prohibits use of using directives and inline namespaces in the global namespace.\n\nIt does not apply to  namespace aliases,  static_assert  or to names that are declared within the \nC++ Standard.\n\nRationale\n\nDeclaring names into appropriate  namespaces  reduces the names found during lookup, helping to \nensure that the names found meet developer expectations.\n\nAdherence with this rule is particularly important within header %les, as it reduces the chance that the \norder of their inclusion will aCect program behaviour.\n\nNotes:\n\n1. Using directives and inline namespaces do not actually add names to the global namespace, but \n\nthey do make them appear as if they are in it.\n\n2. Names declared within an  anonymous namespace  appear in the  global namespace. However, \n\ntheir use is permitted as they do not have external linkage.\n\nExample\n\n44\n\nvoid f1( int32_t );        // Non-compliant\n\nint32_t x1;                // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fnamespace                  // Compliant\n{\n  void f2( int32_t );      // Rule does not apply\n\n  int32_t x2;              // Rule does not apply\n}\n\nnamespace MY_API           // Compliant\n{\n  void b2( int32_t );      // Rule does not apply\n\n  int32_t x2;              // Rule does not apply\n}\n\nusing namespace MY_API;    // Non-compliant\nusing MY_API::b2;          // Non-compliant\nnamespace MY = MY_API;     // Compliant\n\nint main()                 // Compliant\n{\n  extern void f3();        // Non-compliant\n}"
  },
  {
    "rule": "Rule 6.0.4\n\nThe identi9er main shall not be used for a function other than the \nglobal function main\n\n[basic.start.main] Implementation 2, 3\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule also applies to any other entry points de9ned by the implementation.\n\nRationale\n\nmain (or its equivalent) is the entry point to the program and is the only identi9er which must be in \nthe global namespace. The use of main for other functions may not meet developer expectations.\n\nExample\n\nint main()        // Compliant\n{\n}\n\nnamespace\n{\n  int main()      // Non-compliant\n  {\n  }\n}\n\nnamespace NS\n{\n  int main()      // Non-compliant\n  {\n  }\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n45\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n4.6.2 One-de2nition rule \n\n [basic.def.odr]\n\nIn essence, the requirement for the  one-de%nition rule  arises because C++ compilers usually treat \neach source 9le (with any included header %les) as separate translation units, where each translation  \nunit is compiled in isolation. The set of compiled translation units is then linked together to form the \nexecutable program.\n\nThe linker is allowed to assume that objects, templates, types, etc. that share the same name in \ndiCerent translation units refer to the same de9nition. There are no guarantees that violations of that \nassumption will be diagnosed.\n\nIn the following example, the same struct S appears to be de9ned in both translation units, but the \nde9nitions are not the same, so the result is not what the developer expects.\n\n// Program A: file1.cpp\nstruct S\n{\n  int32_t x;\n  int32_t y;\n};\n\nint32_t XminusY( S & s )\n{\n  return ( s.x \u2013 s.y );\n}\n\n// Program A: file2.cpp\nstruct S\n{\n  int32_t y;  // Note that the order of x and y is different\n  int32_t x;\n};\n\nvoid setX( S & s, int32_t v ) { s.x = v; }\nvoid setY( S & s, int32_t v ) { s.y = v; }\n\nThis program contains  unde%ned behaviour; one possible outcome is that the result of  XminusY  is \ny - x.\n\nAs stated above, the linker is not required to check the compatibility of the two de9nitions; the  one-\nde%nition rule puts the onus on the developer to ensure that the de9nitions are compatible. The rules \nwithin this section reinforce the need to follow the one-definition rule, and provide specific instructions \nto the developer."
  },
  {
    "rule": "Rule 6.2.1\n\nThe one-de%nition rule shall not be violated\n\n[basic.def.odr] Unde9ned 6.6\n\nCategory Required\n\nAnalysis Decidable, System\n\nRationale\n\nViolation of the one-de%nition rule (ODR) results in unde%ned behaviour \u2014 for example, when an entity \nhas:\n\n\u25cf No de9nition; or\n\n\u25cf Multiple non-inline de9nitions in diCerent translation units; or\n\n\u25cf Multiple inline de9nitions in diCerent translation units that are not the same; or\n\n46\n\n\u25cf DiCerent initializer values.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fExample\n\n// File a.cpp\nstruct S1\n{\n  int32_t i;\n};\n\nstruct S2\n{\n  int32_t i;\n};\n\n// File b.cpp\nstruct S1\n{\n  int64_t i; \n};                          // Non-compliant - definitions of S1 are not the same\n\nstruct S2\n{\n  int32_t i; \n  int32_t j;\n};                          // Non-compliant - definitions of S2 are not the same\n\nThe following example is non-compliant as File1.cpp and File2.cpp introduce different definitions \nof h, with the call they contain to f resolving to diCerent overloads in each de9nition. \n\n// File1.h\nvoid f( int32_t i );\n\n// File2.h\nvoid f( int64_t i );\n\n// File3.h\ninline void h( int64_t i )\n{\n  f( i );                   // Nested call\n}\n\n// File1.cpp\n#include \"File1.h\"\n#include \"File3.h\"\n\nvoid f1()\n{\n  h( 42 );                  // Nested call in h is to int32_t overload of f\n}\n\n// File2.cpp\n#include \"File2.h\"\n#include \"File3.h\"\n\nvoid f2()\n{\n  h( 42 );                  // Nested call in h is to int64_t overload of f\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n47\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n48"
  },
  {
    "rule": "Rule 6.2.2\n\nAll declarations of a variable or function shall have the same type\n\n[basic.def.odr] NDR 2; Unde9ned 5\n[dcl.link]\n[over.load] / 2.1\n[dcl.attr.noreturn] NDR 1\n\nCategory Required\n\nAnalysis Decidable, System\n\nAmpli2cation\n\nTwo variable declarations with the same name refer to the same variable if they have the same scope. \nTwo function  declarations  with the same name refer to the same function if they have the same \nscope and have equivalent parameter declarations (see [over.dcl]/1). Declarations of variables in the \nglobal scope and declarations of variables and functions with C linkage that have the same identi9er \ndeclare a single entity (note there is no overloading in C).\n\nFor the purposes of this rule:\n\n1. An array declared with an unknown bound has the same type as an array declared with the \n\nsame element type and a known bound; and\n\n2. A pointer to an incomplete type has the same type as a pointer to the complete type.\n\nThe following restrictions apply:\n\n1. When several declarations of the same entity exist, they shall have the same type;\n\n2. All declarations of a function declared with the [[noreturn]] attribute shall have that attribute \n\n(see [dcl.attr.noreturn]).\n\nNote: functions with C linkage are always distinct from functions with C++ linkage.\n\nRationale\n\nIt is unde%ned behaviour if the declarations of a variable or function in two diCerent translation units \ndo not have the same type.\n\nWhile attributes are not part of a function type, inconsistent use of the  [[noreturn]]  attribute \nresults in an ill-formed (no diagnostic required) program.\n\nExample\n\nAll the declarations of f3 in the following 9les con^ict with each other and are non-compliant. \n\n// File a.cpp\ntypedef int32_t myint;\nextern     int32_t a;                // Non-compliant - see b.cpp\nextern     int32_t b [];             // Compliant\nextern     char    c;                // Non-compliant - see b.cpp\nextern     int32_t d;                // Compliant\nextern     myint e;                  // Compliant\n\n           int32_t f1();             // Non-compliant - see b.cpp\n           int32_t f2( int32_t );    // Compliant\nextern \"C\" int32_t f3( int32_t );    // Non-compliant\n           int32_t f4();             // Non-compliant - see b.cpp\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f// File b.cpp\nextern     int64_t a;                // Non-compliant - see a.cpp\nextern     int32_t b [ 5 ];          // Compliant\n           int16_t c;                // Non-compliant - see a.cpp\n           int32_t d { 1 };          // Compliant\n           int32_t e;                // Compliant\n\n           char f1();                // Non-compliant - see a.cpp\n           char f2( char );          // Compliant - not the same function as\n                                     //             int32_t f2( int32_t )\nextern \"C\" int32_t f3( char );       // Non-compliant\n           int32_t f4() noexcept;    // Non-compliant - see a.cpp\n                                     //   Different exception specification\n\n// File c.cpp\nextern \"C\" int32_t f3;               // Non-compliant\n\n// File d.cpp\nint32_t f3;                          // Non-compliant"
  },
  {
    "rule": "Rule 6.2.3\n\nThe source code used to implement an entity shall appear only once\n\n[basic.def.odr] Unde9ned 6.6; NDR 4\n\nCategory Required\n\nAnalysis Decidable, System\n\nAmpli2cation\n\nFor the purposes of this rule, an entity is a variable, type, function, or template thereof.\n\nNote: multiple different specializations for the same primary template and multiple overloads for a \nfunction with the same name but with diCerent signatures are diCerent entities.\n\nThis rule requires that the source code used to implement an entity shall appear only once within a \nproject. If the entity is inline, it can be implemented within a header %le; it is permitted to include such \na header %le in multiple translation units.\n\nAdditionally, explicit specializations of templates shall either be implemented in the same 9le as the \nprimary template, or in a 9le where one of the fully specialized arguments is de9ned. \n\nNote: an entity may have no implementation \u2014 for example, an incomplete type does not need a  \nde9nition when it is used as a tag.\n\nRationale\n\nNon-inline entities shall only be defined once in a program. Inline entities can be defined once for each \ntranslation unit, but the de9nitions shall be identical. This principle is known as the one-de%nition rule.\n\nRequiring that the source code for the de9nition of any entity appears only once reduces the risk of \nviolating the one-de%nition rule and makes the code simpler.\n\nThe declaration of a template\u2019s explicit specialization must be visible when it matches the arguments \nof   the   template   that   is   being   instantiated,   otherwise,   an  implicit   specialization  will   be   generated, \nviolating the one-de%nition rule. Implementing an explicit specialization in the same 9le as the primary  \ntemplate or the argument for which it is specialized ensures that this constraint is satis9ed.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n49\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nExample\n\n// file1.h\ninline int16_t i = 10;\n\n// file2.h \ninline int16_t i = 10;              // Non-compliant - two definitions of i\n\nThe following example demonstrates inconsistent de9nitions of b: \n\nn\ne\ns\n\n// file1.cpp\nint16_t b;                          // Non-compliant - ill-formed (see file2.cpp)\n\n// file2.cpp\nint32_t b;                          // Non-compliant - ill-formed (see file1.cpp)\n\nIn the following example, the full template specialization within a different file results in a violation of the \none-definition rule (which is not the case for the template specialization A< D >, as that is within the file \nthat de9nes D): \n\n// a.h - #include guard omitted for brevity\ntemplate< typename T >\nclass A {};\n\n// b.h\n#include \"a.h\"\n\nA< int32_t > const a1 {};\n\n// c.h\n#include \"a.h\"\n\ntemplate<>\nclass A< int32_t > {};              // Non-compliant\n\n// d.h\n#include \"a.h\"\n\nclass D {};\n\ntemplate<>\nclass A< D > {};                    // Compliant\n\n// main.cpp\n#include \"b.h\" \n#include \"c.h\"                      // ODR violation\n#include \"d.h\"\nA< D > const a2 {};                 // OK - requires inclusion of d.h\n\nIn the following example, the partial template specialization within a diCerent 9le results in a violation \nof the one-de%nition rule: \n\n// wrap.h\ntemplate< typename V >\nstruct wrap\n{\n  V value;\n};\n\n// wrap_ptr.h\n#include \"wrap.h\"\n\ntemplate< typename V >\nstruct wrap< V * > {}               // Non-compliant - should be in wrap.h\n\n50\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f// w.cpp \n#include \"wrap.h\"                   // No specialization visible\n\nwrap< char * > a_wrap;              // ODR violation - see wp.cpp\n\n// wp.cpp \n#include \"wrap_ptr.h\"               // Specialization visible\n\nwrap< char * > b_wrap;              // ODR violation - see w.cpp"
  },
  {
    "rule": "Rule 6.2.4\n\nA header %le shall not contain de9nitions of functions or objects that \nare non-inline and have external linkage\n\n[basic.def.odr]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule prohibits the de9nition within a header %le of non-inline:\n\n\u25cf Namespace-scope variables; and\n\n\u25cf Namespace-scope functions; and\n\n\u25cf Static and non-static member functions; and\n\n\u25cf Non-const, static data members.\n\nThis rule does not apply to entities without linkage (scope local entities) or entities with internal linkage.\n\nRationale\n\nHeader %les should be used to declare C++ templates, types, functions, references and objects. \n\nDe9ning a non-inline entity (function or object) with external linkage in a header %le causes a violation \nof the  one-de%nition rule  when that  header %le  is included in multiple  translation units, resulting in \nunde%ned behaviour. \n\nWhilst de9ning non-inline entities with internal linkage in header %les can cause needless duplication, \nit is not a violation of this rule.\n\nEntities de9ned explicitly or implicitly as inline, or without external linkage, can appear in header %les \nwithout   risking   violation   of   the  one-de%nition   rule  if   all   de9nitions   across   all  translation   units  are \nconsistent. The latter can be guaranteed by using a single  header %le  to de9ne such an  entity  (see"
  },
  {
    "rule": "Rule 6.2.3).\n\nExample\n\n// Header file a.h\n       void f1();           // Rule does not apply - not a definition\n       void f2() { }        // Non-compliant\ninline void f3() { }        // Compliant\n\ntemplate< typename T >\nvoid f4( T ) { }            // Compliant - implicitly inline\n\nint32_t a;                  // Non-compliant\n\nconstexpr auto ans { 42 };  // Compliant - no external linkage\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n51\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nstruct X\n{\n  int32_t a;                // Compliant - no linkage\n  inline static const \n  int32_t b { 2 };          // Compliant - X::b has external linkage but is inline\n};\n\nSee also"
  },
  {
    "rule": "Rule 6.2.1,"
  },
  {
    "rule": "Rule 6.2.3\n\n4.6.4\n\nName lookup \n\n [basic.lookup]"
  },
  {
    "rule": "Rule 6.4.1\n\nA variable declared in an inner scope shall not hide a variable \ndeclared in an outer scope\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA variable declaration in an inner scope is considered to hide a variable in an outer scope when it has the \nsame name and the variable in the outer scope would be found by name lookup in the inner scope at \na point immediately before the declaration.\n\nThe terms outer scope and inner scope are de9ned as follows:\n\n1. The global scope is the outermost scope;\n\n2. Each block (compound-statement), namespace or class introduces an inner scope;\n\n3.\n\nIn a function definition, the function parameters have the same scope as the corresponding \nfunction body (compound-statement or function-try-block);\n\n4. A derived class is treated as an inner scope with respect to the base class;\n\n5. The de9nition of a member function introduces an inner scope to the class\u2019s de9nition;\n\n6. The selection-statements and iteration-statements introduce an inner scope which contains the \n\ncontrolled statement(s) and corresponding condition and init-statement.\n\nIf  declarations  from a namespace are introduced into a scope by a  using-declaration, then they are \ntreated as though they were declared in that scope.\n\nFor the purposes of this rule, the following are treated as the declaration of variables:\n\n1. All data member and function parameter declarations; and\n\n2. The enumerators of an unscoped enumeration type (which have the same scope as the \n\nenumeration type).\n\nRationale\n\nIdenti9er hiding may lead to developer confusion.\n\nNote: this rule prevents the name of a global variable from being reused as the name of a local variable.\n\nException\n\nA class constructor may have a parameter with the same name as a member variable, provided the  \nonly use made of that parameter is to initialize the member. This is a common idiom that poses no  \nrisk.\n\n52\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fExample\n\nint16_t i;\n\nvoid f1()\n{\n  int32_t i;                // Non-compliant - hides i in global scope\n  int32_t z;\n\n  if ( i == 3 )             // It could be confusing as to which i this refers\n  {\n    int32_t z;              // Non-compliant - hides z before if\n  }\n}\n\nvoid f2( int8_t i )         // Non-compliant - hides i in global scope\n{\n}\n\nclass C \n{\n  float i;                  // Non-compliant - hides i in global scope\n  float j;\n\npublic:\n  C ( float j )             // Compliant by exception\n    : j ( j ) {}\n\n  C ( float j, float k )\n    : j ( j )\n  {\n    j += k;                 // Non-compliant - 'j' hides C::j\n  } \n\n  void f3() \n  {\n    int32_t j = 0;          // Non-compliant - hides C::j\n  }\n};\n\nnamespace NS1\n{\n  int32_t i;                // Non-compliant - hides i in global scope\n\n  void f4( int32_t j )      // Compliant - parameter j does not hide C::j\n  {\n    int32_t l = i + j;      // Compiles using ::i if NS1::i declaration removed\n  }\n}\n\nnamespace NS2\n{\n  int32_t v;\n}\n\nusing NS2::v;\n\nvoid f5()\n{\n  float v;                  // Non-compliant - using hides NS2::v in global scope\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n53\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nenum E { e0, e1, e2 };\n\nnamespace\n{\n  int32_t e1 = 32;          // Non-compliant - hides e1 member of E (in global\n}                           // scope)\n\nNote that compiler reporting of a  redeclaration  error against  para  is inconsistent for the following \nexample: \n\nn\ne\ns\n\nint16_t f6( int16_t para )  // 'para' has same scope as function body\ntry\n{                           // Inner scope within function body\n  int16_t para = 1;         // Non-compliant - hides parameter\n  int16_t a    = 2;\n\n  return para + a;\n}\n\ncatch( ... )\n{                           // Inner scope within function body\n  int16_t para = 1;         // Non-compliant - hides parameter\n  int16_t a    = 2;\n\n  return para + a;\n}\n\nvoid f7( int32_t i )\n{\n  for ( int32_t i = 0; i < 9; ++i ) {}   // Non-compliant\n\n  for ( int32_t j = 0; j < i; ++j ) {}\n\n  for ( int32_t j = 0; j < i; ++j ) {}   // Compliant - new scope\n\n  for ( int32_t k = 0; k < i; ++k ) {}\n\n  int32_t k = i;                         // Compliant - for-loop 'k' not in scope\n\n  for ( int32_t k = 0; k < i; ++k ) {}   // Non-compliant - hides 'k' above\n\n  if ( get() )                           // Introduces an inner scope into which 'k'\n  {                                      //   is defined.\n    int32_t k;                           // Non-compliant - hides 'k' in outer scope\n  }\n}\n\nIn the following example, there is no hiding in the compliant examples as the local variable z cannot \nbe found by name lookup within the body of a lambda. \n\nvoid f8()\n{\n  char z;\n\n  auto L1 = [ z ](){ return z; };        // Compliant - no hiding\n  auto L2 = []( char z ){ return z; };   // Compliant - no hiding\n  auto L3 = [](){ char z { 'a' }; };     // Compliant - no hiding\n  auto L4 = [ z ](){ char z { 'a' }; };  // Non-compliant - captured z is hidden\n}\n\n54\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS"
  },
  {
    "rule": "Rule 6.4.2\n\nDerived classes shall not conceal functions that are inherited from \ntheir bases\n\n[class.member.lookup]\n[namespace.udecl] / 4, 15\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA function from a base class is concealed in the derived class if the derived class contains any function \nor variable with the same name, unless:\n\n\u25cf The base class is inherited privately; or\n\n\u25cf The base class function is virtual and the derived class contains an override of it; or\n\n\u25cf The base class function is introduced into the derived class through a using-declaration; or\n\n\u25cf The base class function is a copy assignment operator or a move assignment operator.\n\nNote: this rule does not apply to constructors or destructors as they do not have names.\n\nRationale\n\nWhen performing name lookup, if a function with the requested name exists in the derived class, no  \nlookup will be performed in any base class, even if the base classes contain functions that would  \nhave been better matches. This may result in a call being made to an unexpected function.\n\nAdditionally, calling a function directly or through a base class pointer should result in the same \nfunction being called, which may not be the case when a non-virtual base class function is concealed.\n\nMembers of a class inherited privately are not accessible outside of the derived class, and so users of  \nthe derived type will not encounter the issues identi9ed above.\n\nNote: a using-declaration will only introduce an overload into a derived class if the derived class does \nnot contain the same overload \u2014 see example for f5.\n\nExample\n\nclass Base\n{\npublic:\n          void   f1( int32_t i );\n          void   f2( int32_t i );\n  virtual Base * f3( char    c );\n          void   f4( char    c );\n          void   f5( int32_t i );\n          void   f5( char    c );\n};\n\nclass Derived: public Base\n{\npublic:\n  // Compliant - does not conceal Base::operator=\n  Derived & operator=( Derived const & ) &;\n\n  // Non-compliant - Derived::f1 conceals Base::f1\n  void f1( float f );\n\n                         // Compliant - Base::f2 is not concealed\n  using Base::f2;        // Introduces Base::f2( int32_t ) overload\n  void f2( float f );    // Using declaration means this overload does not conceal\n\n55\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n                                           // Compliant - Base::f3 is not concealed\n  Derived * f3( char const c ) override;   // overrides Base::f3( char )\n     void   f3( int32_t    i );\n\n                                           // Non-compliant - Base::f4 is concealed\n  void f4( char    c );                    // Not an override\n  void f4( int32_t i );\n\n                         // Non-compliant - Base::f5( int32_t ) is concealed\n  using Base::f5;        // Introduces Base::f5( char ), not Base::f5( int32_t ) as\n  void f5( int32_t i );  // this function has the same signature\n};\n\nclass PrivateDerived: private Base\n{\npublic:\n  void f1( float f );    // Compliant - Base inherited privately\n};"
  },
  {
    "rule": "Rule 6.4.3\n\nA name that is present in a dependent base shall not be resolved by \nunquali9ed lookup\n\n[basic.lookup.unqual]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to names that would be found by unqualified lookup if none of the base classes were  \ndependent. \n\nNote: this rule does not apply to names from a base class that are introduced into the derived class  \nthrough a using declaration.\n\nRationale\n\nFor a template class with a dependent base, the use of an unquali9ed name that does not refer to an  \nentity in that class is taken to mean an entity in global scope, even if there is an entity with that name \nin the base. This diCers from the behaviour in non-template classes, where the entity in the base will \nbe selected in preference to an entity in global scope. This may not be consistent with developer \nexpectations.\n\nNote: using a quali%ed-id or pre9xing the identi9er with this-> ensures that an entity in the base is \nselected. \n\nExample\n\nusing int32_t = int;\nusing int16_t = short;\n\ntypedef int32_t Type;\nvoid g();\n\ntemplate< typename T > struct B;\n\ntemplate< typename T >\nstruct A : B< T >\n{\n  using typename B< T >::ConstType;\n\n56\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f  void f1()\n  {\n    // Non-compliant for A< int32_t > - compiler will choose ::Type\n    //   If B were non-dependent, B< int32_t>::Type would have been chosen\n    // Non-compliant for A< int16_t > - compiler will choose ::Type\n    //   If B were non-dependent, B< int16_t>::Type would have been chosen\n    Type t = 0;\n\n    // Compliant - compiler finds the name introduced by the using declaration\n    ConstType t = 0;\n\n    // Non-compliant for A< int32_t > - compiler will choose ::g\n    //   If B were non-dependent, B< int32_t>::g would have been chosen\n    // Compliant for A< int16_t > - base B< int16_t > has no member g\n    g();\n  }\n\n  void f2()\n  {\n    ::Type t1 = 0;                  // Compliant - explicit use of global Type\n    ::g();                          // Compliant - explicit use of global g\n\n    typename B< T >::Type t2 = 0;   // Compliant - explicit use of base Type\n\n    // Compliant for A< int32_t > - uses base g\n    // Compile error for A< int16_t >\n    this->g();\n  }\n};\n\ntemplate< typename T >\nstruct B\n{\n  typedef T Type;\n  typedef T const ConstType;\n  void g();\n};\n\ntemplate<> struct B< int16_t >\n{\n  typedef int16_t Type;\n  typedef int16_t const ConstType;\n};\n\ntemplate struct A< int32_t >;\ntemplate struct A< int16_t >;\n\nusing value_type = char16_t;\n\ntemplate< typename String >\nclass MyString : public String\n{\n  // Non-compliant for MyString<std::string> - compiler will choose ::value_type\n  //   If MyString inherited directly from std::string, std::string::value_type\n  //   would have been chosen\n  value_type separator;  \n};\n\nMyString< std::string > ms;\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n57\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n58\n\n4.6.5\n\nProgram and linkage \n\n [basic.link]"
  },
  {
    "rule": "Rule 6.5.1\n\nA function or object with external linkage should be introduced in a \nheader %le\n\n[basic.scope.namespace]\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to functions and objects with   namespace scope. The  header file  containing the \nintroduction should be included by every translation unit in which it is de9ned or used. \n\nThis rule does not apply to the function main.\n\nRationale\n\nPlacing the introductions of functions and objects with external linkage in a header %le indicates that \nthey are intended to be accessed from multiple  translation units. Requiring that this  header %le  is \nincluded by every  translation unit  that defines or uses the function or object ensures that the \ndeclaration matches the de9nition.\n\nIf usage from multiple  translation units  is not required, then the visibility of the function or object \nshould be reduced by declaring it with internal linkage, for example, by declaring it within an unnamed \nnamespace  of an  implementation %le  (see"
  },
  {
    "rule": "Rule 6.5.2). This has the eCect of increasing isolation and \nencapsulation, which is considered to be good practice. \n\nCompliance with this rule helps to prevent the issues identi9ed in"
  },
  {
    "rule": "Rule 6.2.2.\n\nExample\n\n// header.hpp\nextern int32_t a1;        // Compliant\n\nextern void f3();         // Compliant\n\n// file1.cpp\n#include \"header.hpp\"\n\nint32_t a1 = 0;           // Redeclaration - rule does not apply\nint32_t a2 = 0;           // Non-compliant - no declaration in header\n\nnamespace\n{\n  int32_t const a3 = 0;   // Internal linkage - rule does not apply\n\n  void f1()               // Internal linkage - rule does not apply\n  {\n  }\n}\n\nvoid f2()                 // Non-compliant - no declaration in header\n{\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fvoid f3()                 // Redeclaration - rule does not apply\n{\n}\n\nSee also"
  },
  {
    "rule": "Rule 6.2.2,"
  },
  {
    "rule": "Rule 6.5.2"
  },
  {
    "rule": "Rule 6.5.2\n\nInternal linkage should be speci9ed appropriately\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nInternal linkage for an entity is speci9ed appropriately when:\n\n1.\n\nIt is declared within an anonymous namespace; and\n\n2. None of its declarations use the extern keyword; and\n\n3.\n\nIt is not declared static.\n\nThis rule does not apply to variables declared constexpr or const.\n\nRationale\n\nWhilst the static keyword can be used to give an entity internal linkage, it also has other uses, which \nmay lead to confusion. An entity is unambiguously given internal linkage when it is declared in an  \nanonymous namespace, with the added advantage that this declarative form can be consistently  \napplied to all types of entity.\n\nAn entity in an anonymous namespace can be declared extern, but this does not have an impact on \nits linkage.\n\nExample\n\nstatic void f1();               // Non-compliant\n\nnamespace\n{\n  void f2();                    // Compliant\n\n         int32_t notExtern1;    // Compliant\n  extern int32_t notExtern2;    // Non-compliant\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n59\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\n4.6.7\n\nStorage duration \n\n [basic.stc]"
  },
  {
    "rule": "Rule 6.7.1\n\nLocal variables shall not have static storage duration\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\n[basic.stc.static]\n[basic.start.dynamic]\n[basic.start.term]\n\nn\ne\ns\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule does not apply to variables declared constexpr or const.\n\nRationale\n\nThe use of mutable variables with static storage duration, even when they do not have linkage,  \npotentially results in hidden temporal coupling. This can lead to data races (and thus  undefined  \nbehaviour). Additionally, functions with persistent state are usually more di[cult to understand and \ntest.\n\nNote: the lifetime of local variables with static storage duration ends at program termination in the  \nreverse order of their creation. Suitable care should be taken to ensure that the code executed during \ndestruction does not access a previously destroyed variable.\n\nExample\n\nint32_t bar();\n\nint32_t ga = 0;                         // Compliant - but violates \"See also\"\n\nint32_t foo()\n{\n                   int32_t a = 0;       // Compliant\n  static           int32_t b = 0;       // Non-compliant\n  static constexpr int32_t c = 0;       // Compliant\n  static const     int32_t d = bar();   // Compliant\n}\n\nclass Application\n{\n  static Application & theApp()\n  {\n    static Application app;             // Non-compliant\n\n    return app;\n  }  \n};\n\nSee also"
  },
  {
    "rule": "Rule 6.7.2\n\n60\n\nLicensed to: gunjanjain\n22 Apr 2025"
  },
  {
    "rule": "Rule 6.7.2\n\nGlobal variables shall not be used\n\ns\ne\nn\n\n[basic.stc.static]\n[basic.start.dynamic]\n[basic.start.term]\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nGlobal variables are:\n\n1. Variables de9ned in namespace scope; and\n\n2. Class static data members.\n\nThis rule does not apply to global variables that are:\n\n1. constexpr; or\n\n2. const and that are initialized through static initialization.\n\nRationale\n\nGlobal variables can be accessed and modi9ed from:\n\n\u25cf Anywhere within the translation unit, if they have internal linkage; or\n\n\u25cf Anywhere within the program, if they have external linkage.\n\nThis can lead to uncontrollable interactions between functions, with the risk of unde%ned behaviour \noccurring due to data races in concurrent programs.\n\nAdditionally, certain aspects of the order of initialization of global variables are unspecified. This can lead \nto unpredictable results for global variables that are initialized at run-time (dynamic initialization).\n\nExample\n\nint32_t foo();\n\n      int32_t i1 { foo() };               // Non-compliant\nconst int32_t i2 { i1 };                  // Non-compliant - dynamic initialization\n\nnamespace \n{\n  int32_t i3 { 0 };                       // Non-compliant\n\n  constexpr int32_t bar()\n  {\n    return 42; \n  }\n\n  constexpr int32_t i4 { bar() };         // Rule does not apply - constexpr\n\n  const int32_t SIZE { 100 };             // Rule does not apply \n}                                         // - const without dynamic initialization\n\nstruct ComplexInit\n{\n  ComplexInit();\n};\n\nconst ComplexInit c1 {};                  // Non-compliant - dynamic initialization\n\n61\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nclass StaticMember\n{\n         int32_t x;                       // Rule does not apply\n  static int32_t numInstances;\n};\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nint32_t StaticMember::numInstances = 0;   // Non-compliant\n\nconstexpr auto add =                      // Rule does not apply - add is const\n  []( auto x, auto y ) { return x + y; };\n\nSee also"
  },
  {
    "rule": "Rule 6.7.1\n\n4.6.8 Object lifetime \n\n [basic.life]"
  },
  {
    "rule": "Rule 6.8.1\n\nAn object shall not be accessed outside of its lifetime\n\n[basic.life] Unde9ned 5\n[class.union]\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nTechnically, a C++ object does not exist outside of its lifetime. However, for the purposes of this rule,  \na violation occurs whenever a memory location that does not contain a live object of an appropriate  \ntype is accessed.\n\nRationale\n\nIt is undefined behaviour to access an object before it has been initialized or after its lifetime has ended \n(even if the memory occupied by the object has not been released).\n\nIt is possible to refer to an object before its lifetime has begun, for example, by referring to a non-\nactive member of a union.\n\nCompliance with the rules cross-referenced by this rule helps to prevent lifetime violations.\n\nExample\n\nstruct X\n{\n  void doSomething() {}\n};\n\nvoid h( X * px )\n{\n  px->~X();                           // End the lifetime of *px\n  px->doSomething();                  // Non-compliant\n}\n\nvoid g()\n{\n  X a{};\n  auto & b = ( X{} = a );             // Immediate dangling of b\n  b.doSomething();                    // Non-compliant\n}\n\n62\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fvoid f()\n{\n  int32_t * pi = new int32_t { 42 };\n\n  delete pi;\n  std::cout << *pi;                   // Non-compliant\n}\n\nunion u\n{\n  int32_t  a;\n  uint16_t b[ 2 ];\n};\n\nuint16_t u2()\n{\n  u o;\n\n  o.a = 42;\n  return o.b[ 0 ];                    // Non-compliant - b is not the active member\n}\n\nSee the cross-referenced rules for further examples.\n\nSee also"
  },
  {
    "rule": "Rule 6.7.2,"
  },
  {
    "rule": "Rule 6.8.2,"
  },
  {
    "rule": "Rule 6.8.3,"
  },
  {
    "rule": "Rule 6.8.4,"
  },
  {
    "rule": "Rule 9.5.2,"
  },
  {
    "rule": "Rule 12.3.1,"
  },
  {
    "rule": "Rule 18.3.3"
  },
  {
    "rule": "Rule 6.8.2\n\nA function must not return a reference or a pointer to a local variable \nwith automatic storage duration\n\nCategory Mandatory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule also applies to:\n\n1. Function parameters passed by value; and\n\n2. Returning a lambda that captures by reference a variable with automatic storage duration; and\n\n3. Returning a lambda that captures the address of a variable with automatic storage duration.\n\nFor the purposes of this rule, a throw that is not caught within the function is considered to be a \nreturn from the function.\n\nRationale\n\nAutomatic variables are destroyed when a function returns. Returning a reference or pointer to such \na variable allows it to be used after its destruction, leading to unde%ned behaviour.\n\nNote: this rule and"
  },
  {
    "rule": "Rule 6.8.3 use decidable checks that allow trivial, speci9c instances of potentially \ndangling references to be detected statically. Other (possibly non-decidable) cases are covered by"
  },
  {
    "rule": "Rule 6.8.1.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n63\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nExample\n\nint32_t * f1()\n{\n  int32_t x = 99;\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n  return &x;                 // Non-compliant\n}\n\nint32_t * f2( int32_t y )\n{\n  return &y;                 // Non-compliant\n}\n\nint32_t & f3()\n{\n  int32_t x = 99;\n\n  return x;                  // Non-compliant\n}\n\nint32_t & f4( int32_t y )\n{\n   return y;                 // Non-compliant\n}\n\nint32_t & f5( int32_t & x )\n{\n  return x;                  // Rule does not apply\n}\n\nint32_t * f6()\n{\n  static int32_t x = 0;\n\n  return &x;                 // Rule does not apply\n}\n\nvoid f7()\n{\n  int32_t x = 0;\n\n  throw &x;                  // Non-compliant\n}\n\nvoid f8()\n{\n  try\n  {\n    int32_t x = 0;\n\n    throw &x;                // Rule does not apply - caught within this function\n  }\n  catch ( ... )\n  {\n  }\n}\n\nauto f9()\n{\n  int32_t x { 42 };\n\n  return [&x]() {};          // Non-compliant - captures local by reference\n}\n\n64\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fauto f10()\n{\n  int32_t x { 42 };\n\n  return [p = &x]() {};      // Non-compliant - captures address of local\n}\n\nThe following example is compliant with this rule, but violates"
  },
  {
    "rule": "Rule 6.8.1.\n\nint32_t * f11()\n{\n  int32_t   i = 42;\n  int32_t * p = &i;\n\n  return p;                  // Compliant with this rule\n}\n\nSee also"
  },
  {
    "rule": "Rule 6.8.1,"
  },
  {
    "rule": "Rule 6.8.3"
  },
  {
    "rule": "Rule 6.8.3\n\nAn assignment operator shall not assign the address of an object \nwith automatic storage duration to an object with a greater lifetime\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies when the right-hand side of an assignment operator has the form addressof( x ), \n&x, or is the name of an object having array type.\n\nFor the purposes of this rule, two objects with automatic storage duration that are declared in the  \nsame scope are considered to have the same lifetime.\n\nRationale\n\nIf the address of an automatic object is assigned to another automatic object of larger scope, or to an \nobject with static storage duration, then the object containing the address may exist beyond the time  \nwhen the original object ceases to exist (and its address becomes invalid).\n\nNote: this rule and"
  },
  {
    "rule": "Rule 6.8.2 use decidable checks that allow trivial, speci9c instances of potentially \ndangling references to be detected statically. Other (possibly non-decidable) cases are covered by"
  },
  {
    "rule": "Rule 6.8.1.\n\nExample\n\nvoid f1()\n{\n  int8_t * p;\n\n  {\n    int8_t local;\n    int8_t local_array[ 10 ];\n\n    p = &local;                 // Non-compliant\n    p = local_array;            // Non-compliant\n  }\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n65\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nThe following example is compliant with this rule, but violates"
  },
  {
    "rule": "Rule 6.8.1.\n\nvoid f2()\n{\n  int8_t * p1;\n\n  {\n    int8_t * p2 = nullptr;\n    int8_t local;\n\nn\ne\ns\n\n    p2 = &local;                // Compliant - objects have the same lifetime\n    p1 = p2;                    // Rule does not apply\n  }\n\n  *p1 = 0;                      // Undefined behaviour\n}\n\nSee also"
  },
  {
    "rule": "Rule 6.8.1,"
  },
  {
    "rule": "Rule 6.8.2"
  },
  {
    "rule": "Rule 6.8.4\n\nMember functions returning references to their object should be ref-\nquali%ed appropriately\n\n[basic.life]\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to member functions with reference or pointer return type, where, in the de9nition  \nof the function, at least one return expression explicitly designates  this,  *this  or a subobject of \n*this.\n\nSuch a function is only appropriately ref-quali%ed when:\n\n1.\n\nIt is non-const-lvalue-ref-quali%ed (&); or\n\n2.\n\nIt is const-lvalue-ref-quali%ed (const &) and another overload of that function is declared that is \nrvalue-ref-quali%ed (&&) with the same parameter-type-list.\n\nNote: this implies that a member function returning a pointer or reference to its object should be ref-\nquali%ed, but not rvalue-ref-quali%ed.\n\nRationale\n\nReturning a reference or pointer to a temporary object, or one of its subobjects, from a member  \nfunction can lead to immediate dangling.\n\nRef-qualification  of member functions can be used to control which of them can be called on a  \ntemporary object:\n\n1. A non-const-lvalue-ref-quali%ed function will never bind to a temporary object; and\n\n2. A const-lvalue-ref-qualified function could bind to a temporary object, but this will not occur if an \n\nrvalue-ref-quali%ed overload is present as it will be preferred during overload resolution.\n\nCompliance with this rule ensures that member functions directly returning references to their object \nmembers cannot be called on temporary objects. This rule is limited to direct references so that checks \nfor compliance are decidable. Use of an indirect reference to a temporary object after its lifetime has \nended is covered by"
  },
  {
    "rule": "Rule 6.8.1.\n\n66\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fNotes:\n\n1. An rvalue-ref-qualified member function will only bind to temporary objects and should therefore \n\nnever return a reference or pointer to its object or one of its subobjects.\n\n2. This rule does not apply to defaulted assignment operators as they do not have a de9nition. \n\nHowever,"
  },
  {
    "rule": "Rule 8.18.2 prevents the implicitly returned reference from being used.\n\nExample\n\nstruct A\n{\n  int32_t   a;                       // a is a subobject of *this\n  int32_t & b;                       // b is a reference, not a subobject of *this\n\n  int32_t & geta1() &                // Compliant - non-const-lvalue-ref-qualified\n  { return a; }\n\n  int32_t const & geta2() const &    // Compliant - const-lvalue-ref-qualified and\n  { return a; }\n\n  int32_t geta2() &&                 //             this rvalue-ref overload exists\n  { return a; }\n\n  int32_t & getb()                   // Rule does not apply - b is not a subobject\n  { return b; }\n\n  A const * getMe1() const & { return this; }  // Compliant\n       void getMe1() const && = delete;        //  - because this overload exists\n\n  A & getMe2() { return *this; }               // Non-compliant - not ref-qualified\n};\n\nA createA();\n\n// A call to the non-compliant getMe2 on a temporary results in immediate dangling\nA & dangling = createA().getMe2();\n\nThis rule does not apply to the following example, which is still dangerous and could lead to the use of a \ndangling pointer (see"
  },
  {
    "rule": "Rule 6.8.1): \n\nclass C\n{\n  C * f()\n  {\n    C * me = this;\n\n    return me;                                 // Indirectly designates 'this'\n  }\n};\n\nIn the following example, the instantiation of f in the call at #2 is compliant because #1 is an overload \nof f with the same parameter-type-list. However, the instantiation of f in the call at #3 does not have \nsuch an overload and is therefore non-compliant.\n\nstruct Tmpl\n{\n  template< typename T >\n  Tmpl const * f( T ) const & { return this; } // Non-compliant when instantiated\n                                               // for #3\n  void f( int32_t ) const && = delete;         // #1\n};\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n67\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nvoid bar( int32_t s32, int8_t s8 )\n{\n  Tmpl tpl;\n\n  tpl.f( s32 );                                // #2\n  tpl.f( s8  );                                // #3\n}\n\nSee also\n\nn\ne\ns"
  },
  {
    "rule": "Rule 6.8.1,"
  },
  {
    "rule": "Rule 8.18.2,"
  },
  {
    "rule": "Rule 15.0.2\n\n4.6.9\n\nTypes \n\n [basic.types]"
  },
  {
    "rule": "Rule 6.9.1\n\nThe same type aliases shall be used in all declarations of the same \nentity\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nIf a redeclaration uses diCerent type aliases to those in its previous declarations, it may not be clear \nthat the declarations refer to the same entity.\n\nExample\n\ntypedef int32_t INT;\nusing Index = int32_t;\n\n       INT     i;\nextern int32_t i;             // Non-compliant\n\n       INT j;\nextern INT j;                 // Compliant\n\nIn the following, there are two declarations of g, even though the types differ due to the top level const \nquali9er:\n\nvoid g( int32_t     i );\nvoid g( Index const i );        // Non-compliant - int32_t vs. Index\n\nvoid h( Index         i     );\nvoid h( Index const   index );  // Compliant - Index used consistently\nvoid h( int32_t     * i     );  // Rule does not apply - different overload\n\nSee also"
  },
  {
    "rule": "Rule 6.2.2\n\n68\n\nLicensed to: gunjanjain\n22 Apr 2025"
  },
  {
    "rule": "Rule 6.9.2\n\nThe names of the standard signed integer types and standard \nunsigned integer types should not be used\n\n[basic.fundamental] Implementation 1, 5\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to the names of integral types constructed using the keywords char, short, int, \nlong,  signed  and  unsigned  (ignoring any  cv-quali%cation). It does not apply to the use of plain \nchar.\n\nRationale\n\nIt is implementation-defined how much storage is required for any object of the standard signed integer \ntypes or standard unsigned integer types. When the amount of storage being used is important, the \nuse of types having specified widths makes it clear how much storage is being reserved for each object.\n\nThe C++ Standard Library header %le <cstdint> often provides a suitable set of integer types having \nspeci9ed widths. If a project de9nes its own type aliases, it is good practice to use  static_assert \nto validate any size assumptions. For example: \n\nusing torque_t = unsigned short;\n\nstatic_assert( sizeof( torque_t ) >= 2 );\n\nNotes:\n\n1. Compliance with this rule does not prevent integer promotion, which is influenced by the \nimplemented size of int and the type used for an alias. For example, an expression of type  \nint16_t will only be promoted if the aliased type has a rank lower than that of  int. The \npresence or absence of integer promotion may have an influence on overload resolution.\n\n2. Strong typing, which may be provided by class or enum types, is more robust than the use of \n\ntype aliases to represent speci9c width types.\n\nException\n\n1. The names of the standard signed integer types and standard unsigned integer types may be used \n\nto de9ne a type alias.\n\n2. The name int may be used for:\n\na. The parameter to a post9x operator, which must use that type; and\n\nb. The return type of main; and\n\nc. The argc parameter to main.\n\nExample\n\n#include <cstdint>\n\nint           x = 0;                     // Non-compliant - use of int\nint32_t       y = 0;                     // Compliant\nint_least32_t z = 0;                     // Compliant\n\nusing torque_t = int;                    // Compliant by exception #1\ntorque_t w = 0;\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n69\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nclass C\n{\npublic:\n  C  operator++( int );                  // Compliant by exception #2.1\n};\n\nint main() { }                           // Compliant by exception #2.2\nint main( int argc, char * argv[] ) { }  // Compliant by exception #2.2 and #2.3\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n4.7\n\nStandard conversions\n\n4.7.0\n\nThe built-in type rules \n\n [misra]\n\n4.7.0.1 Motivation\n\nThe C++ built-in operators perform many implicit conversions on their operands. These conversions \ncan lead to unexpected information loss, change of signedness, implementation-de%ned behaviour or \nunde%ned behaviour. To mitigate this, the guidelines in this section, collectively called the built-in type  \nrules, place restrictions on expressions that contain instances of  integral promotion  and the  usual  \narithmetic conversions.\n\nNote:  the  built-in type rules  do not prevent all possible  undefined behaviour  (e.g. signed integer \nover^ow) related to the use of the built-in operators.\n\nFor the following reasons, the  built-in type rules  are stricter than the related guidelines in MISRA C, \neven though the behaviour of both languages is similar:\n\n1. C++ allows function overloading, and knowing which overload is selected by overload resolution \n\nrequires a clear understanding of a sub-expression\u2019s type.\n\n2. C++ allows the de9nition of user-de9ned types that wrap and mimic numeric types. In addition \nto the bene9ts of strong typing, such types can be written in a way that prevents dangerous, \nimplicit conversions. These types can be used when arithmetic with small types is required in a \nprogram, meaning that the built-in type rules can be very strict without harming the expressivity \nof the developer.\n\n4.7.0.2\n\nScope and de2nitions\n\nType categories\n\nEvery built-in type is assigned a type category, as follows: \n\nType category\n\nTypes\n\nCharacter category\n\nchar, wchar_t, char16_t, and char32_t\n\nIntegral category\n\nsigned integer types and unsigned integer types, \nincluding signed char and unsigned char\n\nFloating category\n\nfloat, double, and long double\n\nOther\n\nbool, void, and nullptr_t\n\nThe integral category and +oating category types are collectively called the numeric types.\n\nFor the purposes of the built-in type rules:\n\n1.\n\nIt is assumed that all bits of a numeric type participate in its value representation.\n\n2. All cv-quali%ers and ref-quali%ers are ignored (for example int const & is treated as int).\n\n70\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n3. An expression of type unscoped enumeration with a %xed underlying type is considered as if its \n\ntype were the underlying type of the enumeration. For example:\nenum E : int16_t { a, b } \u2014 considered to be of type int16_t.\n\n4. A bit-9eld is considered as having the smallest integer type with the same signedness that is \n\nable to represent all the possible values of the bit-9eld. For example:\nuint32_t flag : 1 \u2014 considered to be of type uint8_t.\n\n5. All type aliases that resolve to the same built-in type are considered to be equivalent.\n\nNote: an expression of type unscoped enumeration without a %xed underlying type is considered to be \na symbolic abstraction \u2014 see"
  },
  {
    "rule": "Rule 10.2.3.\n\nOperators\n\nAll references to operators within the built-in type rules only refer to built-in operators. An expression \nthat uses an operator that resolves to an overloaded operator is a function call.\n\nFor the built-in operators, the following operator categories are de9ned: \n\nCategory\n\nOperators\n\nArithmetic operators\n\n+ - * / %\n\nBitwise operators\n\n~ | ^ &\n\nShift operators\n\nEquality operators\n\n>> <<\n\n== !=\n\nRelational operators\n\n< > <= >=\n\nLogical operators\n\n! && ||\n\nInc/Dec operators\n\n++ --\n\nThe restrictions enforced by the built-in type rules on the binary forms of the operators in the above \nalso apply to the corresponding compound assignment forms (%=, etc.). For instance,  a += b  is \nconsidered to be equivalent to a + b.\n\nAssignment\n\nFor the purposes of the  built-in type rules, the term  assignment  is not limited to the use of the \nassignment operator and, designates those constructs that may include an implicit conversion between \nthe type of a source expression and a determined target type.\n\nThe following are assignments:\n\n1. Assigning a value using the assignment operator; and\n\n2.\n\nInitializing a variable, including within a lambda capture; and\n\n3. Passing a function parameter by value, including passing a default value for a function argument \nand passing a parameter to a function that is called implicitly (such as the call to a constructor, \nto overloaded operators, to operator() of closure types); and\n\n4. Returning a value from a function by value; and\n\n5. Using a value in a switch statement\u2019s case label (source expression), where the target type is \n\ngiven by the adjusted type of the condition.\n\nNote: compound assignments are not assignments.\n\n4.7.0.3\n\nConventions used in examples\n\nFor the sake of simplicity, the examples within the built-in type rules all assume that char is 8 bit, short \nis 16 bit, int is 32 bit, long is 32 bit and long long is 64 bit.\n\n71\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nHowever, when enforcing the guidelines within a project, it is the sizes of the types provided by the \nimplementation that are taken into account, which means that the compliance of code may depend \non the target architecture.\n\nThe examples also assume that the following user-de9ned literal is de9ned: \n\nconstexpr uint16_t operator \"\"_u16( unsigned long long val );\n\nSimilarly for _u8, _u32, _u64, _s8, _s16, _s32 and _s64.\n\nAdditionally, any variable whose name starts with  u8,  u16,  u32,  u64,  s8,  s16,  s32,  s64  should be \nassumed to be of the indicated type. Variables whose names start with f, d or ld are respectively of \ntype float, double or long double."
  },
  {
    "rule": "Rule 7.0.1\n\nThere shall be no conversion from type bool\n\n[conv.prom]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to all implicit and explicit conversions, except for:\n\n1. The operands of an equality operator where both operands have type bool; or\n\n2. An explicit cast from bool to class T, when that class has a converting constructor with a \n\nparameter of type bool:\n\na. T { true }\n\nb. T ( true )\n\nc. static_cast< T >( true )\n\nd. ( T )true \u2014 note that this violates"
  },
  {
    "rule": "Rule 8.2.2\n\nRationale\n\nValues of type bool may be subject to integral promotion and the usual arithmetic conversions. \nHowever, occurrences are generally indicative of an error or code obfuscation. For example, the use \nof bool operands with the bitwise operators is unlikely to be intentional and is likely to indicate that a \nbitwise operator (&, |, ~) has been confused with a logical operator (&&, ||, !). This rule allows errors \nsuch as this to be detected.\n\nThe integral promotion that occurs when an equality operator is used to compare two values of type \nbool is permitted as it is benign.\n\nCasting a bool to an integral type is not allowed as it is clearer to specify the values to which true \nand false will be converted.\n\nException\n\nAs there is no risk of confusion, a value of type bool may be assigned to a bit-9eld of length 1 \u2014 this \nis a common idiom used when accessing hardware registers.\n\nExample\n\nbool   b1  = true;\nbool   b2  = false;\ndouble d1;\nint8_t s8a;\n\n72\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nif ( b1 & b2 )                       // Non-compliant - b1 and b2 converted to int\nif ( b1 < b2 )                       // Non-compliant - b1 and b2 converted to int\nif ( ~b1 )                           // Non-compliant - b1 converted to int\nif ( b1 ^ b2 )                       // Non-compliant - b1 and b2 converted to int\nif ( b1 == 0 )                       // Non-compliant - b1 converted to int\n\ndouble result = d1 * b1;             // Non-compliant - b1 converted to double\ns8a = static_cast< int8_t >( b1 );   // Non-compliant - b1 converted to int8_t\n\nif ( b1 == false )                   // Compliant - Boolean operands to equality\nif ( b1 == b2 )                      // Compliant - Boolean operands to equality \nif ( b1 != b2 )                      // Compliant - Boolean operands to equality \nif ( b1 && b2 )                      // Compliant - no conversion from bool\nif ( !b1 )                           // Compliant - no conversion from bool\n\ns8a = b1 ? 3 : 7;                    // Compliant - no conversion from bool\n\nvoid f( int32_t n );\nbool b;\n\nf( b );                              // Non-compliant - b converted to int32_t\nf( b ? 1 : 0 );                      // Compliant - no conversion from bool\n\nswitch ( b )                         // Non-compliant - b converted to int\n\nstruct A\n{\n  explicit A( bool );\n};\n\nA anA { true };                      // Compliant - constructor\n\nanA = A { false };                   // Compliant - explicit cast calls constructor\n\nSee also"
  },
  {
    "rule": "Rule 7.0.2,"
  },
  {
    "rule": "Rule 8.2.2"
  },
  {
    "rule": "Rule 7.0.2\n\nThere shall be no conversion to type bool\n\n[conv.integral]\n[conv.bool]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nConversion from a fundamental type (see [basic.fundamental]) to bool depends on the interpretation \nof a non-zero value as true (see [conv.bool]). However, this interpretation may not be appropriate \nfor APIs, such as POSIX, that do not use Boolean return values.\n\nContextual conversion to bool occurs when an operand of fundamental type is used as:\n\n\u25cf An operand to a logical operator; or\n\n\u25cf The 9rst operand of the conditional operator; or\n\n\u25cf The condition of an if-statement or iteration-statement.\n\nThe result of such a conversion may not be what the developer intended (for example, when an  \nassignment is accidentally used as the condition to an if-statement). Therefore, wherever a contextual  \nconversion to bool may occur, the corresponding expression shall have type bool (e.g. as a result of \nan explicit test).\n\n73\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n74\n\nIn addition, fundamental types, unscoped enumeration types, and pointers will be implicitly converted \non  assignment  to  bool.   The   result   of   such   implicit   conversions   may   not   be   what   the   developer \nintended.\n\nException\n\n1. A static_cast to bool is permitted for a class type having an explicit operator bool.\n\n2. Contextual conversion to bool is permitted from a pointer, or from a class type having an \n\nexplicit operator bool.\n\n3. A bit-9eld of size 1 can be converted to bool \u2014 this is a common idiom used when accessing \n\nhardware registers and there is no risk of confusion.\n\n4.\n\nIn a while, a condition of the form type-speci%er-seq declarator is not required to have type bool \nas alternative mechanisms for achieving the same eCect generally require the scope of objects \nto be wider than necessary. Note that a similar exception is not needed for the if statement, as \nthe if ( init-statementopt  condition ) syntax was introduced in C++17.\n\nExample\n\nif ( ( u8a < u8b ) && ( u8c < u8d ) )  // Compliant\nif ( ( u8a < u8b ) && ( u8c + u8d ) )  // Non-compliant\n\nif ( true && ( u8c < u8d ) )           // Compliant\nif ( 1    && ( u8c < u8d ) )           // Non-compliant\nif ( u8a  && ( u8c < u8d ) )           // Non-compliant\n\nif ( !0 )                              // Non-compliant\nif ( !false )                          // Compliant\n\ns32a =   s16a       ? s32b : s32c;     // Non-compliant\ns32a =   b1         ? s32b : s32c;     // Compliant\ns32a = ( s16a < 5 ) ? s32b : s32c;     // Compliant\n\nint32_t fn();\nbool    fb();\n\nwhile ( int32_t i1 = fn() )            // Compliant by exception #4\nif ( int32_t i2 = fn() )               // Non-compliant \nif ( int32_t i3 = fn() ; i3 != 0)      // Compliant version of the above line\n\nwhile ( std::cin )                     // Compliant by exception #2 - std::istream\n                                       //   has explicit operator bool\nfor ( int32_t x = 10; x; --x )         // Non-compliant\n\nextern int32_t * getptr();\n\nif ( getptr() )                        // Compliant by exception #2 - contextual\n                                       //   conversion from pointer to bool\nbool b2 = getptr();                    // Non-compliant\nbool b3 = getptr() != nullptr;         // Compliant\n\nif ( bool b4 = fb() )                  // Compliant\nif ( int32_t i = fn(); i != 0 )        // Compliant\nif ( int32_t i = fn(); i )             // Non-compliant - condition has type of 'i'\nif ( int32_t i = fn() )                // Non-compliant\nif ( u8 )                              // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fThe following example illustrates contextual conversion to bool with a user-de9ned class type: \n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nclass C\n{\n  int32_t x;\npublic:\n  explicit operator bool() const { return x < 0; }\n};\n\nvoid foo( C c ) \n{\n  bool b1 = static_cast< bool >( 4 );  // Non-compliant\n  bool b2 = static_cast< bool >( c );  // Compliant by exception #1\n\n  if ( c )                             // Compliant by exception #2 - contextual\n  {                                    //   conversion from 'C' to bool\n  }\n}\n\nSee also"
  },
  {
    "rule": "Rule 7.0.1,"
  },
  {
    "rule": "Rule 7.11.3,"
  },
  {
    "rule": "Rule 8.2.4"
  },
  {
    "rule": "Rule 7.0.3\n\nThe numerical value of a character shall not be used\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThere shall be no implicit or explicit conversion to or from an expression with character category.\n\nThis rule does not apply to unevaluated operands, or to the operands of an equality operator when both \nhave the same character type.\n\nRationale\n\nTypes in the character category are used to represent characters, not integers. The meaning of the \ninteger value of a character type depends on behaviour outside of the program and the C++ language, \nsuch as the encoding that is being used.\n\nWhen other operations on characters are necessary, such as determining if a character is lower case, \nC++ Standard Library functions provide solutions that are safer than the arithmetic manipulation of \ncharacter values.\n\nWhere the underlying numeric representation of character data is required, such as when generating \na hash, appropriate conversion functions are provided by std::char_traits<>.\n\nExample\n\nchar a = 'a';              // Rule does not apply - no conversion\nchar b = '\\r';             // Rule does not apply - no conversion\nchar c = 10;               // Non-compliant - implicit conversion from int to char\n\nint8_t      d = 'a';       // Non-compliant\nuint8_t     e = '\\r';      // Non-compliant\nsigned char f = 11;        // Rule does not apply - type has integral category\n\nusing CT = std::char_traits< char >;\n\nchar g = L'\u00c6';             // Non-compliant - conversion between character types\nchar h = a - '0';          // Non-compliant - promotion to int, conversion to char\n\n75\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nif ( g && h )              // Non-compliant - two conversions to bool\nif ( a != 'q' )            // Rule does not apply - comparing the same types\nif ( CT::eq( a, 'q' ) )    // Rule does not apply - no conversion\n\nstd::optional< char > o;\nif ( o == 'r' )            // Rule does not apply - no conversion\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n76\n\ndecltype( 's' + 't' ) w;   // Rule does not apply - unevaluated operand\n\nauto i = static_cast< CT::int_type >( 'a' );   // Non-compliant - explicitly\n                                               // converted to CT::int_type\nauto j = CT::to_int_type( 'a' );               // Rule does not apply\n                                               //   - no conversion\n\nif ( ( a >= '0' ) && ( a <= '9' ) )            // Non-compliant - promotion to int\nif ( !CT::lt( a, '0' ) && !CT::lt( '9', a ) )  // Compliant version of the above\n\nif ( 0 == std::isdigit( a ) )                  // Non-compliant - conversion to int\nif ( std::isdigit( a, std::locale {} ) )       // Compliant version of the above\n\nvoid f1 ( std::istream & is )\n{\n  auto i = is.get();\n\n  if ( CT::not_eof( i ) )\n  {\n    char c1 = i;                               // Non-compliant - int to char\n    char c2 = CT::to_char_type( i );           // Compliant version of the above\n  }\n}"
  },
  {
    "rule": "Rule 7.0.4\n\nThe operands of bitwise operators and shift operators shall be \nappropriate\n\n[expr.bit.and]\n[expr.or]\n[expr.xor]\n[expr.shift]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe following shall be of an unsigned type:\n\n\u25cf Both operands of the binary bitwise operators;\n\n\u25cf The left operand of the shift operators;\n\n\u25cf The operand of the bit complement operator.\n\nThe right operand of the shift operators, shall be:\n\n\u25cf Either a non-constant expression with an unsigned type; or\n\n\u25cf A constant expression with a value between 0 and sizeof( T ) * CHAR_BIT - 1 (inclusive), \n\nwhere T is the type of the left operand (before integral promotion).\n\nThe requirements of this rule for binary bitwise operators also apply to the corresponding compound \nassignment forms.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fRationale\n\nBit-oriented   operations   may   be   applied   to   operands   of   signed   and   unsigned   type.   However,   the \nresult is only guaranteed to be de9ned when the sign bit is not aCected.\n\nUnlike most other binary operations, the operands to the shift operators do not undergo the usual  \narithmetic conversions. Both operands are still subject to  integral promotion, with the resulting type \nbeing the promoted type of the left operand. Explicitly casting the left-hand operand of the   shift \noperator  to the intended width allows the reader to reason about the code\u2019s correctness without \nhaving to consider integral promotion.\n\nThe following behaviours may occur if operands to a shift operator have a signed type:\n\n\u25cf Shifting by a negative value results in unde%ned behaviour;\n\n\u25cf A left-shift of a signed left operand can result in unde%ned behaviour, even when the value is \n\npositive;\n\n\u25cf Right-shifting a negative value results in an implementation-de%ned value.\n\nAdditionally, unde%ned behaviour occurs when a shift operator has a right operand with a value that is \ngreater than or equal to the size in bits of the promoted type of the left operand.\n\nException\n\nThe left operand of a shift operator is permitted to be a non-negative constant expression of a signed \ntype T (before integral promotion) when: \n\n\u25cf T uses two\u2019s complement representation; and\n\n\u25cf The right operand is also a constant expression with a value between 0 and \n\nsizeof( T ) * CHAR_BIT - 1 (inclusive); and\n\n\u25cf No set bit is shifted into or beyond the most signi9cant bit, which is used as the sign bit. \n\nExample\n\nThe following examples assume int uses 32-bit two\u2019s complement representation.\n\n1u << u8;                                  // Compliant\n1u << 31;                                  // Compliant\n1_u8 << 2;                                 // Compliant - but violates other rules\nu8 << 2;                                   // Compliant - but violates other rules\n\ns32 << 2;                                  // Non-compliant - left operand is signed\n1 << u8;                                   // Non-compliant - left operand is signed\n( u8 + u16 ) << 2;                         // Non-compliant - result of + is signed\nstatic_cast< uint16_t >( u8 + u16 ) << 2;  // Compliant\n\n1LL << 31;                                 // Compliant by exception\n1 << 30;                                   // Compliant by exception\n2 << 30;                                   // Non-compliant - exception does not\n                                           //   apply as set bit is shifted too far\n\nu32a | u32b;                               // Compliant\ns32a | s32b;                               // Non-compliant - signed operands\n\n~u32;                                      // Compliant\n~u8;                                       // Compliant - but violates other rules\n~s32;                                      // Non-compliant - signed operand\n\nSee also"
  },
  {
    "rule": "Rule 7.0.5\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n77"
  },
  {
    "rule": "Rule 7.0.5\n\nIntegral promotion and the usual arithmetic conversions shall not \nchange the signedness or the type category of an operand\n\nS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\n[conv.prom]\n[conv.fpprom]\n[conv.integral]\n[conv.double]\n[conv.fpint]\n[conv.rank]\n[expr]\n\nThis rule applies to all expressions (including sub-expressions) of numeric type. It also applies within \npreprocessing directives, with the provision that expressions used in #if and #elif preprocessor \ndirectives always have the type intmax_t or uintmax_t. \n\nFor the usual arithmetic conversions, only the 9nal type of an operand is considered. For example, in \nthe expression u32 + u8, u8 is first converted to signed int through integral promotion before being \nconverted to uint32_t; it is the 9nal type of uint32_t that is considered by this rule.\n\nThis rule does not apply to the integral promotion of the operand to the increment or decrement \noperators.\n\nRationale\n\nIntegral promotion and the usual arithmetic conversions are usually value-preserving conversions, and \nit may therefore appear that they are always safe. However, the signedness of the converted type may,  \npossibly surprisingly, not be the same as the signedness of the operand. For example, when an  \nunsigned type is converted to a signed type, an operation may over^ow and trigger   undefined \nbehaviour instead of wrapping.\n\nThe increment and decrement operators convert their results to the type of their operand. This may \nbe a lossy, narrowing conversion, but the usefulness of these operators outweighs this risk.\n\nException\n\n1. A compile-time constant with signed integral type that has a non-negative value may be  \n\nconverted to an unsigned type through the usual arithmetic conversions.\n\n2. A compile-time constant with integral type may be converted to a ^oating type.\n\nExample\n\nThe following non-compliant examples do not directly pose a problem. However, using their results \ncould lead to surprising or unde%ned behaviour.\n\nu8a + u8b                             // Non-compliant - u8a and u8b -> signed int\nu8a += u8b                            // Non-compliant - same as u8a + u8b\nstatic_cast< uint32_t >( u8a ) + u8b  // Compliant - u8b -> unsigned int\nu8a += static_cast< uint32_t >( u8b ) // Compliant - u8a -> unsigned int\n\ns32 * s8                              // Compliant - s8 -> signed int\nu32 / u8                              // Compliant - u8 -> unsigned int\ns32 > u32                             // Non-compliant - s32 -> unsigned int\nu32a - 1                              // Compliant by exception #1\n\n78\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fb ? u8a : u8b                         // Compliant - no conversion\nb ? u8a : u16a                        // Non-compliant - u8a -> signed int and \n                                      //                 u16a -> signed int\n\narray[ u8 ]                           // Rule does not apply - no conversion of u8\nu8++                                  // Rule does not apply\n\nf32 += u32                            // Non-compliant - u32 -> floating\nf32 += 1                              // Compliant by exception #2\nf32 += 0x100'0001                     // Compliant by exception #2 - precision lost\n\n~u8                                   // Non-compliant - u8 -> signed int\n~u32                                  // Compliant\n-u8                                   // Non-compliant - u8 -> signed int\nu8 << 2                               // Non-compliant - u8 -> signed int\n\nconstexpr int32_t fn( int32_t i )\n{\n  return i * i; \n}\n\nu8  + fn( 10 )                        // Compliant by exception #1\nf32 + fn( 10 )                        // Compliant by exception #2"
  },
  {
    "rule": "Rule 7.0.6\n\nAssignment between numeric types shall be appropriate\n\n[conv]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to all assignments where the source and target have numeric type.\n\nA call is non-extensible when it is:\n\n\u25cf A quali9ed call to a member function (such as a.f( x ), this->f( x ), or A::f( x )); or\n\n\u25cf A call to an operator().\n\nA function argument arg is overload-independent when the call is:\n\n\u25cf Through a pointer to function or pointer to member function; or\n\n\u25cf Non-extensible, and, for all overloads that are callable with the same number of arguments, the \nparameters corresponding to  arg  have the same type. Note that a parameter of a function \ntemplate that is dependent on a function template parameter never has the same type.\n\nThe source and target within an assignment shall have the same type when the source expression is:\n\n1. An argument to a function call (including an implicit constructor call) and the corresponding \n\nparameter is not overload-independent; or\n\n2. Passed through the ellipsis parameter in a function call (where the target type is the promoted \n\ntype of the argument).\n\nFor all other assignments:\n\n1. The source and target shall have types of the same type category, signedness and size; or\n\n2. The source and target shall have types of the same type category, signedness, the source size \n\nshall be smaller than the target size, and the source shall be an id-expression; or\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n79\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\n3. The source shall be an integer constant expression and the target shall be either:\n\na. Any numeric type with a range large enough to represent the value, even if the value is not \n\nexactly representable (when storing to a ^oat, for example); or\n\nb. A bit-9eld whose value representation width (see [class.bit]/1) and signedness are capable \n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nof representing the value.\n\nRationale\n\nn\ne\ns\n\nThe C++ built-in operators perform many implicit conversions on their operands. These conversions \ncan lead to unexpected information loss, change of signedness, implementation-de%ned behaviour or \nundefined behaviour. This rule therefore places restrictions on the presence of implicit numeric \nconversions on assignment.\n\nFor ^oating-point types, the exact representation of a value is often not possible, so loss of precision \nwhen assigning a constant value is not a violation of this rule, provided it is within the range of the \ntarget type.\n\nAdditionally,   implicit   conversions   on  assignment  to   a   function   parameter   are   undesirable   as   they \ncould result in a silent change in overload selection due to changes elsewhere within the code, such  \nas the addition of a #include. For this reason, the implicit conversion of a function argument is not \npermitted \u2014 except when the corresponding parameter is  overload-independent, in which case an \nimplicit conversion of the type category is permitted as a silent change in overload selection cannot \noccur.\n\nException\n\nThe  assignment  to a parameter within a call to a constructor that is callable with a single   numeric \nargument is permitted to have a target type that is a wider version of the source type, provided that  \nthe class has no other constructors that are callable with a single argument, apart from copy or move \nconstructors. This allows an instance of the class to be created and used as a function parameter \nwithout requiring an explicit widening conversion of the source type.\n\nExample\n\nu32 = 1;                        // Compliant\ns32 = 4u * 2u;                  // Compliant\nu8  = 3u;                       // Compliant\nu8  = 3_u8;                     // Compliant\nu8  = 300u;                     // Non-compliant - value does not fit\n\nThe use of bit-9elds in the following example violates"
  },
  {
    "rule": "Rule 12.2.1. \n\nstruct S { uint32_t b : 2; } s; // Bit-field is considered to be uint8_t\n\ns.b = 2;                        // Compliant\ns.b = 32u;                      // Non-compliant - value does not fit\ns.b = u8;                       // Compliant - same width, but may truncate\ns.b = u16;                      // Non-compliant - narrowing\n\nvoid sb1( uint32_t );\nvoid sb1( uint8_t  );\nvoid sb2( uint8_t  );\n\nvoid sb3()\n{\n  sb1( s.b );                   // Non-compliant - s.b considered to be uint8_t,\n                                //                 but sb1( uint32_t ) is called\n  sb2( s.b );                   // Compliant\n}\n\n80\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nenum Colour : uint16_t\n{\n  red, green, blue\n} c;\n\nu8  = red;                      // Compliant - value can be represented\nu32 = red;                      // Compliant - value can be represented\nu8  = c;                        // Non-compliant - different sizes (narrowing)\nu32 = c;                        // Compliant - widening of id-expression\n\nenum States\n{\n  enabled, disabled\n};\n\nu8 = enabled;                   // Rule does not apply - source type not numeric\n\nunsigned long ul;\nunsigned int  ui = ul;          // Compliant - if sizes are equal\n\n  u8 = s8;                      // Non-compliant - different signedness\n  u8 = u8 + u8;                 // Non-compliant - change of sign and narrowing\n\nflt1 = s32;                     // Non-compliant - different type category\nflt2 = 0.0;                     // Non-compliant - different sizes and not an\n                                //                 integral constant expression\nflt3 = 0.0f;                    // Compliant\nflt4 = 1;                       // Compliant\nflt5 = 9999999999;              // Compliant - loss of precision is possible\n\nint f( int8_t s8 )\n{\n  int16_t val1 = s8;            // Compliant\n  int16_t val2 { s8 };          // Compliant\n  int16_t val3 ( s8 );          // Compliant\n  int16_t val4 { s8 + s8 };     // Non-compliant - narrowing, as s8 + s8 is int\n\n  switch ( s8 )\n  {\n    case 1:                     // Compliant\n    case 0xFFFF'FFFF'FFFF:      // Non-compliant - value does not fit in int8_t\n      return s8;                // Compliant - widening of id-expression\n  }\n\n  return s8 + s8;               // Compliant - s8 + s8 is of type int\n}\n\nThe following examples demonstrate the  assignment  to function parameters that are not  overload-\nindependent: \n\nvoid f1( int64_t i );\n\nf1( s32 + s32 );                // Non-compliant - implicit widening conversion\n\nvoid f2( int i );\n\nf2( s32 + s64 );                // Non-compliant - implicit narrowing conversion\nf2( s16 + s16 );                // Compliant - result of addition is int\n\nstruct A\n{\n  explicit A( int32_t i );\n  explicit A( int64_t i );\n};\n\nA a { s16 };                    // Non-compliant\n\n81\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n82\n\nvoid f3( long l );\n\nvoid ( *fp )( long l) = &f3;\n\nf3( 2 );                        // Non-compliant - implicit conversion from int to\n                                // long. Adding a #include would silently change\n                                // the selected overload if it added void f3( int )\n\nfp( 2 );                        // Compliant - calling through function pointer is\n                                //             overload-independent\n\nstruct MyInt\n{\n  explicit MyInt( int32_t );\n           MyInt( int32_t, int32_t );\n};\n\nvoid f4( MyInt );\n\nvoid bar ( int16_t s )\n{\n  f4( MyInt { s } );            // Compliant by exception - no need to cast s\n  MyInt i { s };                // Compliant by exception - no need to cast s\n}\n\nvoid log( char const * fmt, ... );\n\nvoid f( uint8_t c )\n{\n  log( \"f( %c )\", c );          // Non-compliant - conversion of c from uint8_t\n}                               //                 to int\n\nIn the following example, all overloads of the function A::set that can be called with two arguments \nhave the type  size_t  for their 9rst parameter. Therefore, the 9rst parameter in a quali9ed call to \nA::set is overload-independent: \n\nstruct A\n{\n  void set( short value );\n  void set( size_t index, int value );\n  void set( size_t index, std::string value );\n  void set( int index, double value ) = delete;   // Not callable\n  void g();\n};\n\nvoid f( A & a )\n{\n  a.set( 42, \"answer\" );        // Compliant - size_t can represent 42, and it is\n}                               // assigned to an overload-independent parameter\n\nvoid A::g()\n{\n  set( 42, \"answer\" );          // Non-compliant - even though this non-qualified\n                                // call will only select an overload in the class\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fIn the following example, both overloads of the function B::set can be called with two arguments, \nbut their 9rst parameters do not have the same type (even if  int  and  long  have the same size). \nTherefore, the 9rst parameter in a quali9ed call to B::set is not overload-independent: \n\nstruct B\n{\n  void set(  int index, int value );\n  void set( long index, std::string value );\n};\n\nvoid f( B & b )\n{\n  b.set( 42, \"answer\" );        // Non-compliant - conversion from int to long not\n}                               // allowed as parameter is not overload-independent\n\nstruct C\n{\n  int32_t x;\n  int64_t y;\n  int64_t z;\n};\n\nC c1 {\n       s16 + s16,               // Compliant - s16 + s16 is of type int\n       s16 + s16,               // Non-compliant - widening from int\n       s16                      // Compliant - widening of id-expression \n     };\n\ntemplate< typename T >\nstruct D\n{\n  void set1( T index, int value );\n  void set1( T index, std::string value );\n\n  template< typename S1 > void set2( S1 index, int value );\n  template< typename S2 > void set2( S2 index, std::string value );\n};\n\nvoid f( D< size_t > & a )\n{\n  a.set1( 42, \"X\" );            // Compliant - size_t is same type\n  a.set2< size_t >( 42, \"X\" );  // Non-compliant - 'S1' is never the same as\n}                               //   the specialized type of 'S2' (size_t)\n\n4.7.11 Pointer conversions \n\n [conv.ptr]"
  },
  {
    "rule": "Rule 7.11.1 nullptr shall be the only form of the null-pointer-constant\n\n[support.types.nullptr] Implementation 2\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nUsing any integral literal representing zero, including the literal 0 or the macro NULL, to represent the \nnull-pointer-constant is a violation of this rule.\n\nIn addition, the macro NULL shall not be used in any other context.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n83\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nRationale\n\nThe C++ Standard de9nes the object nullptr as the null-pointer-constant. \n\nThe literal 0 can also be used to represent a null-pointer-constant. However, 0 has type int, and its use \ncan lead to unexpected overload resolution. Note that the macro NULL expands to 0.\n\nNote: some library functions provide overloads for std::nullptr_t so that they can be selected \nduring overload resolution at compile-time, avoiding the need for a run-time check against nullptr.\n\nn\ne\ns\n\nExample\n\nvoid f1( int32_t * );\n\nvoid f2()\n{\n  f1( nullptr );     // Compliant\n  f1( 0 );           // Non-compliant - 0 used as the null pointer constant\n}\n\nThe following example shows the selection of an integer overload when NULL (which has a value of 0) \nis used instead of nullptr: \n\nvoid f3( int32_t   );\nvoid f3( int32_t * );\n\nvoid f4()\n{\n  f3( NULL );        // Non-compliant - calls the int32_t   overload\n  f3( nullptr );     // Compliant     - calls the int32_t * overload\n}\n\nThe following example shows non-compliant uses of NULL, where it is not used as the null-pointer-\nconstant: \n\n#define MYNULL NULL        // Non-compliant\n\nvoid f5()\n{\n  int32_t one = NULL + 1;  // Non-compliant - NULL used as an integer\n\n  throw NULL;              // Non-compliant - caught by catch ( int )\n}"
  },
  {
    "rule": "Rule 7.11.2 An array passed as a function argument shall not decay to a pointer\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nAn object of array type decays to a pointer when it is passed as a function argument. As a consequence, it \nbecomes more di[cult to detect array bounds errors as the array\u2019s bounds are lost.\n\nIf a design requires arrays of different lengths, then measures shall be taken to ensure that the  \ndimensionality is maintained.\n\nNote:"
  },
  {
    "rule": "Rule 11.3.1 recommends that C-style arrays should not be used as better options are available \nin C++.\n\n84\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fException\n\nPassing a string literal as an argument to a function that expects a pointer to character parameter is \npermitted, as the literal is guaranteed to end with a sentinel character (of value 0) which can be used \nto detect the end of the array.\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\nExample\n\nvoid f1( int32_t   p[ 10 ]    );             // Array will decay to pointer\nvoid f2( int32_t * p          );             // Array will decay to pointer\nvoid f3( int32_t ( &p )[ 10 ] );             // Only accepts arrays of 10 elements\n\ntemplate< size_t N >                         // Accepts arrays of any size, with the\nvoid f4( int32_t ( &p )[ N ] );              // size being automatically deduced\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nvoid f5( initializer_list< int32_t > l );\nvoid log( char const * s );\nvoid log( string_view  s );\n\nNote: it is also possible to deduce the size of an array argument without changing the function into a \ntemplate. For example, an intermediate class can be used to wrap the array, with the constructor  \ndeducing the size using the same technique as shown in f4 (above). Arguments can then use this \nwrapper class, avoiding the array to pointer decay. The std::span class that has been introduced in \nC++20 uses this idiom.\n\nvoid b()\n{\n  int32_t a[ 10 ];\n\n  f1( a );   // Non-compliant - dimension lost due to array to pointer conversion\n  f2( a );   // Non-compliant - dimension lost due to array to pointer conversion\n  f3( a );   // Compliant     - dimension of 10 matches that of the parameter\n  f4( a );   // Compliant     - dimension deduced to be 10\n\n  f5( { 1, 2 } );                // { 1, 2 } is an initializer_list, not an array\n\n  log( \"Hello\" );                // Compliant by exception\n  char const msg[] = \"Hello\";\n  log( msg );                    // Non-compliant - not a literal\n\n  string_view msg2 = \"Hello\"sv;  // Compliant by exception - the literal operator\n                                 //   has a string literal as an argument\n  log( msg2 );                   // msg2 is a string_view, not an array\n}\n\nSee also"
  },
  {
    "rule": "Rule 11.3.1"
  },
  {
    "rule": "Rule 7.11.3 A conversion from function type to pointer-to-function type shall only \n\noccur in appropriate contexts\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA conversion to pointer to function is appropriate when it occurs:\n\n1. Through a static_cast; or\n\n2.\n\nIn an assignment to an object with pointer-to-function type.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n85\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n86\n\nRationale\n\nThe use of a function pointer in Boolean contexts may result in a well-formed program that is contrary \nto developer expectations. For example, if the developer writes if ( f ), then it is not clear whether \nthe intent is to test if the address of the function evaluates to nullptr, or that a call to the function \nf should be made but the call operator has been unintentionally omitted. The use of the & (address-\nof) operator or an explicit conversion with a static_cast to a function pointer removes this ambiguity.\n\nUsing a function as an operand in an arithmetic expression will trigger pointer decay.\n\nExample\n\nextern int * f();\n\nif ( f == nullptr )          // Non-compliant\n{\n}\n\nif ( &f != nullptr )         // Compliant - no conversion\n{ \n  (f)();                     // Compliant - no conversion\n}\n\nstd::cout << std::boolalpha  // Compliant - assignment to pointer-to-function type\n          << f;              // Non-compliant - assignment is not to \n                             // pointer-to-function type\n\nauto x = +f;                 // Non-compliant\n\nvoid f1( double   );\nvoid f1( uint32_t );\n\nauto selected = static_cast< void(*)( uint32_t ) >( f1 );  // Compliant\n\nauto lam = [](){};\nvoid ( *p )() = lam;         // Compliant\nauto x = +lam;               // Non-compliant\n\nif ( lam )                   // Non-compliant\n{\n}\n\nSee also"
  },
  {
    "rule": "Rule 7.0.2,"
  },
  {
    "rule": "Rule 8.2.4\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n4.8\n\nExpressions\n\n4.8.0 MISRA \n\n [misra]"
  },
  {
    "rule": "Rule 8.0.1\n\nParentheses should be used to make the meaning of an expression \nappropriately explicit\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe following table is used in the de9nition of this rule. \n\nDescription\n\nOperator or Operand\n\nRanking\n\nOther\n\nAny operator or operand not listed below\n\n14 (high)\n\nMultiplicative\n\n* / %\n\nAdditive\n\n+ -\n\nBitwise shift\n\n<< >>\n\nRelational\n\n< > <= >=\n\nEquality\n\n== !=\n\nBitwise AND\n\nBitwise XOR\n\nBitwise OR\n\nLogical AND\n\nLogical OR\n\nConditional\n\n&\n\n^\n\n|\n\n&&\n\n||\n\n?:\n\nAssignment\n\n= *= /= %= += -= <<= >>= &= ^= |=\n\nThrow\n\nComma\n\nthrow\n\n,\n\n13\n\n12\n\n11\n\n10\n\n9\n\n8\n\n7\n\n6\n\n5\n\n4\n\n3\n\n2\n\n1\n\n0 (low)\n\nThe rankings used in this table are chosen to allow a concise description of the rule. They are not  \nnecessarily the same as those that might be encountered in the C ++ Standard\u2019s descriptions of \noperator precedence.\n\nNotes:\n\n1. Operators having alternative token representations (see [lex.digraph]) have the same ranking \n\nas their primary form.\n\n2. The additive row does not include unary plus and unary minus, which have rank 14.\n\nAn expression is appropriately explicit when:\n\n\u25cf Its ranking is 0, 1, 2 or 14; or\n\n\u25cf Each operand:\n\n\u25ac Is parenthesized; or\n\n\u25ac Has a ranking of 14; or\n\n\u25ac Has ranking less than or equal to that of the expression.\n\nAdditionally, the operand to the sizeof operator should be parenthesized.\n\n87\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nFor the purposes of this rule, the ranking of an expression is the ranking of the element (operand or  \noperator) at the root of the parse tree for that expression. For a sub-expression, its ranking is that of \nthe element at the \u201croot\u201d of the sub-tree.\n\nFor example, using the syntax and precedence rules from the C++ Standard, the parse tree for the \nnon-compliant expression a << b + c can be represented as: \n\n     <<\n    /  \\\n   a    +\n       / \\\n      b   c\n\nThe element at the root of this parse tree is '<<', so the expression has ranking 11. The root of the \nsub-tree for b + c is +, which has ranking 12.\n\nRationale\n\nThe C++ language has a comparatively large number of operators and their relative precedences are \nnot intuitive. This can lead less experienced developers to make mistakes. Using parentheses to make \noperator bindings explicit removes the possibility that the developer\u2019s expectations are incorrect. It \nalso makes the original developer\u2019s intention clear to reviewers or maintainers of the code.\n\nIt is recognized that overuse of parentheses can clutter the code and reduce its readability. However, \ntoo few parentheses can lead to unintuitive code. This rule tries to achieve a reasonable compromise.\n\nNote: this rule does not require the operands of a comma operator to be parenthesized, even though \nthe result may not meet developer expectation. However, use of the comma operator is not compliant \nwith"
  },
  {
    "rule": "Rule 8.19.1. \n\nx = a, b;   // Parsed as ( x = a ), b \n\nExample\n\nThe following examples show expressions with a unary or postfix operator whose operands are either \nprimary-expressions or expressions whose top-level operators have ranking 14: \n\na[ i ]->n;               // Compliant - no need to write ( a[ i ] )->n          \n*p++;                    // Compliant - no need to write *( p++ )              \nsizeof x + y;            // Non-compliant - write either sizeof ( x ) + y\n                         // or sizeof ( x + y )  \n\nThe following examples show expressions containing operators of the same ranking: \n\na + b - c + d;           // Compliant\n( a + b ) - ( c + d );   // Compliant - produces a different result\n\nThe following examples show a variety of mixed-operator expressions: \n\nx = f ( a + b, c );      // Compliant - no need to write f ( ( a + b ), c )\n\nx = a == b ? a : a - b;  // Non-compliant - operands of conditional operator\n                         // (ranking 3) are:\n                         //   == (ranking 9) needs parentheses\n                         //   a  (ranking 14) does not need parentheses\n                         //   -  (ranking 12) needs parentheses\n\nx = ( a == b ) ? a : ( a - b );   // Compliant version of previous example\n\nNote:  the assignment operators in the previous two examples are compliant \u2014 the ranking of the \nassignment operator is less than 3, so its operands do not need parentheses.\n\n88\n\nx = a << b + c;       // Non-compliant - operands of << operator\n                      // (ranking 11) are:\n                      //  a  (ranking 14) does not need parentheses\n                      //  +  (ranking 12) needs parentheses\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\na && b && c;          // Compliant - all operators are the same.\na && b || c;          // Non-compliant - || (ranking 4) has operand && (ranking 5)\na || b && c;          // Non-compliant - || (ranking 4) has operand && (ranking 5)\na || b || c;          // Compliant - all operators are the same\n\n#if defined( A ) && defined( B ) || defined( C )  // Non-compliant\n\n4.8.1\n\nPrimary expressions \n\n [expr.prim]"
  },
  {
    "rule": "Rule 8.1.1\n\nA non-transient lambda shall not implicitly capture this\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nIf a lambda with implicit capture (having = or & in the capture list) attempts to capture a member \nvariable of a class, what is in fact captured is the this pointer. This behaviour can be surprising, and \nmay result in undefined behaviour if the lambda is called after the object\u2019s lifetime has ended. This issue \ncannot occur for a transient lambda.\n\nNote: implicitly capturing this using [=] is deprecated from C++20.\n\nExample\n\nclass A\n{\n  int16_t val;\n\n  void f()\n  {\n    auto a1 = [=]()                 // Non-compliant - val is not captured, but\n              { return val; };      // 'this' is implicitly captured\n    auto a2 = [&]()                 // Non-compliant - val is not captured, but\n              { return val; };      // 'this' is implicitly captured\n    auto a3 = [this]()              // Compliant - 'this' explicitly captured\n              { return val; };\n    auto a4 = [self = *this]()      // Compliant - current object captured by copy\n              { return self.val; };\n    auto i  = [&]()                 // Rule does not apply - transient lambda\n              { return val; } ();\n  }\n};"
  },
  {
    "rule": "Rule 8.1.2\n\nVariables should be captured explicitly in a non-transient lambda\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to capture by value and capture by reference.\n\nRationale\n\nNaming the variables captured by a lambda expression clarifies its dependencies. This allows variables \ncaptured by reference and pointers captured by value to be more easily identi9ed, helping to ensure \nthat they are not dangling when the lambda is called.\n\n89\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n90\n\nThis issue cannot occur for a transient lambda, so there is no need to explicitly capture its variables.\n\nExample\n\nvoid bar( double val, double min, double max )\n{\n  auto const easedVal = [&]()\n  {\n    if ( val < min ) { return ( val + min ) / 2; }\n    if ( val > max ) { return ( val + max ) / 2; }\n    return val;\n  }();                                          // Compliant - called immediately\n\n  auto const ease = [&]()\n  {\n    if ( val < min ) { return ( val + min ) / 2; }\n    if ( val > max ) { return ( val + max ) / 2; }\n    return val;\n  };                                            // Non-compliant\n  ease();                                       //   - not an immediate call\n}\n\ntemplate< typename It, typename Func >\nbool f1( It b, It e, Func f )                   // f1 does not store f\n{\n  for ( It it = b; it != e; ++it )\n  {\n    if ( f( *it ) )                             // f is called\n    {\n      return true;\n    }\n  }\n\n  return false;\n}\n\ntemplate< typename Cont, typename Func >\nbool f2( Cont const & c, Func f )               // f2 does not store f\n{\n  return f1( std::begin(c), std::end(c), f );   // f passed to non-storing function\n}\n\nvoid foo( std::vector< size_t > const & v, size_t i )\n{\n  bool b1 = f1( v.cbegin(), v.cend(),\n                [&]( size_t elem ) { return elem == i; } );  // Compliant\n  bool b2 = f2( v,\n                [&]( size_t elem ) { return elem == i; } );  // Compliant\n}\n\nstruct Speedometer\n{\n  std::vector< std::function< void ( double ) > > observers;\n\n  template< typename Func >\n  void addObserver( Func f )                    // addObserver stores f\n  {\n    observers.push_back( f );                   // Copying f to the std::function\n  }\n};\n\nvoid process( std::function< Speedometer() > );\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fauto f3()\n{ \n  Speedometer s;\n\n  process( [&](){ return s; } );                // Non-compliant - conversion to\n                                                //  std::function stores the lambda\n  return [=]() { return s; };                   // Non-compliant - implicit capture\n}\n\nvoid addLoggers( Speedometer s, std::ostream & os )\n{\n  s.addObserver( [&]( double speed )            // Non-compliant - implicit capture\n                 { os << speed; });\n  s.addObserver( [&os]( double speed )          // Compliant - explicit capture\n                 { os << speed; } );\n  s.addObserver( []( double speed )             // Compliant - no capture\n                 { std::cout << speed; } );\n}\n\n4.8.2\n\nPost2x expressions \n\n [expr.post]"
  },
  {
    "rule": "Rule 8.2.1\n\nA virtual base class shall only be cast to a derived class by means of \ndynamic_cast\n\n[expr.static.cast] / 11\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to both pointer and reference casts.\n\nRationale\n\nThe behaviour when casting from a virtual base class to a derived class is only well defined when \ndynamic_cast is used, whilst the use of the other casts can result in undefined behaviour. Since \nC++17, a static_cast from a virtual base class is now ill-formed, but some compilers may not yet \nissue a diagnostic. This rule ensures that all cases are detected.\n\nExample\n\nclass B  { };\nclass D: public virtual B { };\n\nD d;\nB * pB  = &d;\nD * pD1 = reinterpret_cast< D * >( pB  );   // Non-compliant\nD * pD2 = dynamic_cast< D * >( pB  );       // Compliant - pD2 may be null\nD & D3  = dynamic_cast< D & >( *pB );       // Compliant - may throw an exception\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n91\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:"
  },
  {
    "rule": "Rule 8.2.2\n\nC-style casts and functional notation casts shall not be used\n\n[expr.type.conv]\n[expr.cast]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nAmpli2cation\n\nThis rule does not apply to functional notation casts that use curly braces or that result in a constructor \ncall.\n\nRationale\n\nC-style casts and functional notation casts raise several concerns:\n\n1. They permit almost any type to be converted to almost any other type without checks;\n\n2. They give no indication why the conversion is taking place;\n\n3. Their syntax is more di[cult to recognize.\n\nThese concerns can be addressed with the use of const_cast, dynamic_cast, static_cast and \nreinterpret_cast, which:\n\n1. Enforce constraints on the types involved;\n\n2. Give a better indication of the cast\u2019s intent;\n\n3. Are easy to identify.\n\nException\n\nA C-style cast to  void  is permitted, as this allows the intentional discarding of a value to be made \nexplicit \u2014 for instance, the return value of a non-void function call (see"
  },
  {
    "rule": "Rule 0.1.2).\n\nExample\n\nint32_t g();\n\nvoid f1()\n{\n  ( void ) g();  // Compliant by exception\n}\n\nIn the following example (which violates"
  },
  {
    "rule": "Rule 8.2.3), the C-style casts from a1 to the non-const pointer \na2 is more permissive than necessary. If the type of a1 is not A, then the C-style cast to a2 will compile, \nresulting in unde%ned behaviour. The equivalent const_cast to a3 will not compile if the type of a1 \nis changed. \n\nstruct A\n{\n  A( char c);\n};\n\nstruct B {};\n\nvoid f1a( A x )\n{\n  auto const & a1 = x;\n  A          * a2 = ( A * )&a1;                // Non-compliant\n  A          * a3 = const_cast< A * >( &a1 );\n}\n\n92\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fvoid f1b( B x )\n{\n  auto const & a1 = x;\n  A          * a2 = ( A * )&a1;                // Non-compliant\n  A          * a3 = const_cast< A * >( &a1 );  // Ill-formed\n}\n\nvoid f2( int32_t x )\n{\n  auto i = A( 'c' );        // Rule does not apply - constructor is called\n  auto j = int8_t { 42 };   // Rule does not apply - use of curly braces\n  auto k = int8_t ( x );    // Non-compliant - does not construct an object\n}                           // of class type\n\nSee also"
  },
  {
    "rule": "Rule 0.1.2,"
  },
  {
    "rule": "Rule 8.2.3"
  },
  {
    "rule": "Rule 8.2.3\n\nA cast shall not remove any const or volatile quali9cation from \nthe type accessed via a pointer or by reference\n\n[expr.const.cast] Unde9ned 1\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nUsing a cast to remove the qualification associated with the addressed type is a violation of the  \nprinciple of type quali9cation.\n\nSome of the problems that might arise include:\n\n\u25cf Removal of const quali9cation might circumvent the read-only status of an object, which may \n\nlead to unde%ned behaviour;\n\n\u25cf Removal of  const  qualification might result in a hardware exception when the object is \n\naccessed;\n\n\u25cf Removal of volatile quali9cation might result in accesses to an object being removed during \n\noptimization.\n\nExample\n\n         uint16_t           x;\n         uint16_t * const   cpi = &x;       // const pointer\n         uint16_t * const * pcpi;           // pointer to const pointer\n         uint16_t *       * ppi;\n   const uint16_t         * pci;            // pointer to const\nvolatile uint16_t         * pvi;            // pointer to volatile\n         uint16_t         * pi;\n\npi = cpi;                                   // Rule does not apply - no cast\n\npi  = const_cast< uint16_t *  >( pci  );    // Non-compliant\npi  = const_cast< uint16_t *  >( pvi  );    // Non-compliant\nppi = const_cast< uint16_t ** >( pcpi );    // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n93\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nThe following examples also violate"
  },
  {
    "rule": "Rule 8.2.2.\n\npi  = ( uint16_t *  )pci;                   // Non-compliant\npi  = ( uint16_t *  )pvi;                   // Non-compliant\nppi = ( uint16_t ** )pcpi;                  // Non-compliant\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nSee also"
  },
  {
    "rule": "Rule 8.2.2\n\nn\ne\ns"
  },
  {
    "rule": "Rule 8.2.4\n\nCasts shall not be performed between a pointer to function and any \nother type\n\n[expr.reinterpret.cast] Unspeci9ed 6\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nFor the purposes of this rule, a pointer to a member is considered to be a pointer to function.\n\nThe following standard conversions are permitted by this rule, even if they are the result of a cast:\n\n\u25cf Function-to-pointer conversions (implicitly taking the address of a function); and\n\n\u25cf Function pointer conversions (from a pointer to noexcept function to pointer to function); and\n\n\u25cf Null pointer conversions (from nullptr to a pointer to function); and\n\n\u25cf User-de9ned conversions, including converting from a lambda with no capture to a pointer to  \n\nfunction.\n\nNote: the cast notation that is used to disambiguate an overloaded function name ([over.over]) is \ncompliant with this rule because the target type is a function type that is compatible with the source \ntype.\n\nRationale\n\nConverting a pointer to function into or from any of the following may result in unde%ned behaviour:\n\n\u25cf Pointer to object;\n\n\u25cf Pointer to non-static data member;\n\n\u25cf Pointer to an object of incomplete type;\n\n\u25cf void *.\n\nCalling a function by means of a pointer whose type is not compatible with the called function also  \nresults in unde%ned behaviour.\n\nCasts that are equivalent to a standard conversion cannot lead to those problems and are therefore  \npermitted.\n\nNote: this rule also applies to pointer to member objects as they are callable and can be used with \nstd::invoke.\n\nException\n\nA cast to  void  may be used to signify that a function pointer returned by a function call is being \nintentionally discarded (see"
  },
  {
    "rule": "Rule 0.1.2).\n\n94\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fExample\n\nusing pf16_t = void (*)( int16_t n );\nusing pf32_t = void (*)( int32_t n );\n\npf16_t getPf16();\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\npf16_t p1 = static_cast< pf16_t >( nullptr );   // Compliant - cast is equivalent\n                                                // to a standard conversion\npf32_t p2 = reinterpret_cast< pf32_t >( p1 );   // Non-compliant - function pointer\n                                                // types are different\n\n( void ) getPf16();                             // Compliant by exception\n\nif ( p1 )                                       // Rule does not apply - no cast;\n{                                               // contextually converted to bool\n}\n\npf16_t    p3 = ( pf16_t ) 0x8000;                          // Non-compliant\npf16_t    p4 = reinterpret_cast< pf16_t >( 0xdeadbeef );   // Non-compliant\nint16_t * p5 = reinterpret_cast< int16_t * >( p4 );        // Non-compliant\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nvoid f5();\nvoid f5( int16_t );\n\ntemplate< typename T >\nvoid f6( T );\n\nvoid f7()\n{\n  f6( static_cast< void (*)() >( f5 ) );        // Compliant - overload selection\n}\n\nstruct A { void foo(); int32_t i; };\nstruct B : A { };\n\nauto pm1 = static_cast< void ( B::* )() >( &A::foo );      // Non-compliant\nauto pm2 = static_cast< int32_t ( B::* ) >( &A::i );       // Non-compliant\n\nSee also"
  },
  {
    "rule": "Rule 0.1.2,"
  },
  {
    "rule": "Rule 8.2.5"
  },
  {
    "rule": "Rule 8.2.5\n\nreinterpret_cast shall not be used\n\n[basic.types] / 2\n[basic.compound] / 4\n[expr.reinterpret.cast]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nCasting between unrelated types generally results in unde%ned behaviour. \n\nException\n\nThe following are allowed by exception as the behaviour is well de9ned:\n\n1. Using reinterpret_cast< T * > to cast any object pointer to a pointer to T, where T is one \n\nof void, char, unsigned char or std::byte, possibly cv-quali%ed.\n\n95\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\n2. Using reinterpret_cast< T >( p ) to convert a pointer p to an integer of type T that is \n\nlarge enough to represent a pointer value (e.g. std::uintptr_t).\n\nExample\n\nuint8_t  * p1;\nuint32_t * p2;\n\np2 = reinterpret_cast< uint32_t * >( p1 );                   // Non-compliant\n\nn\ne\ns\n\nextern uint32_t read_value();\nextern void     print( uint32_t n );\n\nvoid f()\n{\n  uint32_t   u  = read_value();\n  uint16_t * p3 = reinterpret_cast< uint16_t * >( &u );      // Non-compliant \n}\n\nvoid g() \n{\n  std::array< int32_t, 2 > a{};\n  auto p4 = reinterpret_cast< int32_t(*)[ 2 ]>( a.data() );  // Non-compliant\n\n  ( *p4 )[ 0 ] = 42;                                         // Undefined behaviour\n}\n\nIn the following example, the target type uint64_t used in the initializer for p7 violates"
  },
  {
    "rule": "Rule 8.2.8.\n\nvoid h( float x )\n{\n  auto p5 = reinterpret_cast< std::byte const * >( &x );  // Compliant by exception\n  auto p6 = reinterpret_cast< std::uintptr_t    >( &x );  // Compliant by exception\n  auto p7 = reinterpret_cast< uint64_t          >( &x );  // Compliant by exception\n}\n\nSee also"
  },
  {
    "rule": "Rule 8.2.1,"
  },
  {
    "rule": "Rule 8.2.6,"
  },
  {
    "rule": "Rule 8.2.8"
  },
  {
    "rule": "Rule 8.2.6\n\nAn object with integral, enumerated, or pointer to void type shall \nnot be cast to a pointer type\n\n[expr.reinterpret.cast] Unspeci9ed 7\n[expr.static.cast] Unde9ned 12; Unspeci9ed 13\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule does not apply:\n\n\u25cf When the destination type is a pointer to function type or a pointer to member function type \n\n(see"
  },
  {
    "rule": "Rule 8.2.4); or\n\n\u25cf For casts between pointers to void, regardless of any cv-quali%cation.\n\nRationale\n\n96\n\nCasting from either an integral type or a pointer to void type to a pointer to an object may lead to \nunspeci%ed behaviour.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fA round trip conversion of a pointer to object type through  void * (T * -> void * -> T *) is well-\nde9ned. However, this is prohibited by this rule as it is error prone and the detection of any error  \nwould be undecidable.\n\nNote:  casting from an integer to a pointer may be unavoidable when addressing memory mapped \nregisters or other hardware speci9c features. \n\nExample\n\nstruct S\n{\n  int32_t i;\n  int32_t j;\n};\n\nvoid f ( void * p1, int32_t i )\n{\n     S * s1 = static_cast< S * >( p1 );           // Non-compliant\n     S * s2 = reinterpret_cast< S * >( i );       // Non-compliant\n  void * p2 = reinterpret_cast< void * >( i );    // Non-compliant\n  auto   p3 = const_cast< void const * >( p2 );   // Compliant\n}\n\nSee also"
  },
  {
    "rule": "Rule 8.2.4,"
  },
  {
    "rule": "Rule 8.2.5"
  },
  {
    "rule": "Rule 8.2.7\n\nA cast should not convert a pointer type to an integral type\n\n[expr.reinterpret.cast] Implementation 4, 5\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nCasting between a pointer and an integer type makes it harder for tools and developers to understand \nand reason about code behaviour. For example, pointer tracking within tools may become unreliable \nwhen pointers are cast to integers.\n\nNote: casting between pointers and integers may be unavoidable when addressing memory mapped \nregisters or other hardware speci9c features. When the advice given in this rule is not followed, the \nuse of std::uintptr_t or std::intptr_t is required by"
  },
  {
    "rule": "Rule 8.2.8 as these types are guaranteed \nto be able to represent all possible pointer values.\n\nExample\n\nThe following examples violate"
  },
  {
    "rule": "Rule 8.2.5, with the second also violating"
  },
  {
    "rule": "Rule 8.2.8:\n\nstruct S;\n\nvoid f( S * s )\n{\n  std::intptr_t p = reinterpret_cast< std::intptr_t >( s );   // Non-compliant\n  std::uint8_t  q = reinterpret_cast< std::uint8_t  >( s );   // Non-compliant\n}\n\nSee also"
  },
  {
    "rule": "Rule 8.2.5,"
  },
  {
    "rule": "Rule 8.2.8\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n97\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 8.2.8\n\nAn object pointer type shall not be cast to an integral type other than \nstd::uintptr_t or std::intptr_t\n\n[expr.reinterpret.cast] Implementation 4, 5\n[cstdint.syn]\n[basic.compound] / 3\n\nCategory Required\n\nn\ne\ns\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe type-id used in the cast-expression shall explicitly specify std::uintptr_t or std::intptr_t.\n\nRationale\n\nThe types std::uintptr_t and std::intptr_t are the only types that are guaranteed to be able \nto represent all possible values of an object pointer type.\n\nNote: these types are optional and may not be available in all implementations, in which case a  \ndeviation will need to be raised against this rule.\n\nExample\n\nstruct S;\n\nvoid f1( S * s )\n{\n  auto p0 = reinterpret_cast< std::uintptr_t >( s );    // Compliant\n\n  auto p1 = reinterpret_cast< unsigned long >( s );     // Non-compliant\n\n  using hashPtr_t = std::uintptr_t;\n\n  auto p2 = reinterpret_cast< hashPtr_t >( s );         // Non-compliant\n}\n\ntemplate< typename T > void f2( S * s )\n{\n  auto p = reinterpret_cast< T >( s );       // Non-compliant - T is not explicitly\n}                                            //                 std::uintptr_t\n\ntemplate void f2< std::uintptr_t >( S * s );\n\nSee also"
  },
  {
    "rule": "Rule 8.2.5,"
  },
  {
    "rule": "Rule 8.2.7\n\n98\n\nLicensed to: gunjanjain\n22 Apr 2025"
  },
  {
    "rule": "Rule 8.2.9\n\nThe operand to typeid shall not be an expression of polymorphic \nclass type\n\n[expr.typeid]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule does not apply to typeid( type-id ). \n\nstd::type_info const & type { typeid( std::iostream ) };  // Rule does not apply\n\nRationale\n\nAn expression of polymorphic  class  type used as the operand to  typeid  may or may not be \nevaluated at runtime. It is therefore unclear if potential side effects within the expression will or will not \noccur.\n\nAdditionally, typeid could throw a std::bad_typeid exception, but this will only happen if the \noperand has polymorphic class type.\n\nNote: this rule applies even when there is no runtime evaluation.\n\nExample\n\n#include <typeinfo>\n\nstruct S { };                         // Non-polymorphic\nstruct P { virtual void foo() {} };   // Polymorphic\n\nconst std::type_info & foo( S * s )\n{\n  return typeid( *s );                // Compliant\n}\n\nconst std::type_info & foo( P * p )\n{\n  return typeid( *p );                // Non-compliant\n}\n\nconst std::type_info & foo( P p )\n{\n  return typeid( p );                 // Non-compliant\n}\n\nconst std::type_info & bar( P * p )\n{\n  return typeid( p->foo() );          // Compliant - type is always 'void'\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n99\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns"
  },
  {
    "rule": "Rule 8.2.10\n\nFunctions shall not call themselves, either directly or indirectly\n\nCategory Required\n\nAnalysis Undecidable, System\n\nRationale\n\nRecursion carries with it the danger of exceeding available stack space, which can lead to a serious \nfailure. Unless recursion is very tightly controlled, it is not possible to determine before execution  \nwhat the worst-case stack usage could be.\n\nNote: any deviation used to justify non-compliance with this rule will need to explain how stack usage  \nis to be controlled.\n\nException\n\nA constexpr function that is only called within a core constant expression may be recursive.\n\nExample\n\nint32_t fn( int32_t x )\n{\n  if ( x > 0 )\n  {\n    x = x * fn( x - 1 );              // Non-compliant\n  }\n\n  return x;\n}\n\n// File1.cpp\nint32_t fn_3( int32_t x );\n\nint32_t fn_2( int32_t x )\n{\n  if ( x > 0 )\n  {\n    x = x * fn_3( x - 1 );            // Non-compliant\n  }\n\n  return x;\n}\n\n// File2.cpp\nint32_t fn_2( int32_t x );\n\nint32_t fn_3( int32_t x )\n{\n  if ( x > 0 )\n  {\n    x = x * fn_2( x - 1 );            // Non-compliant\n  }\n\n  return x;\n}\n\n100\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nIn the following, the recursion within  fn_4  satis9es the requirements of the exception as it is  only \ncalled from within a core constant expression. \n\nconstexpr int32_t fn_4( int32_t x )\n{\n  if ( x > 0 )\n  {\n    x = x * fn_4( x - 1 );            // Compliant by exception\n  }\n\n  return x;\n}\n\nconstexpr int32_t n = fn_4( 6 );      // Core constant expression\n\nconstexpr int32_t fn_5( int32_t x )\n{\n  if ( x > 0 )\n  {\n    x = x * fn_5( x - 1 );            // Non-compliant\n  }\n\n  return x;\n}\n\nint32_t n = fn_5( 6 );                // Not a core constant expression\n\ntemplate< class T >\nauto Sum( T t )\n{\n  return t;\n}\n\ntemplate< class T, class ... Vals >\nauto Sum( T t, Vals ... vals )\n{\n  return t + Sum( vals ... );         // Compliant - calls a different overload\n}"
  },
  {
    "rule": "Rule 8.2.11 An argument passed via ellipsis shall have an appropriate type\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe following types are not appropriate:\n\n1. class types with virtual member functions;\n\n2. class types having non-trivial copy or move operations;\n\n3. class types having a non-trivial destructor.\n\nThis rule does not apply to unevaluated contexts.\n\nRationale\n\nPassing arguments of some class types via an ellipses parameter is only conditionally-supported with \nimplementation-de%ned behaviour.\n\n101\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nDefault argument promotions are applied to ellipsis parameters, which may lead to the type that is \npassed to the function diCering from the type that would be passed to a normal function parameter  \nor when passed as a parameter pack.\n\nNote: passing arguments to a parameter pack is not passing via ellipsis.\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nExample\n\nstruct A\n{\n  int i { 42 };\n  virtual ~A() = default;\n};\n\nvoid f()\n{\n  std::printf ( \"hello %d\", A{} );   // Non-compliant\n}\n\nThe following example uses overload resolution and type deduction; it does not pass an argument \nvia ellipsis at run-time: \n\nstruct two { char x[2]; };\n\ntwo  test( int );\nchar test( ... );\n\ntemplate< typename T >\nconstexpr bool isIntCompatible( T x )\n{\n  if constexpr ( sizeof( test( x ) ) == 1 )  // Compliant - unevaluated context\n  {\n    return false;                            // Overload resolution -> test( ... )\n  }\n\n  else\n  {\n    return true;                             // Overload resolution -> test( int )\n  }\n}\n\nSee also"
  },
  {
    "rule": "Rule 21.10.1\n\n4.8.3\n\nUnary expressions \n\n [expr.unary]"
  },
  {
    "rule": "Rule 8.3.1\n\nThe built-in unary - operator should not be applied to an expression \nof unsigned type\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to the type of an expression before any integral promotion.\n\nRationale\n\n102\n\nApplying the built-in unary - operator to an expression whose promoted type is unsigned generates \na result of the same unsigned type, which may not meet developer expectations.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fThe result of applying the unary - operator to an expression whose type is unsigned prior to integral \npromotion will only be negative when the promoted type is signed. The promoted type depends on \nthe operand\u2019s rank and the implemented integer sizes.\n\nExample\n\nThe following example assumes that int is 32 bits. \n\nvoid f(  int32_t a );\nvoid f( uint32_t a );\n\nvoid g( uint32_t x, uint16_t y )\n{\n  f( -x );             // Non-compliant - calls f( uint32_t a )\n  f( -y );             // Non-compliant - calls f(  int32_t a )\n}"
  },
  {
    "rule": "Rule 8.3.2\n\nThe built-in unary + operator should not be used \n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n[expr.unary.op] / 7\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThe built-in unary + operator triggers integral promotion, but otherwise performs no other operation. \nWhen its operand is a function name or lambda, decay to a function pointer is triggered. The use of \nstatic_cast is recommended instead as it makes it clear that these conversions are present.\n\nExample\n\nauto  x = + u8a;             // Non-compliant - triggers promotion to int\nauto pf = +[](){};           // Non-compliant - pf is a void(*)()\n\nx = +1;                      // Non-compliant\nx =+ 1;                      // Non-compliant - unary +, not +=\n\nenum A : uint8_t { one };\nenum B : uint8_t { two };\n\nuint8_t operator+( B b ) { return b; }\n\nauto a = +one;               // Non-compliant\nauto b = +two;               // Rule does not apply\nauto c = operator+( two );   // Rule does not apply\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n103\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n4.8.7\n\nAdditive operators \n\n [expr.add]"
  },
  {
    "rule": "Rule 8.7.1\n\nPointer arithmetic shall not form an invalid pointer\n\n[expr.add] Unde9ned 4\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nThis rule applies to all forms of pointer arithmetic, including array indexing: \n\ninteger_expression + pointer_expression\npointer_expression + integer_expression\npointer_expression - integer_expression\npointer_expression += integer_expression\npointer_expression -= integer_expression\n++pointer_expression\n--pointer_expression\npointer_expression++\npointer_expression--\npointer_expression [ integer_expression ]\ninteger_expression [ pointer_expression ]\n\nA pointer resulting from pointer arithmetic is invalid if it does not point to:\n\n\u25cf An element of the same array as the original pointer; or\n\n\u25cf One past the end of the same array as the original pointer.\n\nThis rule also applies to pointer arithmetic that occurs within the C++ Standard Library functions. In  \naddition, it is assumed that the implementation of the functions listed below perform pointer arithmetic \non their pointer parameters:\n\nmemchr, memcmp, memcpy, memmove, memset, strncat, strncmp, strncpy, strxfrm\n\nNote: a pointer to an object that is not an array is treated as if it were a pointer to the 9rst element of  \nan array with a single element.\n\nRationale\n\nUnde%ned behaviour occurs if the result obtained from one of the above expressions is not a pointer \nto an element of the array pointed to by pointer_expression, or a pointer to one beyond the end \nof that array. \n\nNote: dereferencing an invalid pointer, including a pointer to one past the end of an array, results in \nunde%ned behaviour \u2014 this is targeted by"
  },
  {
    "rule": "Rule 4.1.3.\n\nExample\n\nint32_t * f1( int32_t * const a1, int32_t a2[ 10 ], int32_t ( &a3 )[ 10 ] )\n{\n  a1[ 3 ] = 0;                  // Compliant only if the array pointed\n                                // to by 'a1' has at least 4 elements\n\n  *( a2 + 9 ) = 0;              // Compliant only if the array pointed\n                                // to by 'a2' has at least 10 elements\n\n  return a3 + 9;                // Compliant\n}\n\n104\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nvoid f2()\n{\n  int32_t a1[ 10 ] = { };\n\n  int32_t * p1 = &a1[  0 ];     // Compliant\n  int32_t * p2 = a1 + 10;       // Compliant - points to one beyond and\n  int32_t    i = *p2;           //             dereferencing is undefined behaviour\n  int32_t * p3 = a1 + 11;       // Non-compliant - points to two beyond, resulting\n                                //                 in undefined behaviour\n\n  p1++;                         // Compliant\n  a1[ -1 ] = 0;                 // Non-compliant - exceeding array bounds results\n                                //                 in undefined behaviour\n  i = *( &i + 0 );              // Compliant     - 'i' is treated as an array\n                                //                 of size 1\n\n  // This declaration has 6 arrays:\n  //   1 array of 5 elements of type array of int32_t\n  //   5 arrays of 2 elements of type int32_t\n  int32_t a2[ 5 ][ 2 ] = { };\n\n  a2[ 3 ][ 1 ] = 0;             // Compliant\n  i = *( *( a2 + 3 ) + 1 );     // Compliant\n  i = a2[ 2 ][ 3 ];             // Non-compliant - exceeding array bounds results\n                                //                 in undefined behaviour\n\n  int32_t * p4 = a2[ 1 ];       // Compliant\n\n  i = p4[ 1 ];                  // Compliant - p4 addresses an array of size 2\n}\n\nThe following example illustrates pointer arithmetic applied to members of a structure. Because each \nmember is an object in its own right, this rule prevents the use of pointer arithmetic to move from one  \nmember to the next. \n\nstruct\n{\n  uint16_t x;\n  uint16_t y;\n  uint16_t a[ 10 ];\n} s;\n\nvoid f3()\n{\n  uint16_t * p { &s.x };\n\n  ++p;                          // Compliant - p points one past the end of s.x,\n                                //   but this cannot be assumed to point to s.y\n  *p = 0;                       //   and dereferencing is undefined behaviour\n\n  ++p;                          // Non-compliant - more than one past the end\n\n  p = &s.a[ 0 ];                // Compliant     - p points into s.a\n  p = p + 8;                    // Compliant     - p still points into s.a\n  p = p + 3;                    // Non-compliant - more than one past the end\n}\n\nThe following example shows that the implicit pointer arithmetic within library functions can lead to \naccesses beyond the end of an array: \n\nuint8_t buf1[ 5 ] = { 1, 2, 3, 4, 5 };\nuint8_t buf2[ 7 ] = { 1, 2, 3, 4, 5, 6, 7 };\n\nvoid f4()\n{ \n  if ( std::memcmp( buf1, buf2, 5 ) == 0 ) {}    // Compliant\n  if ( std::memcmp( buf1, buf2, 7 ) == 0 ) {}    // Non-compliant\n\n105\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n106\n\n  auto p1 = std::next( buf1, 3 );                // Compliant\n  auto p2 = std::next( buf1, 7 );                // Non-compliant\n}\n\nSee also"
  },
  {
    "rule": "Rule 4.1.3"
  },
  {
    "rule": "Rule 8.7.2\n\nSubtraction between pointers shall only be applied to pointers that \naddress elements of the same array\n\n[expr.add] Unde9ned 5\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nThis rule applies to expressions of the form:\n\npointer_expression_1 - pointer_expression_2\n\nNote: a pointer to an object that is not an array is treated as if it were a pointer to the 9rst element of  \nan array with a single element.\n\nRationale\n\nUndefined behaviour occurs if pointer_expression_1 and pointer_expression_2 do not point \nto elements of the same array or the element one beyond the end of that array.\n\nExample\n\nvoid f1( int32_t * ptr )\n{\n  int32_t   a1[ 10 ];\n  int32_t   a2[ 10 ];\n  int32_t * p1 = &a1[ 1 ];\n  int32_t * p2 = &a2[ 10 ];\n\n  ptrdiff_t diff1 = p1 - a1;     // Compliant\n  ptrdiff_t diff2 = p2 - a2;     // Compliant\n  ptrdiff_t diff3 = p1 - p2;     // Non-compliant\n  ptrdiff_t diff4 = ptr - p1;    // Non-compliant\n}\n\nSee also"
  },
  {
    "rule": "Rule 4.1.3\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f4.8.9\n\nRelational operators \n\n [expr.rel]\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS"
  },
  {
    "rule": "Rule 8.9.1\n\nThe built-in relational operators >, >=, < and <= shall not be applied \nto objects of pointer type, except where they point to elements of \nthe same array\n\n[expr.rel] Unspeci9ed 4\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nUses of std::less, std::less_equal, std::greater, std::greater_equal are permitted as \nspecializations for any pointer type yield a strict total order.\n\nNotes:\n\n1. A pointer to one beyond the last element of an array is considered to point to an element of that \n\narray.\n\n2. A pointer to an object that is not an array is treated as if it were a pointer to the first element of \n\nan array with a single element.\n\nRationale\n\nAttempting to make comparisons between unrelated pointers may result in surprising or unspeci%ed  \nbehaviour.\n\nExample\n\nvoid f1()\n{\n  int32_t   a1[ 10 ];\n  int32_t   a2[ 10 ];\n  int32_t * p1 = a1;\n\n  if ( p1 < a1 ) {}                    // Compliant\n  if ( p1 < std::end( a1 ) ) {}        // Compliant - right operand is one beyond\n  if ( p1 < a2 ) {}                    // Non-compliant\n  if ( std::less<>{}( p1, a2 ) ) { }   // Compliant\n}\n\nstruct S\n{\n  int32_t m1;\n  int32_t m2;\n};\n\nvoid f2()\n{\n  S x { };\n\n  if ( &x.m1 <= &x.m2 ) {}    // Non-compliant - m1 and m2 are not array elements\n}\n\nSee also"
  },
  {
    "rule": "Rule 4.1.3\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n107\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n108\n\n4.8.14 Logical AND operator \n\n [expr.log.and]"
  },
  {
    "rule": "Rule 8.14.1\n\nThe right-hand operand of a logical && or || operator should not \ncontain persistent side eAects\n\nCategory Advisory\n\nAnalysis Undecidable, System\n\nRationale\n\nThe evaluation of the right-hand operand of the && and || operators is conditional on the value of the \nleft-hand operand. If the right-hand operand contains side eAects then those side eAects may or may \nnot occur, which may be contrary to developer expectations.\n\nIf evaluation of the right-hand operand would produce side effects which are not persistent at the point \nin the program where the expression occurs then it does not matter whether the right-hand operand \nis evaluated or not.\n\nThe term persistent side eAect is de9ned in Appendix C.\n\nExample\n\nuint16_t f( uint16_t y )              // The side effects within f are not\n{                                     // persistent, as seen by the caller\n  uint16_t temp = y;\n\n  temp = y + 0x8080U;\n\n  return temp;\n}\n\nuint16_t h( uint16_t y )\n{\n  static uint16_t temp = 0;\n\n  temp = y + temp;                    // This side effect is persistent\n\n  return temp;\n}\n\nvoid g( bool ishigh )\n{\n  if ( ishigh && ( a == f( x ) ) )    // Compliant - f() has no persistent\n  {                                   //             side effects\n  }\n\n  if ( ishigh && ( a == h( x ) ) )    // Non-compliant - h() has a persistent\n  {                                   //                 side effect\n  }\n}\n\nvolatile uint16_t v;\n         uint16_t x;\n\nif ( ( x == 0u ) || ( v == 1u ) )     // Non-compliant - access to volatile v\n{                                     //                 is persistent\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n( fp != nullptr ) && ( *fp )( 0 );    // Non-compliant if fp points to a function\n                                      // with persistent side effects\nif ( fp != nullptr )\n{\n  ( *fp )( 0 );                       // Compliant version of the above\n}\n\n4.8.18 Assignment and compound assignment \n\n [expr.ass]"
  },
  {
    "rule": "Rule 8.18.1 An object or subobject must not be copied to an overlapping object\n\n[expr.ass] Unde9ned 8\n\nCategory Mandatory\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nThis rule applies when:\n\n\u25cf A member of a union is copied to a diCerent member of the same union; or\n\n\u25cf A slice of an array is copied to an overlapping slice of the same array using memcpy.\n\nRationale\n\nCopying between members of the same union object may result in unde%ned behaviour.\n\nIf part of an array is to be copied to another part of the same array (e.g. when moving elements 1 to  \n10 to elements 0 to 9), then std::memcpy may overwrite an element before it has been copied, as \nthere is no guarantee of the order in which they are copied. By contrast, std::memmove is guaranteed \nto handle the overlap appropriately.\n\nExample\n\nThe use of unions in the following example is a violation of"
  },
  {
    "rule": "Rule 12.3.1. \n\nvoid f1( void )\n{\n  union\n  {\n    int16_t i;\n    int32_t j;\n  } a = { 0 };\n\n  a.i = a.i;         // Rule does not apply - same member\n  a.j = a.i;         // Non-compliant           \n}\n\nvoid f2( std::array< int16_t, 20 > & a )\n{\n  memcpy ( &a[ 0 ], &a[ 1 ], 10u * sizeof ( a[ 0 ] ) );  // Non-compliant \n  memmove( &a[ 0 ], &a[ 1 ], 10u * sizeof ( a[ 0 ] ) );  // Rule does not apply\n  memcpy ( &a[ 1 ], &a[ 0 ], 10u * sizeof ( a[ 0 ] ) );  // Non-compliant \n  memmove( &a[ 1 ], &a[ 0 ], 10u * sizeof ( a[ 0 ] ) );  // Rule does not apply\n  memcpy ( &a[ 0 ], &a[ 5 ],  5u * sizeof ( a[ 0 ] ) );  // Compliant - no overlap\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n109\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 8.18.2\n\nThe result of an assignment operator should not be used\n\n[expr.ass]\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nn\ne\ns\n\nThis rule applies to simple and compound assignments, built-in or overloaded, even if they occur in \nan infeasible path. It does not apply to assignments within an unevaluated operand.\n\nRationale\n\nThe use of assignment operators, simple or compound, in combination with other arithmetic operators \nis not recommended because:\n\n\u25cf It can signi9cantly impair the readability of the code;\n\n\u25cf It introduces additional  side effects  into a statement, making it more difficult to avoid the \n\nunde%ned behaviour covered by"
  },
  {
    "rule": "Rule 4.6.1.\n\nExample\n\nx = y;                     // Compliant\na[ x ] = a[ x = y ];       // Non-compliant - value of x = y is used\n\nif ( bool_a = bool_b )     // Non-compliant - value of bool_a = bool_b is used\n{                          // (bool_a == bool_b was probably intended)\n}\n\nif ( uint8_t i = y )       // Rule does not apply - not an assignment operator\n{\n}\n\nif ( ( 0u == 0u ) || ( bool_a = bool_b ) )  // Non-compliant - even though\n{                                           // bool_a = bool_b is not evaluated\n}\n\nif ( ( x = f() ) != 0 )    // Non-compliant - value of x = f() is used\n{\n}\n\na[ b += c ] = a[ b ];      // Non-compliant - value of b += c is used\n\na = b = c = 0;             // Non-compliant - values of c = 0, b = c = 0 are used\n\nSee also"
  },
  {
    "rule": "Rule 4.6.1\n\n110\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f4.8.19 Comma operator \n\n [expr.comma]\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS"
  },
  {
    "rule": "Rule 8.19.1\n\nThe comma operator should not be used\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to the use of the comma operator, but not when a comma is used as the fold operator \nwithin a fold expression.\n\nRationale\n\nUse of the comma operator is generally detrimental to the readability of code, and the same eCect \ncan usually be achieved by other means. \n\nExample\n\nf( ( 1, 2 ), 3 );                        // Non-compliant - how many parameters?\n\ntemplate< typename ... Ts >\nvoid print_all_of( const Ts &... ts )\n{\n  ( print( ts ), ... );                  // Rule does not apply\n}\n\nThe following example is non-compliant with other rules: \n\nfor ( i = 0, p = &a[ 0 ]; i < N; ++i, ++p )    // Non-compliant\n{\n}\n\n4.8.20 Constant expressions \n\n [expr.const]"
  },
  {
    "rule": "Rule 8.20.1 An unsigned arithmetic operation with constant operands should \n\nnot wrap\n\n[expr.const]\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to any built-in arithmetic operation resulting in an unsigned integral type, where all \noperands are constant expressions.\n\nThis rule does not apply to an expression that is not evaluated, for example, because it appears in the \nright operand of a logical && operator whose left operand is false at compile time.\n\nRationale\n\nUnsigned integer expressions do not overflow, but instead wrap around in a modular way. Any \nconstant unsigned integer expression that wraps will not be diagnosed by the compiler. There may be  \ngood reasons to rely on the modular arithmetic provided by unsigned integer types, but the reasons \n\n111\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nare less obvious if wrapping occurs when an operator has constant operands \u2014 this may indicate a \nprogramming error.\n\nExample\n\nAny unsigned wrapping that occurs during the evaluation of a case expression is unlikely to be \nintentional. In the following example, any value of BASE greater than or equal to 65024 would result \nin wrapping on a machine with a 16-bit int type. \n\nn\ne\ns\n\n#define BASE 65024u\n\nswitch ( x )\n{\n  case BASE + 0u:   f(); break;\n  case BASE + 1u:   g(); break;\n  case BASE + 512u: h(); break;    // Non-compliant - wraps to 0\n}\n\nIn the following example, the expression DELAY + WIDTH has the value 70,000, but this will wrap to \n4,464 on a machine with a 16-bit int type. \n\nconstexpr auto DELAY { 10000u };\nconstexpr auto WIDTH { 60000u };\n\nvoid fixed_pulse()\n{\n  auto off_time = DELAY + WIDTH;   // Non-compliant - wraps to 4464\n}\n\nIn the following example, the sub-expression ( 0u - 1u ) results in unsigned integer wrapping in the \ninitialization of  x. However, in the initialization of  y, the sub-expression is never evaluated and the \nexpression is therefore compliant. \n\nvoid g( bool b )\n{\n  uint16_t x = b ? 0u : ( 0u - 1u );               // Non-compliant\n  uint16_t y = ( 0u == 0u ) ? 0u : ( 0u - 1u );    // Compliant\n}\n\nWrapping within preprocessing expressions is also non-compliant: \n\n#if 1u + ( 0u - 10u )     // Non-compliant as ( 0u - 10u ) wraps\n#if 11u + ( 0u - 10u )    // Non-compliant as both operations wrap\n#if 11u + 0u - 10u        // Compliant\n\nThe rule does not apply to the following example as there are no built-in arithmetic operations with \nconstant operands. \n\nconstexpr auto add( const uint16_t a, const uint16_t b )\n{\n  return a + b;    // References to a, b are not constant expressions.\n}\n\nconstexpr auto x = add( 10000u, 60000u );    // No built-in arithmetic operation\n\n112\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f4.9\n\nStatements\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n4.9.2\n\nExpression statement \n\n [stmt.expr]"
  },
  {
    "rule": "Rule 9.2.1\n\nAn explicit type conversion shall not be an expression statement\n\n[expr.type.conv]\n[stmt.expr]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule only applies to explicit type conversions that use functional notation.\n\nRationale\n\nAn explicit type conversion that uses functional notation is composed of a type name followed by \nparentheses or braces. It creates a temporary object that is discarded at the end of the statement.  \nThis notation can appear to be very similar to the declaration of a variable, except that it does not \ncontain a variable name. \n\nIf the intent was to declare a variable for scope-based resource management (e.g. std::lock_guard), \nthe destruction side effects which were expected to occur at the end of the containing block will instead \noccur immediately (e.g. the lock is prematurely released).\n\nExample\n\nIn the following example, the redundant parentheses surrounding b_mutex violate"
  },
  {
    "rule": "Rule 6.0.1.\n\nvoid f1()\n{\n  std::unique_lock< std::mutex >   a_mutex;    // Declaration, rule does not apply\n  std::unique_lock< std::mutex > ( b_mutex );  // Declaration, rule does not apply\n}\n\nvoid f2()\n{\n  std::scoped_lock { a_mutex };                // Non-compliant\n                                               //   - locks and unlocks here\n  // Unprotected\n}\n\nvoid f3()\n{\n  std::scoped_lock ( a_mutex, other_mutex );   // Non-compliant\n                                               //   - locks and unlocks here\n  // Unprotected\n}\n\nvoid f4()\n{\n  f( std::unique_lock { a_mutex } );           // Compliant - type conversion is\n                                               //   not an expression statement\n}\n\nSee also"
  },
  {
    "rule": "Rule 6.0.1\n\n113\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n114\n\n4.9.3\n\nCompound statement \n\n [stmt.block]"
  },
  {
    "rule": "Rule 9.3.1\n\nThe body of an iteration-statement or a selection-statement shall be a \ncompound-statement\n\n[Koenig] 24\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe body of an  iteration-statement  (while,  do ... while,  for) or a  selection-statement  (if,  else, \nswitch) shall be a compound-statement.\n\nRationale\n\nIt is possible for a developer to mistakenly believe that a sequence of statements forms the body of \nan iteration-statement or selection-statement by virtue of their indentation. The accidental inclusion of \na semi-colon after the controlling expression is a particular danger, leading to a null control statement. \nUsing a compound-statement clearly de9nes which statements actually form the body.\n\nAdditionally, it is possible that indentation may lead a developer to associate an else statement with \nthe wrong if.\n\nException\n\nAn  if  statement that is the statement to an  else  need not be contained within a  compound-\nstatement.\n\nExample\n\nThe layout for the  compound-statement  and its enclosing braces are style issues which are not \naddressed by this document; the style used in the following examples is not mandatory.\n\nMaintenance to the following \n\nwhile ( data_available )\n  process_data();               // Non-compliant\n\ncould accidentally give \n\nwhile ( data_available )\n  process_data();               // Non-compliant\n  service_watchdog();\n\nwhere  service_watchdog  should have been added to the loop body. The use of a  compound-\nstatement signi9cantly reduces the chance of this happening.\n\nThe next example appears to show that action_2 is the else statement to the 9rst if. \n\nif ( flag_1 )\n  if ( flag_2 )                 // Non-compliant\n    action_1();                 // Non-compliant\nelse\n  action_2();                   // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fwhen the actual behaviour is \n\nif ( flag_1 )\n{\n  if ( flag_2 )\n  {\n    action_1();\n  }\n  else\n  {\n    action_2();\n  }\n}\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nThe use of compound-statements ensures that if and else associations are clearly de9ned. \n\nThe exception allows the use of else if, as shown below \n\nif ( flag_1 )\n{\n  action_1();\n}\nelse if ( flag_2 )              // Compliant by exception\n{\n  action_2();\n}\nelse { }                        // Compliant - else with empty block\n\nThe following example shows how a spurious semi-colon could lead to an error \n\nwhile ( flag );                 // Non-compliant\n{\n  flag = fn();\n}\n\nwhile ( !data_available ) { }   // Compliant - loop with empty body\n\n4.9.4\n\nSelection statements \n\n [stmt.select]"
  },
  {
    "rule": "Rule 9.4.1\n\nAll if ... else if constructs shall be terminated with an else \nstatement\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA 9nal else shall always be provided whenever an if statement is followed by a sequence of one or \nmore else if constructs.\n\nNote: a 9nal else statement is not required for a simple if statement.\n\nRationale\n\nTerminating   a   sequence   of  if ... else if  constructs   with   an  else  statement   is   defensive \nprogramming, complementing the requirement for a  default  clause in a  switch  statement (see"
  },
  {
    "rule": "Rule 9.4.2).\n\nThe addition of an else statement, even when empty, indicates that consideration has been given \nregarding the behaviour when all other conditions evaluate to false.\n\n115\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n116\n\nExample\n\nvoid f1( bool flag_1, bool flag_2 ) \n{\n  if ( flag_1 )\n  {\n    action_1();\n  }\n  else if ( flag_2 )\n  {\n    action_2();\n  }                     // Non-compliant\n}\n\nvoid f2(bool flag_1, bool flag_2) \n{\n  if ( flag_1 )\n  {\n    action_1();\n  }\n  else if ( flag_2 )\n  {\n    action_2();\n  }\n  else                  // Compliant\n  {\n  }\n}\n\nvoid f3( bool flag ) \n{\n  if ( flag )\n  {\n    action_1();\n  }                     // Simple 'if' - rule does not apply\n}\n\nSee also"
  },
  {
    "rule": "Rule 9.4.2"
  },
  {
    "rule": "Rule 9.4.2\n\nThe structure of a switch statement shall be appropriate\n\n[stmt.switch]\n[dcl.attr.fallthrough]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe substatement of a switch statement is called the switch body. It shall be a compound statement.\n\nA  labeled   statement,   along   with   the   complete   chain   of   its   substatements   that   are   also  labeled \nstatements, is called a label group. A label group that is directly enclosed by a switch body is called a \nswitch label group.\n\nThe statements directly enclosed by a switch body are partitioned into switch branches, with each switch \nlabel group starting a new branch.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fA switch statement is structured appropriately when it conforms to the following restrictions:\n\ns\ne\nn\n\n1. The condition shall only be preceded by an optional simple-declaration;\n\n2. case or default labeled statements shall only appear as part of a switch label group;\n\n3. Switch label groups shall only contain case or default labeled statements;\n\n4. The 9rst statement in a switch body shall be a switch label group;\n\n5. Every switch branch shall be unconditionally terminated by either:\n\na. A break statement; or\n\nb. A continue statement; or\n\nc. A return statement; or\n\nd. A goto statement; or\n\ne. A throw expression; or\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nf. A call to a [[noreturn]] function; or\n\ng. A [[fallthrough]] attribute applied to a null statement.\n\n6. Every switch statement shall have at least two switch branches;\n\n7. Every switch statement shall have a default label, appearing as either the 9rst label of the \n\n9rst switch label group or as the last label of the last switch label group.\n\nRationale\n\nThe syntax for the switch statement can be used to create complex, unstructured code. This rule \nplaces restrictions on the use of the switch statement in order to impose a simple and consistent \nstructure: \n\n1. A simple-declaration is permitted before the condition as it allows the declaration of a variable \nwith restricted scope within a switch statement. An expression-statement is not permitted as \nthe init-statement, as it introduces complexity without any extra bene9t.\n\n2. The C++ Standard permits a case label or default label to be placed before any statement \ncontained within the body of a switch statement, potentially leading to unstructured code. To \nprevent this, a case label or default label is only permitted to appear at the outermost level \nof the compound statement forming the body of a switch statement.\n\n3.\n\nIncluding labels other than case or default in a switch label group potentially allows unstructured \ncontrol ^ow to be introduced.\n\n4. A statement placed before a  switch label group  would either be an uninitialized variable or \n\nunreachable code.\n\n5.\n\nIf a developer fails to terminate a switch branch, then control flow \u201cfalls\u201d into the following switch \nbranch or, if there is no such branch, oC the end and into the statement following the  switch \nstatement. The requirement for unconditional termination ensures that unintentional fall-\nthroughs can be detected, with the [[fallthrough]] attribute being used to explicitly indicate \nwhen fall-through is intentional. Note: fall-through that occurs between two consecutive case \nor default labels having no intervening statements is not ambiguous, and is permitted by this \nrule.\n\n6. A switch statement with a single switch branch is not permitted as it may be indicative of a \n\nprogramming error.\n\n7. The requirement for a default label is defensive programming, complementing the requirement \nfor if ... else if constructs to be terminated with an else (see"
  },
  {
    "rule": "Rule 9.4.1). The addition of \na  default, even when empty, indicates that consideration has been given regarding the  \nbehaviour when all other cases are not selected. Placing the default as the 9rst or last label \nmakes it easier to locate during code review.\n\n117\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n118\n\nNote:  even when the  condition  of a  switch  has  enum  type, listing all enumerators values in  case \nlabels does not make the use of default redundant as the value could still lie outside of the set of \nenumerators.\n\nException\n\nIf the condition of a switch statement is an unscoped enumeration type that does not have a fixed \nunderlying type, and all the enumerators are listed in case labels, then a default label is not required. \nNote: compliance with"
  },
  {
    "rule": "Rule 10.2.3 ensures that an object of such a type cannot be assigned values \noutside of its set of enumerators.\n\nExample\n\nThe following switch statement has four switch branches: \n\nswitch ( int8_t x = f(); x ) // Compliant - declaration of x is simple\n{\n  case 1:\n  {\n    break;                   // Compliant - branch unconditionally terminated\n  }\n\n  case 2:\n  case 3:\n    throw;                   // Compliant - branch unconditionally terminated\n\n  case 4:\n    a++;\n    [[fallthrough]];         // Compliant - branch has explicit fall-through\n  default:                   // Compliant - default is last label\n    b++;\n    return;                  // Compliant - branches unconditionally terminated\n}\n\nThe following switch statement has four switch branches: \n\nswitch ( x = f(); x )        // Non-compliant - x = f() is not a simple-declaration\n{\n  int32_t i;                 // Non-compliant - not a switch label group\n\n  case 5:\n    if ( ... )\n    {\n      break;\n    }\n    else\n    {\n      break;\n    }\n                             // Non-compliant - termination is not unconditional\n\n  case 6:\n    a = b;                   // Non-compliant - non-empty, implicit fall-through\n  case 7:\n    {\n      case 8:                // Non-compliant - case not in a switch label group\n        DoIt();\n    }\n    break;\n}                            // Non-compliant - default is required\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nswitch ( x )                 // Non-compliant - only one switch branch\n{\n  default:\n    ;                        // Non-compliant - default must also be terminated\n}\n\nenum Colours { RED, GREEN, BLUE } colour;\n\nswitch ( colour )\n{\n  case RED:\n    break;\n  case GREEN:\n    break;\n}                            // Non-compliant - default is required\n\nswitch ( colour )\n{\n  case RED:\n  case GREEN:\n    break;\n  case BLUE:\n    break;\n}                            // Compliant by exception - all enumerators listed\n\nswitch ( colour )            // Non-compliant - only one switch branch\n{\n  case RED:\n  default:                   // Non-compliant - default must be first or last label\n  case BLUE:\n    break;\n}\n\nSee also"
  },
  {
    "rule": "Rule 9.4.1,"
  },
  {
    "rule": "Rule 9.6.2,"
  },
  {
    "rule": "Rule 9.6.3,"
  },
  {
    "rule": "Rule 10.2.3\n\n4.9.5\n\nIteration statements \n\n [stmt.iter]"
  },
  {
    "rule": "Rule 9.5.1\n\nLegacy for statements should be simple\n\n[stmt.for]\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA legacy for statement is simple when:\n\n1. The init-statement only declares and initializes a loop-counter of integer type; and\n\n2. The condition only compares the loop-counter to a loop-bound using a relational operator; and\n\n3. The loop-counter is modi9ed, but only by incrementing or decrementing by a loop-step within \n\nthe expression of the for statement; and\n\n4. The loop-bound and loop-counter have the same type, or the loop-bound is a constant expression \nand the type of the loop-counter has a range large enough to represent the value of the loop-\nbound; and\n\n119\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\n5. The loop-bound and loop-step are constant-expressions or are variables that are not modi9ed \n\nwithin the for statement; and\n\n6. The loop-counter, loop-bound and loop-step are not bound to non-const references and do not \n\nhave any of their addresses assigned to pointers to non-const.\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nNote: the range-for statement is not a legacy for statement. \n\nRationale\n\nn\ne\ns\n\nThe number of iterations of a legacy for statement is determined by a user-provided loop condition \nand code review, which may be non-trivial, is required to ensure that the loop behaves as expected.  \nThis review is not required for iterator-based algorithms or range-for statements, as the number of \niterations is not determined by a user-provided loop condition. It is therefore recommended that \nlegacy for statements should not be used, unless they are simple.\n\nIt is generally unnecessary to use the legacy for statements as C++ Standard Library algorithms are \nprovided for most iteration use-cases. Iterating over the contents of a container can be achieved by \nthe use of a range-for statement when the existing algorithms are not suitable. Using or implementing a \nrange adapter or iterator adapters allows  range-for  statements or iterator-based algorithms to be \nused to loop over other data sources and sinks.\n\nWhen a legacy for statement cannot be replaced by an existing C++ Standard Library algorithm, it can \nbe abstracted and con9ned within a (potentially generic) dedicated function to make code review and \njusti9cation easier.\n\nNote: care must be taken to ensure that a simple legacy for statement will make progress and terminate.\n\nExample\n\nfor ( int32_t i = 0; i < 10; ++i )           // Compliant\n{\n  cout << i << \" \";\n}\n\nbool foo( int32_t & );\n\nfor ( int32_t i = 0; i < 10; ++i )           // Non-compliant\n{\n  foo( i );                                  // i passed as non const & parameter\n}\n\nfor ( uint32_t i = 0u; i < u64a; ++i )       // Non-compliant - loop-counter and\n{                                            //   loop-bound have different types\n  // ... \n}\n\nint32_t sum { };\nstd::array< int32_t, 10 > arr { };\n\nfor ( auto i = 0u; i < arr.size(); ++i )     // Compliant- arr.size() is constant \n{\n  sum += arr[ i ];\n}\n\nThe following achieve the same without the use of legacy for statements: \n\nfor ( auto const e : arr )                   // Rule does not apply \n{\n  sum += e;\n}\n\n120\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nsum = reduce( begin( arr ),\n              end( arr ),\n              int32_t {} );                  // Rule does not apply\n\nSee also"
  },
  {
    "rule": "Rule 0.0.2"
  },
  {
    "rule": "Rule 9.5.2\n\nA for-range-initializer shall contain at most one function call\n\n[stmt.ranged] \n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe for-range-initializer occurs within the range-based for statement: \n\nfor ( for-range-declaration : for-range-initializer ) statement\n\nFor the purposes of this rule, the following are also considered to be function calls:\n\n\u25cf Any expression creating an object of class type; and\n\n\u25cf Any use of an overloaded operator.\n\nRationale\n\nCompliance with this rule will avoid the undefined behaviour related to object lifetime violations when \nthe for-range-initializer of a range-based for statement creates a temporary object.\n\nThe range-based for statement is de9ned within the C++ Standard as being equivalent to: \n\n{\n  auto && __range = for-range-initializer; \n  auto    __begin = begin-expr;               // Uses __range\n  auto      __end = end-expr;\n  for ( ; __begin != __end; ++__begin)\n  {\n    for-range-declaration = *__begin;\n    statement\n  }\n}\n\nEven though lifetime extension through __range will extend the lifetime of the outermost temporary \nobject of the for-range-initializer, it will not extend the lifetime of an intermediate temporary. The rules \nfor temporary lifetime extension are subtle and it is easy to accidentally trigger unde%ned behaviour \nby accessing a temporary object after its lifetime has ended (see"
  },
  {
    "rule": "Rule 6.8.1). \n\nCreating a temporary object containing a range requires a function call, and only a second call can  \nresult in creating a reference to or into it. Therefore, allowing no more than one function call eliminates \nthe risk in a way that is decidable at the expense of prohibiting some non-problematic cases. De9ning a \nvariable holding the value of the desired for-range-initializer and using that variable will always be \ncompliant with this rule.\n\nNote: these lifetime issues with range-for statements have been resolved from C++23.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n121\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nExample\n\nextern std::vector < std::string > make();\n\nvoid f()\n{\n  for ( char c: make().at( 0 ) )     // Non-compliant - two function calls\n  {\n  }\n}\n\nvoid g()\n{\n  auto range = make().at( 0 );       // Note that auto && would dangle\n\n  for ( char c: range )              // Compliant - no call when using named range\n  {\n  }\n}\n\nvoid h()\n{\n  for ( auto s: make() )             // Compliant - single function call\n  {\n  }\n}\n\nThe following shows an example that has no unde%ned behaviour, but which includes non-compliant \ncases as a consequence of preferring a decidable check: \n\nstd::vector< std::string > make( std::string_view );\n\nvoid bar( std::string s )\n{\n  for ( auto e : make( s ) )         // Non-compliant - call to 'make' and an\n  {                                  // implicit conversion to std::string_view\n  }\n\n  auto r = make( s );\n\n  for ( auto e : r )                 // Compliant version of the above\n  {\n  }\n\nSee also"
  },
  {
    "rule": "Rule 6.8.1\n\n4.9.6\n\nJump statements \n\n [stmt.jump]"
  },
  {
    "rule": "Rule 9.6.1\n\nThe goto statement should not be used\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThe use of goto is usually regarded as bad programming practice as it can lead to code that is difficult  \nto understand and analyse. Restructuring code to avoid its use generally leads to code that has a lower \nlevel of complexity.\n\n122\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nIf this advice is not followed,"
  },
  {
    "rule": "Rule 9.6.2 and"
  },
  {
    "rule": "Rule 9.6.3 ensure that the use of goto does not result in \ncode that is considered to be unstructured. \n\nSee also"
  },
  {
    "rule": "Rule 9.6.2,"
  },
  {
    "rule": "Rule 9.6.3"
  },
  {
    "rule": "Rule 9.6.2\n\nA goto statement shall reference a label in a surrounding block\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA goto statement shall be enclosed in a statement that directly encloses its referenced label.\n\nRationale\n\nThe unconstrained use of goto can lead to programs that are extremely di[cult to comprehend and \nanalyse. However, ^ags may need to be introduced to give the required control ^ow when it is not \nused, with the possibility that the ^ags may themselves make the code less transparent than if goto \nwere used. The restricted use of goto is therefore allowed where that use will not lead to semantics \ncontrary to developer expectations.\n\nThis rule prohibits jumping in to nested blocks, as this results in complex control ^ow.\n\nExample\n\nvoid f1()\n{\n  int32_t j = 0;\n\n  goto L1;                                // Non-compliant\n\n  for ( j = 0; j < 10 ; ++j )\n  {\n  L1:\n    j;\n  }\n}\n\nvoid f2()\n{\n  for ( int32_t j = 0; j < 10 ; ++j )\n  {\n    for ( int32_t i = 0; i < 10; ++i )\n    {\n      goto L2;                            // Compliant\n    }\n  }\n\nL2:\n  f1();\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n123\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nswitch ( i )\n{\n  case 0:\n    if ( x < y )\n      goto L3;                            // Non-compliant\n    break;\n\n  case 1:\n  L3:\n    break;\n}\n\nSee also"
  },
  {
    "rule": "Rule 9.6.1,"
  },
  {
    "rule": "Rule 9.6.3"
  },
  {
    "rule": "Rule 9.6.3\n\nThe goto statement shall jump to a label declared later in the \nfunction body\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThe unconstrained use of goto can lead to programs that are extremely di[cult to comprehend and \nanalyse. However, ^ags may need to be introduced to give the required control ^ow when it is not \nused, with the possibility that the ^ags may themselves make the code less transparent than if goto \nwere used. The restricted use of goto is therefore allowed where that use will not lead to semantics \ncontrary to developer expectations.\n\nThis rule prohibits the use of back jumps as they can be used to introduce iteration without using the  \nwell-de9ned iteration statements supplied by the language.\n\nNote:  the C++ Standard places restrictions on the uses of forward jumps. For example, it is not  \npermitted to jump from a point where a local variable with initialization is not in scope to a point \nwhere it is in scope.\n\nExample\n\nvoid f()\n{\n  int32_t x = 0;\n\nL1:\n  if ( x == 10 )\n  {\n    goto L2;       // Compliant\n  }\n  else\n  {\n    ++x;\n    goto L1;       // Non-compliant\n  }\n\nL2:\n  return;\n}\n\nSee also\n\n124"
  },
  {
    "rule": "Rule 9.6.1,"
  },
  {
    "rule": "Rule 9.6.2\n\nLicensed to: gunjanjain\n22 Apr 2025"
  },
  {
    "rule": "Rule 9.6.4\n\nA function declared with the [[noreturn]] attribute shall not \nreturn\n\n[dcl.attr.noreturn]\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nLeaving a function as the result of an exception is not a return. \n\nA function\u2019s compliance with this rule is determined independently of the context in which the function \nis called. For example, a Boolean parameter is treated as if it may have a value of true or false, even \nif all the calls expressed in the current program use a value of true.\n\nRationale\n\nReturning from a function declared as [[noreturn]] results in unde%ned behaviour. \n\nNote: a function may be declared as [[noreturn]] when:\n\n1.\n\nIt only exits by throwing an exception; or\n\n2.\n\nIt loops endlessly; or\n\n3.\n\nIt causes program termination.\n\nExample\n\n[[noreturn]] void kill_the_process()   // Compliant\n{\n  std::abort();                        // Note - std::abort is also [[noreturn]]\n}\n\n[[noreturn]] void throw_some()         // Compliant - only exits with an exception\n{ \n  throw 42;\n}\n\n[[noreturn]] void g( bool b )          // Non-compliant - returns if 'b' is false\n{ \n  if ( b )\n  {\n    throw std::exception{};\n  }\n}\n\nSee also"
  },
  {
    "rule": "Rule 6.2.2\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n125\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:"
  },
  {
    "rule": "Rule 9.6.5\n\nA function with non-void return type shall return a value on all \npaths\n\n[stmt.return]\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nn\ne\ns\n\nAmpli2cation\n\nThe compound statement of a lambda expression with a non-void return type is also considered to \nbe a function covered by this rule.\n\nA return is not required after an explicit throw or after calling a function marked [[noreturn]].\n\nThis rule does not apply to main, as it implicitly returns 0 if an exit path does not explicitly return a \nvalue.\n\nNote: ^owing oC the end of a function body, except within main, is equivalent to a return with no \noperand.\n\nRationale\n\nThe operand to return gives the value that the function returns. The absence of a return with an \noperand in an execution path through a function with a non-void return type results in unde%ned  \nbehaviour.\n\nExample\n\nint32_t fn1()              // Non-compliant\n{\n  // No return\n}\n\nint32_t fn2( int32_t x )   // Compliant\n{\n  if ( x > 100 )\n  {\n    throw 42;              // Exiting via an exception\n  }\n  else\n  {\n    return x;              // Value returned on other path\n  }\n}\n\n126\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n4.10 Declarations\n\n4.10.0 MISRA \n\n [misra]"
  },
  {
    "rule": "Rule 10.0.1 A declaration should not declare more than one variable or member \n\nvariable\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nAn init-declarator-list or a member-declarator-list should consist of a single init-declarator or member-\ndeclarator respectively. \n\nStructured bindings are permitted by this rule.\n\nRationale\n\nWhere multiple declarators appear in the same  declaration, the type of an identi9er may not meet \ndeveloper expectations.\n\nExample\n\nint32_t   i1; int32_t j1;                 // Compliant\nint32_t   i2, * j2;                       // Non-compliant\nint32_t * i3,\n        & j3 = i2;                        // Non-compliant\n\nstruct point\n{\n  int32_t x, y;                           // Non-compliant\n};\n\nstd::map< char, char > map = f();\n\nauto [ loc, inserted ] = \n  map.insert( make_pair( 'A', 'a' ) );    // Compliant - structured binding\n\n4.10.1 Speci2ers \n\n [dcl.spec]"
  },
  {
    "rule": "Rule 10.1.1\n\nThe target type of a pointer or lvalue reference parameter should be \nconst-quali9ed appropriately\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe target type of a named pointer or reference parameter should be const-quali9ed, unless:\n\n1.\n\nIt is not an object type; or\n\n2. The parameter is assigned to a pointer or reference with a non-const target type; or\n\n3. The target object is modi9ed within the function.\n\n127\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n128\n\nFor the purposes of this rule, an object is also considered to be modi9ed if it is passed as a pointer to \nnon-const parameter or a non-const reference parameter, including use as the implicit this parameter \nof a non-const member function.\n\nThis rule does not apply to parameters:\n\n1. That are unnamed; or\n\n2. Of virtual functions; or\n\n3. Of function templates; or\n\n4. Of functions or lambdas declared within the scope of a template.\n\nNote: this rule also applies to pointer parameters declared using array syntax.\n\nRationale\n\nConsistent application of this guideline results in function signatures that more accurately re^ect the \nbehaviour of the functions within the project, making it less likely that a developer will falsely assume \nthat a call will not result in the modi9cation to an object.\n\nThe rule does not apply to virtual functions as diCerent overrides of the function may or may not \nmodify the target object, and all overrides will need to omit const-quali9cation if one or more of the \noverrides requires that the target type be non-const. Similarly, for templates, only some instantiations \nmay modify the target object.\n\nException\n\nThis rule does not apply to main whose signature, which does not use const-quali9cation, is de9ned \nwithin the C++ Standard.\n\nExample\n\nvoid f1(       int8_t *       p1,     // Compliant - *p1 modified\n         const int8_t *       p2,     // Compliant - *p2 not modified, but is const\n               int8_t *       p3,     // Non-compliant - *p3 not modified, no const\n               int8_t * const p4,     // Non-compliant - *p4 not modified, no const\n               int8_t         a[3] )  // Non-compliant - 'a' decays to int8_t *\n{\n   *p1 = *p2 + *p3 + *p4 + a[ 2 ];\n}\n\nauto & f2( int32_t &  i,              // Compliant\n           int32_t && j,              // Rule does not apply - rvalue reference\n           int32_t &    )             // Rule does not apply - unnamed parameter\n{\n  return i;                           // Assigning to non-const reference\n}\n\nauto f3( std::vector< int32_t > & x )  // Compliant - even though x.begin has an\n{                                      //             equivalent const overload\n  return x.begin();                    // Non-const member function\n}\n\nauto f4( std::vector< int32_t > & x )  // Non-compliant\n{\n  return x.cbegin();                   // Const member function\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\ftemplate< typename T >\nstruct A\n{\n  void foo ( T       & t,              // Rule does not apply - in template scope\n             int32_t & i )             // Rule does not apply - in template scope\n  {\n    t.f( i );                          // t and/or i may or may not be modified,\n  }                                    // depending on the signature of T::f\n};"
  },
  {
    "rule": "Rule 10.1.2\n\nThe volatile quali9er shall be used appropriately\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nIt is inappropriate to declare the following entities as volatile:\n\n\u25cf Local variables;\n\n\u25cf Function parameters;\n\n\u25cf Function return types;\n\n\u25cf Member functions;\n\n\u25cf Structured bindings.\n\nNote: a pointer or reference to a volatile entity is permitted.\n\nRationale\n\nWhile the C++ Standard permits volatile quali9cation to be applied to the entities listed above, the \nbehaviour is not well-de9ned or well-understood. In addition, volatile does not prevent data races, \nbut it is often incorrectly used when trying to ensure thread safety.\n\nNote: some of these uses of volatile have been deprecated in C++20 and their removal is planned \nfor a future version.\n\nExample\n\nvoid f1( volatile int32_t i )    // Non-compliant\n{\n  use< int32_t >( i );\n}\n\nvoid f2( volatile int32_t * p )  // Compliant - parameter is not volatile\n{\n  use< int32_t * >( p );\n}\n\nvoid f3( int32_t * volatile p )  // Non-compliant - parameter is volatile\n{\n  use< int32_t * >( p );\n}\n\nvoid f4( int32_t i )\n{\n  volatile int32_t j = i;        // Non-compliant\n\n  use< int32_t >( j );\n}\n\nvolatile int32_t f5();           // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n129\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n130\n\nvoid f6()\n{\n  int32_t g[ 2 ] = { 1, 2 };\n\n  auto volatile [ a, b ] = g;    // Non-compliant\n}\n\nstruct S\n{\n  volatile uint32_t reg;         // Compliant\n};\n\nvoid f7( S s );                  // Compliant - but unlikely to work as expected\nvoid f8( S & s );                // Compliant - preserves volatile behaviour of reg\n\n4.10.2 Enumeration declarations \n\n [dcl.enum]"
  },
  {
    "rule": "Rule 10.2.1 An enumeration shall be de9ned with an explicit underlying type\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe underlying type of an enum is explicit when its declaration has an enum-base.\n\nAdditionally, an explicit or implicit enumerator value shall not be the result of a narrowing conversion.\n\nNote: the C++ Standard states that any program that violates this additional requirement is ill-formed. \nHowever, it is known that some compilers do not issue a diagnostic.\n\nRationale\n\nWhen an enum is de9ned without an enum-base:\n\n\u25cf If the enum is unscoped, the underlying type is implementation-de%ned, with the only restriction \n\nbeing that the type must be able to represent the enumeration values; or\n\n\u25cf If the enum is scoped, it will implicitly have an underlying type of int.\n\nIn both cases, using an explicit underlying type ensures that this type is obvious to the user, reducing \nthe risk of an operation on enumerators leading to unwanted integer over^ows.\n\nException\n\nThe underlying type does not have to be speci9ed when:\n\n1. All of the enumerators in an enumeration use their default values \u2014 these enumerators are  \ntypically used as symbolic values, meaning the underlying type is not important ("
  },
  {
    "rule": "Rule 10.2.3 \nrestricts which operations are permitted for such types); or\n\n2. An enumeration is declared in an extern \"C\" block \u2014 i.e. the enumeration is intended to be \n\nused with C code.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nExample\n\nenum class Enum1 : int8_t    // Compliant\n{\n  E0 = 1,\n  E1 = 2,\n  E2 = 4\n};\n\nenum class Enum2             // Non-compliant - no explicit underlying type\n{\n  E0 = 0,\n  E1,\n  E2\n};\n\nThe following example will be reported as ill-formed by a conforming compiler. \n\nenum class Enum3 : uint8_t   // Non-compliant - cannot represent value for E2\n{                            // Implicit value is the result of wrapping\n  E0,\n  E1 = 255,\n  E2\n};\n\nenum class Enum4             // Compliant by exception #1\n{\n  E0,\n  E1,\n  E2\n};\n\nextern \"C\"\n{\n  enum Enum5                 // Compliant by exception #2\n  {\n    E7_0 = 0,\n    E7_1,\n    E7_2\n  };\n}\n\nSee also"
  },
  {
    "rule": "Rule 10.2.3"
  },
  {
    "rule": "Rule 10.2.2 Unscoped enumerations should not be declared\n\n[dcl.enum] / 2\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nIf an unscoped enumeration type is declared, its enumerators may hide an entity declared with the same \nname in an outer scope. This may lead to developer confusion.\n\nUsing a  scoped enumeration  restricts the scope of its enumerators\u2019 names, which can only be  \nreferenced as quali9ed names. In addition, its enumerators cannot be implicitly converted to numeric \nvalues.\n\n131\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nException\n\nThis rule does not apply to an unscoped enumeration type declared as a class member as any name \nhiding would be reported as a violation of"
  },
  {
    "rule": "Rule 6.4.1. This idiom was commonly used before scoped  \nenumeration types were introduced.\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nExample\n\nstatic int32_t E10 = 5;\nstatic int32_t E20 = 5;\n\nenum       E1 : int32_t { E10, E11, E12 };    // Non-compliant - ill-formed as\n                                              // E10 already declared\nenum class E2 : int32_t { E20, E21, E22 };    // Compliant\n\nvoid f1( int32_t number );\n\nvoid f2()\n{\n  f1( 0 );\n  f1( E11 );        // Implicit conversion from enum to int32_t type\n  f1( E2::E21 );    // Ill-formed - implicit conversion of scoped enumeration\n\n  f1( static_cast< int32_t >( E2::E21 ) );    // Explicit conversion needed\n}\n\nclass C1\n{\npublic:\n  enum Cstyle { E10, E20, E30 };              // Compliant by exception\n};\n\nSee also"
  },
  {
    "rule": "Rule 6.4.1"
  },
  {
    "rule": "Rule 10.2.3\n\nThe numeric value of an unscoped enumeration with no 9xed \nunderlying type shall not be used\n\n[dcl.enum] Implementation 7\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nIn an evaluated context, expressions of  unscoped enumeration  type without a 9xed  underlying type \nshall not be used:\n\n\u25cf As operands to an arithmetic, bitwise, shift, logical, or compound assignment operator;\n\n\u25cf As   operands   to  relational  and  equality  operators,   unless   both   operands   have   the   same \n\nenumeration type;\n\n\u25cf As the source of an assignment or a static_cast, unless the target has the same enumeration \ntype or is an integer type large enough to accept all the values of the narrowest possible  \nunderlying type;\n\n\u25cf As   the  condition  of   a  switch,   unless   all  case  constants   are   enumerators   of   the   same \n\nenumeration.\n\n132\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nAdditionally, a static_cast expression shall only have an unscoped enumeration target type if that \nenumeration type has a 9xed underlying type.\n\nRationale\n\nThe  underlying  type  of  an  unscoped  enumeration  that  does  not  have  a  fixed  underlying  type  is \nimplementation-de%ned, so any implicit conversion could yield surprising results.\n\nExample\n\nenum E     { e1a, e1b };\nenum Other { e2a };\n\nvoid g( int32_t i );\n\nvoid f( E e )\n{\n  E       e2 = e;       // Compliant - assignment to the same type\n  int32_t i1 = e;       // Compliant - assignment to a large enough integer\n\n  e == e1a;             // Compliant\n  e < e1b;              // Compliant\n  e == e2a;             // Non-compliant - second operand of a different type\n  e + 1;                // Non-compliant - addition\n\n  g( e );               // Compliant - assignment to large enough integer\n\n  switch( e )           // Non-compliant - cases are not all enumerators of E\n  {\n    case e1b: return;   // e1b is an enumerator of E\n    case e2a: return;   // e2a is not an enumerator of E\n  }\n\n  auto s  = sizeof( e + 1 );         // Unevaluated context - rule does not apply\n  E    e3 = static_cast< E >( 0 );   // Non-compliant\n\n  auto a1 = \"QWERTY\";\n  a1[ e1a ];            // Compliant - index operator\n  *( a1 + e1a );        // Non-compliant\n\n  std::string a2 { a1 };\n  a2[ e1a ];            // Compliant - assignment to a large enough integer (size_t)\n}\n\nSee also"
  },
  {
    "rule": "Rule 10.2.2\n\n4.10.3 Namespaces \n\n [basic.namespace]"
  },
  {
    "rule": "Rule 10.3.1\n\nThere should be no unnamed namespaces in header %les\n\n[namespace.unnamed]\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nAn unnamed namespace is unique within each translation unit. Any declarations appearing in an \nunnamed namespace within a header file refer to different entities in each translation unit, which might \nnot be consistent with developer expectations.\n\n133\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nExample\n\n// Header.hpp\nnamespace            // Non-compliant\n{\n  inline int32_t x;\n}\n\nvoid fn_a();\n\nn\ne\ns\n\n// File1.cpp\n#include \"Header.hpp\"\n\nvoid fn_a()\n{\n  x = 42;\n}\n\n// File2.cpp\n#include \"Header.hpp\"\n\nvoid fn_b()\n{\n  fn_a();            // Assigns 42 to 'x' in translation unit for 'File1.cpp'\n\n  if ( x == 42 ) {}  // 'x' within this translation unit will not have the value 42\n}\n\n4.10.4 The asm declaration \n\n [dcl.asm]"
  },
  {
    "rule": "Rule 10.4.1\n\nThe asm declaration shall not be used\n\n[dcl.asm] Implementation 1\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThe asm declaration is conditionally-supported, with the use of any assembly language insert resulting \nin implementation-de%ned behaviour.\n\nMany modern development environments provide better means (such as intrinsic functions) for  \nachieving what has traditionally been done by the use of assembly language.\n\nEncapsulation of assembly language should be considered if this rule is subject to deviation, as this  \naids portability. \n\nNote: the use of any assembly language that does not use the asm declaration is a language extension, \nand is restricted by"
  },
  {
    "rule": "Rule 4.1.1.\n\n134\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f4.11 Declarators\n\ns\ne\nn\n\n4.11.3 Meaning of declarators \n\n [dcl.meaning]\n\ni\nl\n\ni\n\ne\nd\nu\nG"
  },
  {
    "rule": "Rule 11.3.1\n\nVariables of array type should not be declared\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nA variable of array type does not have value semantics and its size has to be managed separately. It is \npossible to use types that do not have these limitations. For example:\n\n\u25cf std::array \u2014 provides value semantics and manages the size;\n\n\u25cf std::string_view \u2014 manages the size.\n\nException\n\nThe declaration of an array of const character type is permitted when it is immediately initialized with \na string literal.\n\nExample\n\nvoid foo() noexcept\n{\n  const size_t                     size { 10 };\n        wchar_t                    a1 [ size ];  // Non-compliant\n        std::array< wchar_t, size > a2;          // Compliant\n}\n\nvoid bar( int      a[ 10 ],    // Rule does not apply - pointer to int\n          int ( &b )[ 10 ],    // Rule does not apply - reference to array\n          int ( *c )[ 10 ])    // Rule does not apply - pointer to array\n{\n}\n\nstruct S\n{\n  std::uint16_t a3[ 10 ];                        // Non-compliant\n};\n\nusing namespace std::literals;\n\nconst char s1[] = \"abcd\";                        // Compliant by exception\n      char s2[] = \"abcd\";                        // Non-compliant\nconst auto best = \"abcd\"sv;                      // Compliant\n\nSee also"
  },
  {
    "rule": "Rule 7.11.2\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n135\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 11.3.2\n\nThe declaration of an object should contain no more than two levels \nof pointer indirection\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nn\ne\ns\n\nAny typedef-name appearing in a declaration is treated as if it were replaced by the type that it denotes.\n\nNote: the pointer decay that occurs when declaring a function parameter of array type introduces a  \nlevel of pointer indirection.\n\nRationale\n\nUse of more than two levels of indirection can seriously impair the ability to understand the behaviour \nof the code, and therefore should be avoided.\n\nExample\n\ntypedef int8_t * INTPTR1;\nusing INTPTR2 = int8_t *;\n\nstruct s\n{\n  int8_t *   s1;                                // Compliant\n  int8_t **  s2;                                // Compliant\n  int8_t *** s3;                                // Non-compliant\n};\n\nstruct s *   ps1;                               // Compliant\nstruct s **  ps2;                               // Compliant\nstruct s *** ps3;                               // Non-compliant\n\nint8_t **  (   *pfunc1 )();                     // Compliant\nint8_t **  (  **pfunc2 )();                     // Compliant\nint8_t **  ( ***pfunc3 )();                     // Non-compliant\nint8_t *** (  **pfunc4 )();                     // Non-compliant\n\nvoid function( int8_t  *   par1,                // Compliant\n               int8_t  **  par2,                // Compliant\n               int8_t  *** par3,                // Non-compliant\n               INTPTR1 *   par4,                // Compliant\n               INTPTR1 *   const * const par5,  // Non-compliant\n               int8_t  *   par6[],              // Compliant\n               int8_t  **  par7[],              // Non-compliant\n               int8_t  ** &par8)                // Compliant\n\n{\n   int8_t  *   ptr1;                            // Compliant\n   int8_t  **  ptr2;                            // Compliant\n   int8_t  *** ptr3;                            // Non-compliant\n   INTPTR2 *   ptr4;                            // Compliant\n   INTPTR2 *   const * const ptr5;              // Non-compliant\n   int8_t  *   ptr6[ 10 ];                      // Compliant\n   int8_t  **  ptr7[ 10 ];                      // Compliant\n}\n\nExplanation of types:\n\n\u25cf par1 and ptr1 are of type pointer to int8_t.\n\n136\n\n\u25cf par2 and ptr2 are of type pointer to pointer to int8_t.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n\u25cf par3 and ptr3 are of type pointer to a pointer to a pointer to int8_t. This is three levels and \n\nis non-compliant.\n\n\u25cf par4 and ptr4 are expanded to a type of pointer to a pointer to int8_t.\n\n\u25cf par5  and  ptr5  are expanded to a type of const pointer to a const pointer to a pointer to \n\nint8_t. This is three levels and is non-compliant.\n\n\u25cf par6 is of type pointer to pointer to int8_t because arrays are converted to a pointer to the \n\ninitial element of the array.\n\n\u25cf ptr6 is of type array of pointers to int8_t.\n\n\u25cf par7  is of type pointer to pointer to pointer to  int8_t  because arrays are converted to a \n\npointer to the initial element of the array. This is three levels and is non-compliant.\n\n\u25cf ptr7 is of type array of pointer to pointer to int8_t. This is compliant.\n\n\u25cf par8 is of type reference to pointer to pointer to int8_t. This is compliant.\n\n4.11.6 Initializers"
  },
  {
    "rule": "Rule 11.6.1 All variables should be initialized\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\n [dcl.init]\n\n[dcl.init]\n\nAll variables should either be explicitly or implicitly initialized.\n\nApart from the following, all variables should be explicitly initialized with an associated initializer in  \ntheir de9nition:\n\n1. Variables of class type, or\n\n2. Function parameters (which are initialized with the corresponding argument value), or\n\n3. Variables with static storage duration (which are zero-initialized by default).\n\nRationale\n\nHaving several states within a program increases the risk of defects being introduced. Each variable \nthat is 9rst uninitialized, then set to a value creates two program states. It is therefore better to initialize \nthe variable directly to a value that is to be used. The intent of this rule is not that each variable is  \ninitialized with some value, but that it is initialized with its real value; the one that will be used when \nthe variable is next read.\n\nIn order to achieve this, the variable de9nition can be delayed until the \u201cright\u201d value is available. This \nnaturally   leads   to   reducing   the   variable\u2019s   scope,   reducing   the   risk   of   the   variable   being   used  \ninappropriately. An immediately evaluated lambda can be used to compute a value when a variable\u2019s \ninitialization is more complex.\n\nIn many cases, initializing the variable within its de9nition allows it to be a constant de9nition.\n\nNote: there are many ways to explicitly initialize a variable. When possible, the list-initialization syntax \n(with curly braces) should be used as it does not suCer from the issues that arise from the use of other \nsyntactic forms (e.g. narrowing or declaring a function while trying to de9ne a variable, also known as \n\u201cthe most vexing parse\u201d).\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n137\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nExample\n\nvoid f( bool cond )\n{\n  int32_t i;                        // Non-compliant\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n138\n\n  if ( cond ) { i =  42; }\n  else        { i = -1;  }\n\n  int32_t j = cond ? 42 : -1;       // Compliant\n  int32_t k = [&]()                 // Compliant\n    {\n      if ( cond ) { return 42; }\n      else        { return -1; }\n    }();\n\n  string s;                         // Compliant - default-initialized\n}\n\nint32_t g;                          // Compliant - static initialization applies\n\nvoid f()\n{\n  thread_local int32_t i;           // Compliant - static initialization applies\n}\n\nSee also"
  },
  {
    "rule": "Rule 15.1.4"
  },
  {
    "rule": "Rule 11.6.2\n\nThe value of an object must not be read before it has been set\n\n[dcl.init] Unde9ned 12\n\nCategory Mandatory\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nFor the purposes of this rule, an array element or class member is considered to be a discrete object. \n\nNote: struct members are also class members.\n\nRationale\n\nObjects created with automatic storage duration or dynamic storage duration have an indeterminate  \nvalue. Reading an indeterminate value may result in unde%ned behaviour.\n\nThis rule requires that all objects are written, either by implicit or explicit initialization in their  \ndeclaration or by assignment, before they are read.\n\nNote: jumping over an initializer by the use of a goto or switch statement \u201cbypasses\u201d the declaration \nof the object, rendering the program ill-formed.\n\nExample\n\nnamespace \n{\n  int32_t Z;                  // Compliant - implicitly initialized with '0'\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nvoid f()\n{\n  int32_t  i;\n  int32_t  j = i + 1;         // Non-compliant - i has not been assigned a value\n\n  int32_t * p = new int32_t;\n  int32_t   k = *p;           // Non-compliant - *p has not been assigned a value\n\n  int32_t * q;\n\n  if ( q == p )               // Non-compliant - q has not been assigned a value\n  {\n  }\n}\n\nint32_t g( bool b )\n{\n  if ( b )\n  {\n    goto L1;\n  }\n\n  int32_t x;\n\n  x = 10u;\n\nL1:\n  x = x + 1u;               // Non-compliant - x may not have been assigned a value\n\n  return x;\n}\n\nstruct S { int32_t a; int32_t b; };\n\nvoid h()\n{\n  S s1;\n  S s2 = { 10 };\n\n  auto i1 = s1.a;           // Non-compliant\n  auto i2 = s2.b;           // Compliant - s2.b implicitly initialized to 0\n\n  int32_t array1[ 10 ] = { 1, 2, 3 };\n  int32_t array2[ 10 ];\n  auto i3 = array1[ 5 ];    // Compliant - array1[ 5 ] implicitly initialized to 0\n  auto i4 = array2[ 5 ];    // Non-compliant\n}\n\nclass C\n{\npublic:\n  C() : m_a( 10 ), m_b( 7 )   // Both m_a and m_b initialized\n  {\n  }\n\n  C( int32_t a ) : m_a( a )   // m_b not initialized\n  {\n  }\n\n  int32_t GetmB()\n  {\n    return m_b;\n  }\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n139\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n140\n\nprivate:\n  int32_t m_a;\n  int32_t m_b;\n};\n\nint main()\n{\n  C c1;\n  if ( c1.GetmB() > 0 )       // Compliant - m_b initialized\n  {\n  }\n\n  C c2( 5 );\n\n  if ( c2.GetmB() > 0 )       // Non-compliant - m_b not initialized\n  {\n  }\n}\n\nSee also"
  },
  {
    "rule": "Rule 15.1.4"
  },
  {
    "rule": "Rule 11.6.3 Within an enumerator list, the value of an implicitly-speci9ed \n\nenumeration constant shall be unique\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nAn implicitly-speci9ed enumeration constant has a value one greater than its predecessor. If the 9rst \nenumeration constant is implicitly-speci9ed, then its value is zero.\n\nAn explicitly-speci9ed enumeration constant has the value of the associated constant expression.\n\nIf implicitly-specified and explicitly-specified constants are mixed within an enumeration list, it is  \npossible for values to be duplicated. Such duplication may be unintentional and may give rise to  \nunexpected behaviour.\n\nThis rule requires that any duplication of  enumeration constants  be made explicit, thus making the \nintent clear.\n\nException\n\nAn implicitly-specified  enumeration constant  may have the same value as an explicitly-specified \nenumeration constant from the same enumeration when the explicitly-speci9ed value is de9ned using \nonly the name of another enumeration constant.\n\nExample\n\nThe following examples are compliant as it is clear which enumeration constants have the same value: \n\nenum E1 { A = 3, B, C = 5, D = 5 };           // Compliant\nenum E2 { A = 3, B, C,     D = C, E = D };    // Compliant by exception\n\nThe following examples are non-compliant as enumeration constants have the same implicit values: \n\nenum E3 { A = 3, B, C, D = 4    };            // 'B' and 'D' have the same value\nenum E4 { A = 3, B, C, D = B, E };            // 'C' and 'E' have the same value\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fThe following example is non-compliant as the use of B + 1 means the exception does not apply. \n\nenum E5 { A = 3, B, C, D = B + 1 };           // Non-compliant\n\n4.12\n\nClasses\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n4.12.2 Class members \n\n [class.mem]"
  },
  {
    "rule": "Rule 12.2.1 Bit-9elds should not be declared\n\n[class.bit] Implementation 1\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThere are a number of aspects of bit-9elds that a developer needs to consider, including:\n\n\u25cf It is implementation-defined whether the bit-fields are allocated from the high or low end of a  \n\nstorage unit (usually a byte);\n\n\u25cf It is implementation-de%ned whether or not a bit-9eld can overlap a storage unit boundary (e.g. \nif a 6-bit bit-9eld and a 4-bit bit-9eld are declared in that order, then the 4-bit bit-9eld may either \nstart a new byte or it may use 2 bits in one byte and 2 bits in the next);\n\n\u25cf If the bit-9eld\u2019s width is greater than the number of bits in the object representation of the bit-\n9eld\u2019s type, then the extra bits are padding bits and do not participate in the value representation \nof the bit-9eld.\n\nThese issues are generally benign (e.g. when packing together short-length data to save storage space), \nbut they may lead to errors if the absolute position of the bit-9elds is important (e.g. when accessing \nhardware registers).\n\nProvided the elements of the structure are only accessed by name, the developer need make no  \nassumptions about the way that the bit-9elds are stored within the structure.\n\nExample\n\nstruct message\n{\n  unsigned char low  : 4;    // Non-compliant\n  unsigned char high : 4;    // Non-compliant\n};\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n141\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:"
  },
  {
    "rule": "Rule 12.2.2 A bit-9eld shall have an appropriate type\n\n[class.bit] / 3, 4; Implementation 1\n[basic.fundamental] / 5; Implementation 1\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nAmpli2cation\n\nThe following types are appropriate for a bit-9eld:\n\n\u25cf Signed and unsigned integer types;\n\n\u25cf An enum with a fixed underlying type of signed or unsigned integer type, provided that all of its \n\nenumeration values are representable within the width of the bit-field;\n\n\u25cf bool.\n\nRationale\n\nThe char and wchar_t types shall not be used for bit-9elds as it is implementation-de%ned if they are \nsigned or unsigned. The char16_t and char32_t types are not permitted as they are only intended \nto be used to store character code points.\n\nSimilarly, when using an unscoped enum without specifying the underlying type, it is implementation-\ndefined if the underlying representation is signed or unsigned. Therefore, the exact number of bits  \nrequired to represent all values in the enumeration is also implementation-de%ned.\n\nExample\n\nstruct S\n{\n   signed int a : 2;    // Compliant\n          int   : 2;    // Compliant\n      int32_t b : 2;    // Compliant\n         char c : 2;    // Non-compliant\n\n  signed char d : 2;    // Compliant - signed integer type\n      wchar_t e : 2;    // Non-compliant - not a signed or unsigned integer type\n     char32_t f : 2;    // Non-compliant - not a signed or unsigned integer type\n         bool g : 1;    // Compliant\n};\n\nenum Direction { Top, Left, Bottom, Right };\nenum Colour : char          { Red, Pink, Blue };\nenum Line   : unsigned char { Plain, Dash, Dot};\n\nstruct S\n{\n  Direction dir        : 4;   // Non-compliant - unscoped and no underlying type\n  Colour    lineColour : 2;   // Non-compliant - underlying type is plain char\n  Line      lineStyle1 : 1;   // Non-compliant - cannot represent Dot\n  Line      lineStyle2 : 2;   // Compliant\n};\n\n142\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS"
  },
  {
    "rule": "Rule 12.2.3 A named bit-9eld with signed integer type shall not have a length of \n\none bit\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nA single-bit signed bit-9eld is unlikely to behave in a useful way and its presence is likely to indicate an \nerror.\n\nNote: anonymous signed bit-9elds of any length are allowed as they cannot be accessed.\n\nExample\n\nstruct S\n{\n  signed int a : 1;    // Non-compliant\n  signed int   : 1;    // Rule does not apply\n  signed int   : 0;    // Rule does not apply\n  signed int b : 2;    // Compliant\n         int c : 1;    // Non-compliant\n};\n\n4.12.3 Unions \n\n [class.union]"
  },
  {
    "rule": "Rule 12.3.1\n\nThe union keyword shall not be used\n\n[class.union] / 1, 5\n[basic.life] 1; Unde9ned 4\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nA member of a union can be written and the same member can then be read back in a well-de9ned \nmanner.\n\nHowever, writing to one union member and then reading back from a different union member results  \nin unde%ned behaviour. In addition, the use of a member of non-trivial type requires manual control \nof its lifetime. For these reasons, unions shall not be used.\n\nThe class std::variant, available since C++17, provides a type-safe union that can be used to store a \nvalue of one type from a 9xed set of alternatives. In contrast to unions, the alternatives are accessed  \nby type (if the types are diCerent) or index, not by name. It is impossible to access an inactive member \nof a std::variant. For example, trying to access an inactive member via std::get will lead to an \nexception being thrown.\n\nExample\n\nunion Data1                                    // Non-compliant\n{\n  int32_t i;\n  float   j;\n};\n\nusing Data2 = std::variant< int32_t, float >;  // Rule does not apply\n\n143\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\n4.13 Derived classes\n\n4.13.1 Multiple base classes \n\n [class.mi]\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n144"
  },
  {
    "rule": "Rule 13.1.1 Classes should not be inherited virtually\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nVirtual inheritance of base classes is not recommended as it introduces a number of potentially \nconfusing behaviours, such as call by dominance in diamond hierarchies and changes to the order of \ninitialization of bases.\n\nExample\n\nstruct A\n{\n  virtual int32_t foo() { return 1; }\n};\n\nstruct B : public virtual A            // Non-compliant\n{\n  int32_t goo()\n  {\n    return foo();\n  }\n};\n\nstruct C : public virtual A            // Non-compliant\n{\n  int32_t foo() override { return 2; }\n};\n\nstruct D : C, B\n{\n};\n\nint main()\n{\n  D d;\n\n  return d.goo();                      // Calls C::foo(), which may not be expected\n}\n\nSee also"
  },
  {
    "rule": "Rule 8.2.1,"
  },
  {
    "rule": "Rule 13.1.2,"
  },
  {
    "rule": "Rule 15.1.1\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS"
  },
  {
    "rule": "Rule 13.1.2 An accessible base class shall not be both virtual and non-virtual in \n\nthe same hierarchy\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nWhere a base class is inherited both virtually and non-virtually, it is unclear if the intent is for there to  \nbe one or more instances of the base class subobject.\n\nExample\n\nclass A {};\n\nclass B1: public virtual A {};\nclass B2: public virtual A {};\nclass B3: public         A {};\n\nclass C:  public B1, B2, B3 {};  // Non-compliant - C has two A subobjects\n\nSee also"
  },
  {
    "rule": "Rule 13.1.1\n\n4.13.3 Virtual functions \n\n [class.virtual]"
  },
  {
    "rule": "Rule 13.3.1 User-declared member functions shall use the virtual, override \n\nand final speci9ers appropriately\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe speci9ers are used appropriately when a member function declaration:\n\n1. Does not override a function in a base class, and has either no specifier or has the virtual \n\nspeci9er; or\n\n2. Overrides a function in a base class, does not use the virtual speci9er, and does use either \n\nthe override or final speci9er.\n\nNote: this rule also applies to destructors.\n\nRationale\n\nWhen a function is declared that does not override a function in a base class (including the case where \nthe owning class has no base classes), then it is either not intended to be virtual or it is a virtual function \nthat is expected to be overridden in a derived class. The function declaration should therefore include  \neither no specifier or the virtual specifier, as appropriate. The use of the override specifier in \nthis case would render the program ill-formed, whilst use of the final speci9er would mean that it is \na virtual function that cannot be subsequently overridden (in which case making it   virtual  is \nredundant).\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n145\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nWhen a function is declared that overrides a virtual function in a base class:\n\n\u25cf The override specifier explicitly documents that this declaration overrides a function in a base \n\nclass;\n\n\u25cf The final speci9er documents that no further overrides are permitted.\n\nWhilst they are permitted by the C++ Standard, the following redundant combinations of specifier shall \nbe avoided:\n\n1. Use of virtual with either override or final;\n\n2. Use of final with override.\n\nThe use of a single speci9er makes the meaning clearer:\n\n1. virtual \u2014 this is a new virtual function this is expected to be overridden;\n\n2. override \u2014 this is an override that may or may not be overridden;\n\n3. final \u2014 this is an override that cannot be overridden.\n\nNotes:\n\n1. Declaring a class itself as final does not make its virtual member functions override or \n\nfinal; the compiler is not required to check that the declarations are overrides.\n\n2."
  },
  {
    "rule": "Rule 6.4.2  restricts the use of function declarations that hide non-virtual functions in base  \n\nclasses.\n\nExample\n\nclass A\n{\npublic:\n  virtual ~A() = default;\n  virtual void f1() noexcept = 0;               // Compliant\n  virtual void f2() noexcept {}                 // Compliant\n  virtual void f3() noexcept {}                 // Compliant\n          void f4() noexcept {}                 // Compliant\n\n  // The following declarations are non-compliant\n  virtual void f5() noexcept final = 0;         // 'virtual' and 'final'\n  virtual void f6() noexcept final {}           // 'virtual' and 'final'\n          void f7() noexcept final {}           // Ill-formed - not virtual\n};\n\nclass B : public A\n{\npublic:\n  // The following declarations are non-compliant\n  ~B();                                         // No specifier given for override\n  virtual void f1() noexcept override {}        // 'virtual' and 'override'\n          void f2() noexcept override final {}  // 'override' and 'final'\n          void f3() noexcept {}                 // No specifier given for override\n          void f4() noexcept override {}        // Ill-formed - A::f4() not virtual\n};\n\nSee also"
  },
  {
    "rule": "Rule 6.4.2,"
  },
  {
    "rule": "Rule 15.0.1\n\n146\n\nLicensed to: gunjanjain\n22 Apr 2025"
  },
  {
    "rule": "Rule 13.3.2 Parameters in an overriding virtual function shall not specify diCerent \n\ndefault arguments\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nEach parameter in an overriding virtual function shall either:\n\n1. Not specify a default argument; or\n\n2. Use a constant expression as its default argument, with the corresponding parameter in the \nnon-overriding function also specifying a default argument that is a constant expression with \nthe same value.\n\nRationale\n\nDefault arguments are determined by the static type of the object. If a default argument is diCerent \nfor a parameter in an overriding function, the value used in the call will be diCerent when calls are  \nmade via the base or derived object, which may be contrary to developer expectations.\n\nRequiring that multiple default arguments for the same parameter be  constant expressions allows \ncompliance checks for this rule to be decidable.\n\nExample\n\nint32_t x();\n\nclass Base\n{\npublic:\n  virtual void good1( int32_t a = 0   );\n  virtual void good2( int32_t a = x() );\n  virtual void bad1 ( int32_t a = 0   );\n  virtual void bad2 ( int32_t a       );\n  virtual void bad3 ( int32_t a = x() );\n};\n\nclass Derived : public Base\n{\npublic:\n  void good1( int32_t a = 0   ) override;   // Compliant - same default used\n  void good2( int32_t a       ) override;   // Compliant - no default specified\n  void bad1 ( int32_t a = 1   ) override;   // Non-compliant - different value\n  void bad2 ( int32_t a = 2   ) override;   // Non-compliant - no default in base\n  void bad3 ( int32_t a = x() ) override;   // Non-compliant - not constant\n};\n\nvoid f( Derived & d )\n{\n  Base & b = d;\n\n  b.good1();      // Will use default of 0\n  d.good1();      // Will use default of 0\n  b.good2();      // Will use default of x( )\n  d.good2( 0 );   // No default value available to use\n\n  b.bad1();       // Will use default of 0\n  d.bad1();       // Will use default of 1\n  b.bad2( 0 );    // No default value available to use\n  d.bad2();       // Will use default of 2\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n147\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 13.3.3\n\nThe parameters in all declarations or overrides of a function shall \neither be unnamed or have identical names\n\nCategory Required\n\nAnalysis Decidable, System\n\nRationale\n\nn\ne\ns\n\nThe name given to a parameter helps document the purpose of the parameter. If a function parameter \nis renamed in a subsequent declaration, then having diCerent names for the same object may lead to \ndeveloper confusion.\n\nExample\n\nThe following example is compliant: \n\nvoid fn1( int32_t a );\nvoid fn1( int32_t   );\n\nThe following example is non-compliant as the parameter names have been swapped: \n\nvoid CreateRectangle( uint32_t Height, uint32_t Width  );\nvoid CreateRectangle( uint32_t Width,  uint32_t Height );\n\nThe following example is non-compliant as the named parameters are diCerent: \n\nvoid fn2( int32_t a );\nvoid fn2( int32_t b ) { }\n\nThe following example is non-compliant as the parameter name in the override differs from the  \nparameter name in the overridden function:\n\nclass Shape\n{\n  virtual void draw( Canvas & destination ) = 0;\n};\n\nclass Rectangle : public Shape\n{\n  void draw( Canvas & canvas ) override;\n};\n\nThe rule does not apply to the following example as the specialization is a diCerent declaration (note \nthat this example is non-compliant with"
  },
  {
    "rule": "Rule 17.8.1): \n\ntemplate< class T > void f( T t );\ntemplate<> void f< int32_t >( int32_t i );\n\n148\n\nLicensed to: gunjanjain\n22 Apr 2025"
  },
  {
    "rule": "Rule 13.3.4 A comparison of a potentially virtual pointer to member function shall \n\nonly be with nullptr\n\n[expr.eq] Unspeci9ed 3\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nA pointer to member function is potentially virtual if it is:\n\n1. A compile-time constant that points to a virtual member function; or\n\n2. A pointer to member function of a class that is incomplete at the end of the translation unit; or\n\n3. Not a compile-time constant pointer to member function and has a type matching that of a \n\nvirtual member function of its class.\n\nRationale\n\nThe result of comparing a pointer to member function that points to a virtual function with anything \nother than nullptr is unspeci9ed.\n\nExample\n\nclass A\n{\npublic:\n          void f1();\n          void f2();\n  virtual void f3();\n};\n\nvoid foo()\n{\n  if ( &A::f1 != &A::f2  ) {}   // Compliant\n  if ( &A::f1 != nullptr ) {}   // Compliant\n  if ( &A::f3 == &A::f2  ) {}   // Non-compliant - f3 virtual\n  if ( &A::f3 == nullptr ) {}   // Compliant\n}\n\nvoid bar( void ( A::*ptr )() )\n{\n  if ( ptr == &A::f2 ) {}       // Non-compliant - ptr potentially points to A::f3,\n                                // which is virtual\n}\n\nNote: the example above would be compliant if A had no virtual members.\n\nclass B\n{\npublic:\n          void f1();\n          void f2();\n  virtual void f3( int32_t i );\n};\n\nvoid bar( void ( B::*ptr )() )\n{\n  if ( ptr == &B::f2 ) {}       // Compliant - there are no virtual functions \n                                // in B with the appropriate signature\n}\n\n149\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nclass D: public A               // Inherits virtual functions from A\n{\npublic:\n  void f4();\n};\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n150\n\nvoid car( void ( D::*ptr )() )\n{\n  if ( ptr == &D::f4 ) {}       // Non-compliant - ptr potentially points to A::f3,\n                                // which is virtual\n}\n\nstruct E;\n\nvoid foo ( void ( E::*p1 )(), void ( E::*p2 )() ) \n{\n  if ( p1 == p2 ) {}            // Non-compliant - 'E' is incomplete, so it is\n                                // unknown if the pointers are to virtual members    \n\n}\n\n// The following definition of E anywhere in the translation\n// unit would make the above example compliant\n// struct E{ void f1(); void f2(); };\n\n4.14 Member access control\n\n4.14.1 Access speci2ers \n\n [class.access.spec]"
  },
  {
    "rule": "Rule 14.1.1 Non-static data members should be either all private or all \n\npublic\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nBy implementing a class interface with member functions only and making all the class data members \ninaccessible, it is possible to retain more control over how the object\u2019s state can be modified. For  \nexample, enforcing an invariant for the class, or making sure that the address of a data member of a \nclass can not be accessed by its users, making detection of possibly dangling addresses more robust.\n\nHowever, some classes merely need to group together some data members without defining any \ninvariants. For such classes, making the data members public simplifies the code (less code to \nmaintain, easy use of structured bindings), therefore reducing the risk of errors.\n\nThese two situations are usually exclusive, with it being di[cult to reason about a class that has both \npublic and private data members.\n\nThe use of protected data members would mean that:\n\n\u25cf The members should not be directly accessed; and\n\n\u25cf The members can be directly accessed by any derived class, possibly breaking the invariants  \n\nestablished by the base class.\n\nIf derived classes require privileged access to data members, those members should be private \nand protected functions should be de9ned to allow them to be manipulated.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nExample\n\nclass C1                       // Non-compliant - has public and private members\n{\npublic:\n  int32_t a;\n\nprivate:\n  int32_t b;\n};\n\nstruct C2                      // Compliant\n{\n  C2( int32_t a, int32_t b ) : a{ a }, b{ b } {}\n  int32_t a;\n  int32_t b;\n};\n\nclass C3                       // Compliant - rule does not apply to static members\n{\npublic:\n  C3( int32_t a, int32_t b ) : a{ a }, b{ b } {}\n  static int32_t s;\n\nprivate:\n  int32_t a;\n  int32_t b;\n};\n\n4.15\n\nSpecial member functions\n\n4.15.0 MISRA \n\n [misra]"
  },
  {
    "rule": "Rule 15.0.1 Special member functions shall be provided appropriately\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nFor the purposes of this rule, a special member function is said to be customized if it is user-provided \nand not defaulted.\n\nAll out-of-class de9nitions of the destructor, copy operations, and move operations for a class shall \nbe placed in a single 9le.\n\nIn addition, a class shall satisfy all of the requirements defined within this rule that apply to it. For  \ninstance, a class that is used as a base class and that has a  customized destructor shall comply with \nthe requirements within all of the following requirement sections.\n\nRequirements for all classes on copyability and movability\n\nA class T is copy-constructible if the expression std::is_copy_constructible_v< T > is true, \nand similarly for move-constructible, move-assignable, and copy-assignable.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n151\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nA class shall belong to exactly one of the following categories (other combinations are not permitted):\n\n1. Unmovable \u2014 it is not copy-constructible, not move-constructible, not copy-assignable and not \n\nmove-assignable; or\n\n2. Move-only \u2014 it is move-constructible (and optionally move-assignable) but neither copy-constructible \n\nnor copy-assignable; or\n\n3. Copy-enabled \u2014 it is copy-constructible and move-constructible and can optionally also be both \n\ncopy-assignable and move-assignable.\n\nCategory\n\nMove constructible\n\nMove assignable\n\nCopy constructible\n\nCopy assignable\n\nUnmovable\n\nMove-only\n\nCopy-enabled\n\nNo\n\nYes\n\nYes\n\nYes\n\nYes\n\nNo\n\nNo\n\nYes\n\nNo\n\nYes\n\nNo\n\nNo\n\nNo\n\nYes\n\nYes\n\nNo\n\nNo\n\nNo\n\nNo\n\nYes\n\nRequirements in the presence of customized copy or move operations\n\nIf a class has customized copy or move operations, it shall have a customized destructor.\n\nRequirements in the presence of customized destructors\n\nThe definition of any customized destructor shall contain at least one statement that is neither a \ncompound statement nor a null statement. A class with such a destructor is regarded by this rule as \nmanaging a resource.\n\nAdditionally:\n\n1.\n\nIf the class is unmovable, it is de9ned to be a scoped manager.\n\n2.\n\n3.\n\nIf the class is move-only, it shall have a customized move constructor. If it is move-assignable, it \nshall also have a customized move assignment operator. Such a class is defined to be a unique \nmanager.\n\nIf the class is copy-enabled, it shall have a customized copy constructor and its move constructor \nshall either be customized or not declared. If it is copy-assignable, it shall also have a customized  \ncopy-assignment operator and the move operations shall either both be customized or both not \nbe declared. Such a class is de9ned to be a general manager.\n\nRequirements in the presence of inheritance\n\nA class that is used as a public base class shall either:\n\n1. Be an unmovable class that has a (possibly inherited) public virtual destructor; or\n\n2. Have a protected non-virtual destructor.\n\nNote: these destructors shall either be de9ned as = default or customized (and non-empty).\n\nRationale\n\nLanguage rules determining which user-declared  special member functions  suppress which of the \ncompiler-provided functions are subtle and, for legacy reasons, the combinations produced may be \nsemantically unsound (see [depr.impldec] in the C++ Standard). \n\nThis rule takes advantage of reasonable language-provided defaults and, in particular, avoids the  \nneed to explicitly implement these defaults within the code; code that is, or attempts to be, equivalent \nto the compiler-provided functions is super^uous and may have subtle behavioural diCerences.\n\n152\n\nMore specifically, application of the \u201cRule of Zero\u201d in class definitions is encouraged \u2014 i.e. when a  \nclass does not declare any of the move constructor, copy constructor, move-assignment operator, copy-\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nassignment operator, or destructor special member functions. A class following the \u201cRule of Zero\u201d can \nbe unmovable, move-only or copy-enabled, depending on the properties of the class\u2019s members and \nbase classes.\n\nThe requirements on copyability and movability enforce the use of semantically sound combinations \nof the  special member functions. In particular, they ensure that  copy-constructible  types are always \nmove-constructible.\n\nThe requirements on classes with customized destructors cover the cases where resource management \nis involved and ensure that, when a class directly handles a resource, customized code will be called \nwhen an instance of the class is copied, moved or destroyed.\n\nThe requirements on base classes reduce the risk of slicing and deleting a derived class instance  \nthrough a base class pointer, when the base class does not have a virtual destructor:\n\n\u25cf Compliance with requirement 1 ensures that these risks are completely prevented.\n\n\u25cf Compliance with requirement 2 ensures that these risks are prevented for code that does not \n\nhave privileged access to the base class.\n\nCompliance with this rule addresses the vulnerabilities covered by the \u201cRule of Zero\u201d, the \u201cRule of Five\u201d \nand similar rules in other C++ guidelines. It also covers the vulnerabilities identified within the pre-\nC++11 \u201cRule of Three\u201d \u2014 see the requirements for general manager (above).\n\nException\n\nAn aggregate, which cannot have a user-declared destructor, may be used as a public base class \u2014 \nthis allows empty base class optimization for mix-in and tag types.\n\nExample\n\nstruct MyTagClass {};       // Compliant - Rule of Zero (empty class)\nstruct MyValue              // Compliant - Rule of Zero \n{\n  int32_t val { 42 }; \n};\n\nstruct PolyBaseWrong        // Non-compliant - base class that is not an aggregate \n{                           //                 and has no virtual destructor.\n  virtual void doIt();      //                 Additionally, slicing may occur.\n};\n\nstruct DerivedWrong : PolyBaseWrong {};\n\nstruct PolyBase             // Compliant - unmovable base class with virtual public\n{                           //             destructor\n  virtual void doIt() = 0;\n  virtual ~PolyBase() = default;\n\n  PolyBase & operator=( PolyBase && ) = delete;   // This makes the class unmovable\n};\n\nstruct Derived : PolyBase\n{\n  // Class definition\n};\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n153\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n154\n\nstruct NonEmptyDestructor   // Non-compliant - copy-enabled class with a customized\n                            //                 destructor but non-customized\n{                           //                 copy-operations\n  ~NonEmptyDestructor()     // Non-compliant - customized destructor has empty body\n  {\n    {\n      // Still empty\n      ;\n    }\n  }\n};\n\nstruct Locker               // Compliant - scoped manager\n{\n  explicit Locker( std::mutex & m ) :\n    m { m }\n  { \n    m.lock();\n  }\n\n  ~Locker()\n  {\n    m.unlock();\n  }\n\n  Locker & operator=( Locker && ) = delete;       // This makes the class unmovable\n\nprivate:\n  std::mutex & m;\n};\n\nstruct NonMovable           // Non-compliant - copy-constructible, but not \n{                           //                 move-constructible\n  NonMovable( NonMovable const &  );\n  NonMovable( NonMovable       && ) = delete;\n};\n\nstruct Aggregate { };\n\nstruct Child : Aggregate    // Compliant by exception - base class without\n{                           //                          destructor is an aggregate\n};"
  },
  {
    "rule": "Rule 15.0.2 User-provided copy and move member functions of a class should \n\nhave appropriate signatures\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nFor   a  class X,   the   copy   constructor,   move   constructor,   copy   assignment   operator   and   move \nassignment operator, if user-provided, should have the following signatures: \n\nX( X const & );                         // Copy constructor\nX( X && ) noexcept;                     // Move constructor\nX & operator=( X const & ) &;           // Copy assignment operator\nX & operator=( X && ) & noexcept;       // Move assignment operator\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fIt is permitted to:\n\n\u25cf Add constexpr to any of these operations;\n\n\u25cf Add explicit to the constructors;\n\n\u25cf Add noexcept (which may be conditional) to the copy operations.\n\nNote: const X & is also permitted as an alternative to X const &.\n\nRationale\n\nA constructor taking the class itself by non-const reference parameter (X &) is considered to be a copy \nconstructor. However, this parameter style means it is possible to modify the argument object, which \nwould be unlikely to meet developer expectations. \n\nThe use of copy and move constructors with parameters having default arguments makes it harder \nto review the code. Therefore, delegating to constructors supporting these extra parameters should \nbe used in preference to the use of default arguments. \n\nThe situation is similar for a copy assignment operator taking the right-hand-side operand by non-\nconst reference. For copy-assignment, the C++ Standard permits the right-hand-side parameter to be \npass-by-value; this is not allowed by this rule. \n\nAssignment operators should return an lvalue-reference to the assigned-to object in order to allow \nchaining of assignments. However, without reference quali9cation, the assignment may be to a  \ntemporary object with the risk that a potentially dangling lvalue-reference to that temporary object \nmay be exposed. Using an lvalue-reference returned from assignment to a temporary object to access \nthe temporary object results in undefined behaviour as the temporary object will have been destroyed \nbefore the access takes place.\n\nThrowing from within a move operation makes it unclear what the state of the moved-from object is \nexpected to be. Declaring these functions as noexcept makes it clear they will not throw, which is \ncompatible with exception-safe code.\n\nException\n\nUser-provided assignment operators are allowed to be declared with the return type  void as this \nprevents use of the result of the assignment operator, easing compliance with"
  },
  {
    "rule": "Rule 8.18.2.\n\nExample\n\nstruct UniqueManager\n{\n  UniqueManager() = default;                               \n  UniqueManager( UniqueManager && ) noexcept;               // Compliant\n  UniqueManager & operator=( UniqueManager && ) noexcept;   // Non-compliant -\n};                                                          //   needs & qualifier\n\nstruct Manager\n{\n  Manager( Manager const & other ) noexcept( false );    // Compliant\n  Manager( Manager const & other, char c );              // Not a copy-constructor\n  Manager( Manager && other, char c = 'x' ) noexcept;    // Non-compliant -\n};                                                       //   move constructor\n\nstruct ScopedManager\n{\n  ScopedManager();\n  ~ScopedManager();\n  ScopedManager & operator=( ScopedManager && ) = delete;   // Rule does not apply\n};\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n155\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nstruct Bad\n{\n  Bad( Bad volatile const & );                 // Non-compliant - volatile\n  virtual Bad & operator=( Bad const & ) &;    // Non-compliant - virtual\n};\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nSee also"
  },
  {
    "rule": "Rule 8.18.2,"
  },
  {
    "rule": "Rule 15.0.1\n\nn\ne\ns\n\n4.15.1 Constructors \n\n [class.ctor]"
  },
  {
    "rule": "Rule 15.1.1 An object\u2019s dynamic type shall not be used from within its \n\nconstructor or destructor\n\n[class.abstract] Unde9ned 6\n[class.cdtor] Unde9ned 3, 4, 5\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nFor the purposes of this rule, the initialization of a non-static data member (including via a  default \nmember initializer) is considered as being part of the constructor.\n\nThe dynamic type of an object is used when:\n\n\u25cf A virtual call is made to a virtual function;\n\n\u25cf typeid is applied to an object with polymorphic class type;\n\n\u25cf Using dynamic_cast.\n\nRationale\n\nDuring construction and destruction of an object, its type may be diCerent from the type of the fully \nconstructed object. The result of using an object\u2019s dynamic type in a constructor or destructor may  \nnot be consistent with developer expectations.\n\nThis rule also prohibits a virtual call being made to a pure virtual function from within a constructor  \nor destructor. Such calls result in unde%ned behaviour.\n\nAdditionally, using the dynamic type of the current object through a pointer or reference to a child  \nclass of the current class results in unde%ned behaviour, and is therefore also prohibited by this rule.\n\nExample\n\nclass B1\n{\npublic:\n  B1()\n  {\n    typeid( *this );                // Compliant - B1 not polymorphic\n  }\n};\n\n156\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nclass B2\n{\npublic:\n  virtual ~B2();\n  virtual void foo();\n  virtual void goo() = 0;\n\n  void bar()\n  {\n    foo();\n    typeid( *this );\n  }\n\n  B2()\n  {\n    typeid( *this );                // Non-compliant\n    typeid( B2 );                   // Compliant - current object type not used\n    B2::foo();                      // Compliant - not a virtual call\n    foo();                          // Non-compliant\n    goo();                          // Non-compliant - undefined behaviour\n    dynamic_cast< B2 * >( this );   // Non-compliant\n    bar();                          // Non-compliant - indirect call to foo and \n                                    // use of typeid on current object\n  }\n};\n\nThe following example is non-compliant and has unde9ned behaviour when a virtual call is made on  \nthe object under construction through an indirect pointer. \n\nclass B4;\n\nclass B3\n{\npublic:\n  explicit B3( B4 * b );\n  virtual ~B3();\n  virtual void foo();\n};\n\nclass B4 : public B3\n{\npublic:\n  B4() : B3( this ) { }\n};\n\nB3::B3( B4 * b )\n{\n    foo();                          // Non-compliant - calls B3::foo\n    this->foo();                    // Non-compliant - calls B3::foo\n    b->foo();                       // Non-compliant - undefined behaviour\n}"
  },
  {
    "rule": "Rule 15.1.2 All constructors of a class should explicitly initialize all of its virtual \n\nbase classes and immediate base classes\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to all user-provided constructors that are not defaulted.\n\n157\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nA base class is considered as explicitly initialized by a constructor when:\n\n1. The base class is initialized in the member initializer list of the constructor; or\n\n2. The constructor is a delegating constructor, assuming that the delegated-to constructor \n\nconforms to this rule.\n\nRationale\n\nThis rule reduces the chance of confusion over which constructor will be used, and with what  \nparameters. \n\nException\n\nA class is empty when it has no non-static data members, no virtual member functions, no virtual base \nclasses, and only  empty  base classes. A base class that is  empty  need not be initialized, as there is \nnothing to initialize.\n\nExample\n\nclass A\n{\npublic:\n  A() {}                          // Rule does not apply - no base classes\n};\n\nclass B : public A\n{\npublic:\n  B() {}                          // Compliant by exception\n};\n\nclass V\n{\npublic:\n   V() {}                         // Rule does not apply - no base classes\n   V( int32_t i ): i ( i ) {}     // Rule does not apply - no base classes\n\nprivate:\n   int32_t i = 0;\n};\n\nclass C1 : public virtual V\n{\npublic:\n  C1() : V { 21 } {}              // Compliant\n};\n\nclass C2 : public virtual V\n{\npublic:\n  C2() : V { 42 } {}              // Compliant\n};\n\nIn the following, there would appear to be an ambiguity as D only includes one copy of V. Which version \nof  V\u2018s constructor is executed and with what parameter? In fact,   V\u2018s default constructor is always \nexecuted. This would be the case even if C1 and C2 constructed their bases with the same integer \nparameter. \n\nclass D: public C1, public C2\n{\npublic:\n  D() {}                          // Non-compliant\n};\n\n158\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nThis is clari9ed by making the initialization explicit: \n\nD() : V {}, C1 {}, C2 {} {}       // Compliant - V::i == 0\n\nstruct E\n{\n  int32_t i;\n  int32_t j;\n};\n\nclass F : public E\n{\npublic:\n  F( int32_t val ) : E { val }    // Compliant - E is initialized by aggregate\n  {}                              // initialization, with E::j initialized to 0\n\n  F() : F ( 0 ) {}                // Compliant - delegates to the other constructor\n};\n\nclass G : public A                // Rule does not apply - no user-provided\n{                                 // constructor                \n};\n\nclass H : public A, public V      // Rule does not apply - no user-provided\n{                                 // constructor\npublic:\n  using V::V;                     // Subobject 'A' implicitly initialized\n};"
  },
  {
    "rule": "Rule 15.1.3 Conversion operators and constructors that are callable with a single \n\nargument shall be explicit\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule does not apply to copy or move constructors. \n\nNote: this rule does not prevent the addition of explicit to other constructors.\n\nRationale\n\nThe explicit keyword prevents a constructor or conversion operator from being used to implicitly \nconvert from one type to another.\n\nExample\n\nclass C\n{\npublic:\n  C( int32_t a );                    // Non-compliant\n};\n\nclass D\n{\npublic:\n  explicit D( int32_t a );           // Compliant\n  D( const D & d );                  // Rule does not apply - copy constructor\n  operator int32_t() const;          // Non-compliant\n  explicit operator bool() const;    // Compliant\n};\n\n159\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nclass E\n{\npublic:\n  E( int32_t a,    int32_t b = 0 );  // Non-compliant - callable with one argument\n  E( char a = 'a', int32_t b = 0 );  // Non-compliant - callable with one argument\n  E( char a,       char b        );  // Rule does not apply - requires two arguments\n};\n\nvoid f( E e );\n\nn\ne\ns\n\nvoid g()\n{\n  f( 0 );                            // Implicit conversion from 0 to E\n}"
  },
  {
    "rule": "Rule 15.1.4 All direct, non-static data members of a class should be initialized \n\nbefore the class object is accessible\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA class object is considered accessible:\n\n\u25cf At the top of the compound-statement that forms the constructor body;\n\n\u25cf For an aggregate, as soon as the object is created.\n\nA data member is initialized at the top of a constructor body if:\n\n\u25cf The constructor is a delegating constructor; or\n\n\u25cf The data member has a default member initializer; or\n\n\u25cf The data member appears in the constructor\u2019s member initialization list; or\n\n\u25cf The data member\u2019s type has a constructor.\n\nA data member of an aggregate is initialized if:\n\n\u25cf The data member has a default member initializer; or\n\n\u25cf The object\u2019s declaration has an initializer; or\n\n\u25cf The data member\u2019s type has a constructor.\n\nFor the purposes of this rule, an implicitly or explicitly defaulted constructor is treated as if its  \nsynthesized body was user-written.\n\nRationale\n\nA constructor should completely initialize its object. Explicit initialization reduces the risk of an invalid \nstate existing after successful construction. Note \u2014 the initialization of base classes is covered by"
  },
  {
    "rule": "Rule 15.1.2.\n\nEach non-static data member should be initialized, preferably using a default member initializer, or \nelse within a constructor member initialization list.\n\nAssigning to the variable in the constructor body is not sufficient, as requiring members to be initialized \nat the top of the constructor allows compliance checking for this rule to be made decidable. \n\nNote: compliance with this rule means that constructors will often have an empty body.\n\n160\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nFor   an  aggregate,   non-static   data   members   can   be   initialized   either   by   using   default   member \ninitialization or aggregate initialization when declaring an object.\n\nExample\n\nclass PersonClass\n{\npublic:\n  PersonClass( string const & name, int32_t age ) :\n    name { name }, age { age }       // Compliant\n  {}\n\n  explicit PersonClass( int32_t age ) :\n    age { age }                      // Compliant - name is default constructed,\n  {}                                 //             and income initialized to 1000\n\n  explicit PersonClass( string const & name ) :\n    name { name }                    // Non-compliant - age not initialized\n  {\n    age = 18;\n  }\n\n  PersonClass() = default;           // Non-compliant - age not initialized\n\nprivate:\n  string  name;\n  int32_t age;\n  int32_t income = 1000;\n};\n\nclass PersonAggregate\n{\npublic:\n  string name;\n  int32_t age;\n  int32_t income { 1000 };\n};\n\nvoid f()\n{\n  PersonAggregate p1;       // Non-compliant - age not initialized, even though\n                            //                 name and income are initialized\n  PersonAggregate p2 {};    // Compliant - name is default constructed, and age is\n}                           //             initialized to 0, income to 1000\n\nclass Building              // Non-compliant - height not initialized in the\n{                           //                 implicit default constructor\nprivate:\n  string name;\n\npublic:\n  int32_t height;\n}\n\nclass Base\n{\n  int32_t a;\n\npublic:\n  explicit Base( int32_t a ) :  // Compliant \n    a { a } { }  \n};\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n161\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n162\n\nclass Derived : public Base\n{\n  int32_t b;\n\npublic:\n  Derived() :                   // Compliant\n    Base { 0 }, b {} {}\n\n  using Base::Base;             // Non-compliant - b not initialized by the\n};                              //                 synthesized constructor"
  },
  {
    "rule": "Rule 15.1.5 A class shall only de9ne an initializer-list constructor when it is the \n\nonly constructor\n\n[dcl.init.list]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nCopy and move constructors are permitted in addition to the initializer-list constructor.\n\nA constructor is an initializer-list constructor if its first parameter is of type \nstd::initializer_list< T > or is a reference to a (possibly cv-quali%ed) \nstd::initializer_list< T >, and either there are no other parameters or else all other \nparameters have default arguments.\n\nA constructor is an initializer-list constructor if:\n\n\u25cf Its first parameter is of type std::initializer_list< T > or is a reference to a (possibly cv-\n\nquali%ed) std::initializer_list< T >; and\n\n\u25cf Either there are no other parameters or else all other parameters have default arguments.\n\nRationale\n\nUnder the special overload resolution rules, a constructor with a sole std::initializer_list< T > \nparameter will always be preferred over a constructor taking individual arguments of convertible types \nin initializations using curly braces. Consequently, the eCect of an initialization may diCer depending  \non the form of initialization (curly braces or parentheses) and may not meet developer expectation.\n\nAlthough the guidelines within this document do not apply to C++ Standard Library de9nitions, the \ndesign of std::vector demonstrates the problem that this rule prevents in user classes: \n\nstd::vector< int32_t > v1{ 3, 4 };    // Vector has two elements: {3, 4}\nstd::vector< int32_t > v2( 3, 4 );    // Vector has three elements: {4, 4, 4}\n\nAnother source of confusion arises when a default constructor is present and an object is initialized \nwith empty curly braces. According to language rules, this will always call the default constructor, but \na developer may expect an initialization with an empty initializer list.\n\nNote: a non-constructor function taking a single std::initializer_list< T > parameter will \nrequire both parentheses and curly braces at the call site, so does not suffer from the concern  \naddressed by this rule.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nExample\n\nclass A                              // Non-compliant\n{\npublic:\n  A( std::size_t x, std::size_t y );\n\n  A( std::initializer_list< std::size_t > list );\n};\n\nclass B                              // Compliant - no initializer-list constructor\n{\npublic:\n  B( std::size_t x, std::size_t y );\n\n  // The following is not an initializer-list constructor\n  B( std::size_t x, std::initializer_list< std::size_t > list);\n};\n\nclass C                              // Compliant\n{\npublic:\n  C( std::initializer_list< std::size_t > list );\n\n};\n\nclass D                              // Compliant\n{\npublic:\n  D( const D & d );\n  D( D && d );\n  D( std::initializer_list< std::size_t > list );\n};\n\n4.15.8 Copying and moving class objects \n\n [class.copy]\n\nDir 15.8.1\n\nUser-provided copy assignment operators and move assignment \noperators shall handle self-assignment\n\n[swappable.requirements]\n[moveassignable]\n[copyassignable]\n\nCategory Required\n\nAmpli2cation\n\nTypes supporting copy assignment shall satisfy the CopyAssignable requirement.\n\nTypes supporting move assignment shall satisfy the MoveAssignable requirement.\n\nAdditionally, in the case of self-assignment, user-provided copy assignment operators and move assignment \noperators shall:\n\n\u25cf Not have unde%ned behaviour; and\n\n\u25cf Not leak any resources; and\n\n\u25cf Preserve the value of the self-assigned object.\n\nNote: what constitutes the value of an object depends on a class\u2019s design, and is usually related to the \nsemantics of the equality operator.\n\n163\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n164\n\nRationale\n\nClass designs that require user-provided copy assignment operators or move assignment operators can \nbe avoided when it is possible to use a manager class (see"
  },
  {
    "rule": "Rule 15.0.1), such as smart pointers and \nthe containers provided by the C++ Standard Library. However, when implementing a manager class, \ncare needs to be taken when de9ning user-provided copy assignment operators and move assignment  \noperators.\n\nNa\u00efve implementations, particularly in the presence of self-assignment, can lead to undefined behaviour, \nresource   leaks,   performance   issues   and   unintended   violations   of   the   object\u2019s   semantics.   Self-\nassignment is rarely intentional, but it is often hard to spot when it occurs \u2014 for example, when  \nmanipulating overlapping ranges of objects.\n\nThis directive extends the  CopyAssignable  and  MoveAssignable  requirements to all types supporting \nthese assignments, and additionally requires that the state of the object is preserved after a self-\nassignment. This is done to ensure that the behaviour is predictable and that no resources are leaked.\n\nWell-known idioms, such as copy-and-swap, may help when complying with this directive. However,  \nas there is no one-solution-9ts-all, this directive does not recommend a speci9c idiom.\n\nExample\n\nThe following is a simplified implementation of a container, similar to  std::vector. The class \nimplements a general manager, and so user-provided copy assignment operators and move assignment \noperators are required.\n\nclass Vector\n{\n  std::size_t   size_;\n  int32_t     * buffer_;\n\npublic:\n  Vector() : size_( 0 ), buffer_( nullptr ) {}\n  Vector( std::size_t size ) : size_( size ), buffer_( new int[ size ] ) {}\n\n  ~Vector()\n  {\n    delete[] this->buffer_;\n  }\n\n  Vector( Vector const & other ) :\n    size_( other.size_ ),\n    buffer_( other.size_ != 0 ? new int32_t[ other.size_ ] : nullptr )\n  {\n    ( void )std::copy_n( other.buffer_, size_, this->buffer_ );\n  }\n\n  Vector( Vector  && other ) noexcept :\n    size_( std::exchange( other.size_, 0 ) ),\n    buffer_( std::exchange( other.buffer_, nullptr ) )\n  {}\n\n  Vector & operator=( Vector const & other ) &;\n  Vector & operator=( Vector && other ) & noexcept;\n};\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nCopy assignment\n\nThe following implementation of copy assignment is non-compliant due to the presence of unde%ned  \nbehaviour for self-assignment. \n\nVector & Vector::operator=( Vector const & other ) &\n{\n  this->size_ = other.size_;\n  delete[] this->buffer_;                  // Deletes other.buffer_\n  this->buffer_ = new int[ other.size_ ];  // Reading from deleted storage,\n                                           //   resulting in undefined behaviour\n  ( void )std::copy_n( other.buffer_,\n                       other.size_,\n                       this->buffer_ );\n  return *this;\n}\n\nThis unde%ned behaviour can be prevented by introducing a check for self-assignment. \n\nVector & Vector::operator=( Vector const & other ) &\n{\n  if ( this != std::addressof( other ) )\n  {\n    this->size_ = other.size_;\n    delete[] this->buffer_;\n    this->buffer_ = new int[ other.size_ ];\n\n    ( void )std::copy_n( other.buffer_,\n                         other.size_,\n                         this->buffer_ );\n  }\n\n  return *this;\n}\n\nThe check for self-assignment is a valid solution in this case, but it does not guarantee a correct  \nimplementation in all cases (e.g., self-referential data structures). It also has several disadvantages  \nwhich are outside of the scope of this directive, but which may need to be considered in the final  \ndesign:\n\n\u25cf Pessimization of performance for the (presumably) rare case of self-assignment; and\n\n\u25cf Code duplication within the destructor (deletion of elements and the buffer) and the copy  \n\nconstructor (deep copy of elements); and\n\n\u25cf Failure to provide the strong exception safety guarantee.\n\nThese concerns are addressed when using the copy-and-swap idiom. \n\nVector & Vector::operator=( Vector const & other ) &\n{\n  Vector tmp( other );                      // Copy construction, with deep copying\n  std::swap( this->size_,   tmp.size_   );\n  std::swap( this->buffer_, tmp.buffer_ );\n\n  return *this;\n\n  // tmp goes out of scope and thus takes care of deleting the previous buffer\n}\n\nSelf-assignment is handled appropriately when using the copy-and-swap idiom. However, the creation \nof a new buffer invalidates any iterators or references to elements of the original Vector, and it \nrequires unnecessary duplication of resources. Whilst not shown in the above, these issues can be \navoided by introducing a check for self-assignment around the copy-and-swap algorithm.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n165\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nMove assignment\n\nThe following implementation of move assignment has no unde%ned behaviour, but the Vector will \nbe released when self-assignment takes place. By any reasonable notion of equivalence, the value is \nnot preserved.\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n166\n\nVector & Vector::operator=( Vector && other ) & noexcept\n{\n  delete[] this->buffer_;\n  this->size_   = std::exchange( other.size_,   0       );\n  this->buffer_ = std::exchange( other.buffer_, nullptr );\n\n  return *this;\n}\n\nThe following example addresses these issues by using the move-and-swap idiom. \n\nVector & Vector::operator=( Vector && other ) & noexcept\n{\n    Vector tmp( std::move( other ) );\n\n    std::swap( this->size_,   tmp.size_   );\n    std::swap( this->buffer_, tmp.buffer_ );\n\n    return *this;\n}\n\nWhen self-assignment takes place, the call to std::move transfers ownership of the resources to the \ntemporary object tmp, and then the calls to std:swap returns their ownership back to *this. There \nare no changes to the state of *this and duplication of resources does not occur. Whilst not shown, \na check for self-assignment may be included to avoid unnecessary operations. \n\nSee also"
  },
  {
    "rule": "Rule 15.0.1\n\n4.16 Overloading\n\n4.16.5 Overloaded operators \n\n [over.oper]"
  },
  {
    "rule": "Rule 16.5.1\n\nThe logical AND and logical OR operators shall not be overloaded\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nLogical AND and logical OR operators are transformed into function calls. Whilst the overloaded  \noperators obey the rules for syntax and evaluation order defined within the C ++ Standard, both \noperands will always be evaluated. As it may be unclear if a particular use of a logical operator results \nin a call to an overloaded operator, a developer may incorrectly believe that short-circuit evaluation \nwill occur.\n\nNote: the order of evaluation of the operands was unspecified when using overload operators in  \nversions of C++ prior to C++17.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fExample\n\nIn the following example, instantiation of the template function f with AutomatedCar results in the \nbuilt-in  operator&&  being   used,   with  AutomatedCar::increaseSpeed  only   being   called   if \nAutomatedCar::isOvertaking returns true.\n\nIf f is instantiated with Car, the overload of operator&& is used. As this does not have short-\ncircuit behaviour,  Car::increaseSpeed  is always called, irrespective of the value returned by \nCar::isOvertaking.\n\nclass FuzzyBool {};\n\nclass Car\n{\npublic:\n  FuzzyBool isOvertaking();\n  bool increaseSpeed();\n};\n\nclass AutomatedCar\n{\npublic:\n  bool isOvertaking();\n  bool increaseSpeed();\n};\n\nbool operator&&( FuzzyBool fb, bool b );    // Non-compliant\n\ntemplate< class Vehicle >\nvoid f( Vehicle & v )\n{\n  if ( v.isOvertaking() && v.increaseSpeed() )\n  {\n  }\n}"
  },
  {
    "rule": "Rule 16.5.2\n\nThe address-of operator shall not be overloaded\n\n[expr.unary.op] Unde9ned 5\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nTaking the address of an object of incomplete type where the complete type contains a user-declared \noperator& results in unde%ned behaviour (until C++11) or unspeci%ed behaviour (since C++11).\n\nOverloading the & operator can make code harder to understand as *&a may not give the same result \nas a.\n\nNote: std::addressof will always return the address of an object without there being a risk of  \nunde%ned or unspeci%ed behaviour.\n\nExample\n\n// A.h\nclass A\n{\npublic:\n  A * operator&();       // Non-compliant\n};\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n167\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n168\n\n// f1.cc\nclass A;\n\nvoid f1( A & a )\n{\n  &a;                    // Undefined or unspecified behaviour\n}\n\n// f2.cc\n#include \"A.h\"\n\nvoid f2( A & a )\n{\n  &a;                    // Uses user-defined operator&\n}\n\n4.16.6 Built-in operators \n\n [over.built]"
  },
  {
    "rule": "Rule 16.6.1 Symmetrical operators should only be implemented as non-member \n\nfunctions\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe following member binary operators are symmetrical operators, even when their parameters have \ndiCerent types: \n\noperator+    operator-    operator*   operator/    operator%\noperator==   operator!=   operator<   operator<=   operator>=   operator>\noperator^    operator&    operator|\noperator&&   operator||\n\nRationale\n\nThis rule helps to ensure that both operands of a op b are treated identically in terms of conversions.\n\nIf operator+ for class C is implemented as a member (e.g. C operator+( C rhs ) const;), then \nthe left-hand value can only be of type C, whilst the compiler may implicitly convert right-hand operands \nof other types to C.\n\nFor example, if C has a constructor that takes an int value, then if c is a value of type C, c + 1 creates a \ntemporary object from C( 1 ) and adds it to c. Depending upon what other, if any, implicit conversions \nare available, 1 + c either results in a compilation error or it may call a diCerent function and give an \nentirely diCerent result to c + 1. This inconsistent behaviour is undesirable.\n\nNote: this rule permits a non-member operator to be declared as a hidden friend (i.e. a friend function \ndefined in the class). Hidden friend operators are only considered for overload resolution by argument-\ndependent lookup when the compiler has a class object as one of the operands, making it less likely \nthat the wrong overload is selected due to the implicit conversion of both operands. The use of hidden \nfriends for such operators is generally considered to be good practice.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nExample\n\nThe constructor in the following example violates"
  },
  {
    "rule": "Rule 15.1.3. \n\nclass C\n{\n  int32_t i;\n\npublic:\n  C( int32_t x = 0 ): i( x ) {}\n\n  C operator+( C rhs ) const;           // Non-compliant\n  C operator+( int32_t rhs ) const;     // Non-compliant\n  C operator and( C rhs ) const;        // Non-compliant\n\n  friend C operator*( C lhs, C rhs );   // Compliant - non-member friend\n\n  friend C operator-( C lhs, C rhs )    // Compliant - hidden friend\n  {\n    return C( lhs.i - rhs.i );\n  }\n\n  friend std::ostream &\n    operator<<( std::ostream & os,\n                     C const & c );     // Rule does not apply - not symmetrical\n  C & operator/=( C const & rhs );      // Rule does not apply - not symmetrical\n};\n\nC operator/( C lhs, C rhs );            // Compliant - non-member\nC operator*( C lhs, C rhs );            // Compliant - non-member friend\n\nint main()\n{\n  C c( 21 );\n\n  std::cout << (  c + 1 ) << '\\n';\n//std::cout << (  1 + c ) << '\\n';  // Would fail to compile\n  std::cout << (  c * 4 ) << '\\n';\n  std::cout << (  4 * c ) << '\\n';\n  std::cout << ( 84 / c ) << '\\n';\n}\n\n4.17\n\nTemplates\n\n4.17.8 Function template specialization \n\n [temp.fct.spec]"
  },
  {
    "rule": "Rule 17.8.1\n\nFunction templates shall not be explicitly specialized\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule also applies to member function templates, but not non-template member functions of class \ntemplates.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n169\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nRationale\n\nExplicit function specializations will be considered only after overload resolution has chosen a best  \nmatch from the set of primary function templates. Furthermore, when the overload set contains both \ntemplate and non-template versions that are otherwise an equal match for overload resolution, the \ntemplate version (and therefore its specializations) will not be selected. All of this may be inconsistent \nwith developer expectations. \n\nNote: overloads provide a better solution than the use of explicit function specializations.\n\nn\ne\ns\n\nExample\n\ntemplate< typename T > void f1( T );      // Overload # 1A\ntemplate<> void f1< char * >( char * );   // Non-compliant - explicit\n                                          // \ntemplate< typename T > void f1( T * );    // Overload # 1B\n\nspecialization of overload # 1A\n\ntemplate< typename T > void f2( T   );    // Overload # 2A\ntemplate< typename T > void f2( T * );    // Overload # 2B\nvoid f2( char * );                        // Overload # 2C - rule does not apply\n\ntemplate< typename T > void f3( T );\ntemplate<> void f3< char * >( char * );   // Non-compliant - explicit\n                                          // \n\nspecialization of f3\n\nvoid b( char * s )\n{\n  f1( s );                                // Calls overload # 1B, with T = char\n  f2( s );                                // Calls overload # 2C\n}\n\n4.18\n\nException handling\n\nExceptions provide a way of transferring control to a point in the program higher up in the call stack. \nThey are designed to handle exceptional situations such as unexpected errors.\n\nCode must be designed to behave correctly if exceptions are thrown during execution, otherwise an \nexception may result in issues such as resource leaks, an invalid program state and unexpected  \nprogram termination. Compliance with the rules in this section helps to prevent the inappropriate use \nof exceptions and ensures that the code is more robust if exceptions are raised. In addition,"
  },
  {
    "rule": "Rule\n21.6.2, and more generally the use of the RAII idiom, ensures that resources are not leaked in the \npresence of exceptions.\n\nLike all error handling mechanisms, exceptions have execution time and code size costs. For instance, \nthe stack unwinding that is required for exception handling is often implemented using complex  \nstate machines, and most C++ compilers generate code that indirectly invokes  malloc  to allocate \nheap memory for exception objects.\n\nDue to the complexity of the usual implementations and the allocation of heap memory, it is generally \nnot possible to predict safe and precise upper bounds for the worst-case execution time of exception \nhandling. Therefore, it may be preferable to avoid throwing exceptions in hard real-time code that  \nmust guarantee execution deadlines.\n\nMost compilers provide options (such as -fno-exceptions) that can be used to disable exceptions \nin order to eliminate the code and size overheads mentioned above.\n\nDisabling exceptions means that it will probably not be possible to comply with some of the rules within \nthis section and others \u2014 for example, it might not be possible to provide the exception handler  \nrequired by"
  },
  {
    "rule": "Rule 18.3.1. A number of deviations may therefore be needed, with the supporting \ndocumentation being used to demonstrate how the related issues are to be prevented. For example, \nexceptions that are thrown by the C++ Standard Library will probably lead to immediate program  \n\n170\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\ntermination, and it needs to be demonstrated that any use of the C++ Standard Library will not result  \nin an exception being thrown, or that any termination is handled appropriately.\n\nNote: disabling exceptions is a language extension, requiring a deviation against"
  },
  {
    "rule": "Rule 4.1.1.\n\n4.18.1 Throwing an exception \n\n [except.throw]"
  },
  {
    "rule": "Rule 18.1.1 An exception object shall not have pointer type\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nIf an exception object of pointer type is thrown and that pointer refers to a dynamically created object,  \nthen it may be unclear which function is responsible for destroying it, and when. This ambiguity does \nnot exist if the object is thrown by value.\n\nExample\n\nclass A\n{\n  // Implementation\n};\n\nvoid fn( int16_t i )\n{\n  static A   a1;\n         A * a2 = new A;\n\n  if ( i > 10 )\n  {\n    throw &a1;              // Non-compliant - pointer type thrown\n  }\n\n  else\n  {\n    throw a2;               // Non-compliant - pointer type thrown\n  }\n}\n\nSee also"
  },
  {
    "rule": "Rule 18.3.2\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n171\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 18.1.2 An empty throw shall only occur within the compound-statement of a \n\ncatch handler\n\n[expr.throw]\n[except.handle] Implementation 9\n[except.terminate] Implementation 2\n\nCategory Required\n\nn\ne\ns\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nAn empty throw is a throw-expression with no operand. \n\nFor the purposes of this rule, the body of a lambda declared within the compound-statement of a catch \nhandler is not considered to be part of the catch handler.\n\nRationale\n\nAn empty throw re-throws the temporary object that represents an exception. Its use is intended to \nenable the handling of an exception to be split across two or more handlers.\n\nSyntactically, there is nothing to prevent an empty throw from being used outside a catch handler. \nHowever, this would result in implementation-defined program termination when there is no exception \nobject to re-throw.\n\nExample\n\nvoid f1( void )\n{\n  try\n  {\n    throw std::range_error( \"range error\" );\n  }\n\n  catch ( std::exception const & )\n  {\n    log( \"Caught in f1\" );\n\n    throw;                   // Compliant - re-throws an exception object\n  }\n}\n\nvoid f2( void )\n{\n  throw;                     // Non-compliant - not syntactically within a catch\n}\n\n172\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f4.18.3 Handling an exception \n\n [except.handle]\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS"
  },
  {
    "rule": "Rule 18.3.1\n\nThere should be at least one exception handler to catch all otherwise \nunhandled exceptions\n\n[except.terminate] Implementation 1.2, 1.10\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe function main should include a try-catch with a catch ( ... ) handler. \n\nThe catch handlers of this try-block, and any code within main that is outside of this try-block, should \nnot attempt to propagate an exception. To make this rule decidable, any call to a function having a  \npotentially-throwing exception speci%cation ([except.spec]/3) is assumed to propagate an exception.\n\nFor the purposes of this rule, where a development environment allows a function other than main \nto be nominated as the entry point of the program, that function shall be treated as if it were main.\n\nRationale\n\nIf a program throws an exception that is not caught, the program terminates in an implementation-\nde%ned manner. In particular, it is implementation-de%ned whether the call stack is unwound before \ntermination, meaning that some destructors may not be executed. By enforcing the provision of a \n\u201clast-ditch catch-all\u201d, the developer can ensure that the program terminates in a consistent manner.\n\nExample\n\nint main()                           // Compliant\n{\n  try\n  {\n    // Program code\n  }\n\n  catch ( specific_type & e )        // Optional, explicit handler(s) are permitted\n  {\n    // Handle expected exceptions \n  }\n\n  catch ( ... )                      // Catch-all handler should be provided\n  {\n    // Handle unexpected exceptions \n  }\n\n  return 0;\n}\n\nvoid logError( char const * message );\n\nint main()                           // Compliant\ntry\n{\n  // Program code\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n173\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n174\n\ncatch ( ... )                        // Catch-all handler\n{\n  try\n  {\n    logError( \"Unexpected\" );\n  }\n\n  catch (...)\n  {\n    // Logging also threw\n  }\n}\n\nint main()                           // Non-compliant - handler may throw\ntry\n{\n  // Program code\n}\n\ncatch ( ... )                        // Catch-all handler\n{\n  logError( \"Unexpected\");           // Potentially throwing function may lead to\n}                                    // an exception propagating from main\n\nSee also"
  },
  {
    "rule": "Rule 18.4.1,"
  },
  {
    "rule": "Rule 18.5.1,"
  },
  {
    "rule": "Rule 18.5.2"
  },
  {
    "rule": "Rule 18.3.2 An exception of class type shall be caught by const reference or \n\nreference\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nSlicing occurs if the exception object is of a derived class and it is caught by value as the base class,  \nwhich means that information unique to the derived class\u2019s members is lost. Slicing does not occur \nwhen the exception is caught by reference.\n\nException objects may be shared between threads, such as when an exception is thrown from \nstd::shared_future. In this case, catching by const reference reduces the chance of data races.\n\nExample\n\ntry\n{\n  mayThrow();\n}\ncatch ( std::runtime_error e )       // Non-compliant - slicing occurs\n{\n}\ncatch ( std::exception const & e )   // Compliant - exception object is complete\n{\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS"
  },
  {
    "rule": "Rule 18.3.3 Handlers for a function-try-block of a constructor or destructor shall \n\nnot refer to non-static members from their class or its bases\n\n[except.handle] Unde9ned 10\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nReferring to a non-static member of a class or a base class in the handler (i.e. the  catch part) of a \nfunction-try-block of a class constructor or destructor results in unde%ned behaviour.\n\nFor example, if a memory allocation exception is thrown during creation of the object, the object will \nnot exist when the handler attempts to access its members. Additionally, in the destructor, the object \nmay have been successfully destroyed before the exception is handled and it will not be available to  \nthe handler.\n\nExample\n\nclass C\n{\npublic:\n  int32_t x;\n\n  C()\n  try : x { mayThrow() }\n  {\n  }\n\n  catch ( ... )\n  {\n    if ( 0 == x )   // Non-compliant - x may not exist at this point\n    {\n    }\n  }\n\n  ~C()\n  try\n  {\n    // Action that may raise an exception\n  }\n\n  catch ( ... )\n  {\n    if ( 0 == x )   // Non-compliant - x may not exist at this point\n    {\n    }\n  } \n};\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n175\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n176\n\n4.18.4 Exception speci2cations \n\n [except.spec]"
  },
  {
    "rule": "Rule 18.4.1 Exception-unfriendly functions shall be noexcept\n\n[support.start.term] Implementation-de9ned 9.1\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe following functions are considered as  exception-unfriendly  and are required to be implicitly or \nexplicitly noexcept:\n\n1. Any function or constructor directly called (explicitly or implicitly) to initialize a non-constexpr, \n\nnon-local variable with static or thread storage duration;\n\n2. All destructors;\n\n3. All copy-constructors of an exception object;\n\n4. All move constructors;\n\n5. All move assignment operators;\n\n6. All functions named \u201cswap\u201d;\n\nAdditionally, the arguments passed to extern \"C\" functions std::set_terminate, std::atexit \nor std::at_quick_exit shall be convertible to function pointers to noexcept functions.\n\nThis rule does not apply to any member function de9ned as = delete.\n\nRationale\n\nWhen an exception is thrown, the call stack is unwound up to the point where the exception is to be  \nhandled. The destructors for all automatic objects declared between the point where the exception is \nthrown and where it is to be handled will be invoked. If one of these destructors exits with an exception,  \nthen the program will terminate in an implementation-defined manner. Requiring destructors to be \nnoexcept and enforcing"
  },
  {
    "rule": "Rule 18.5.1 ensures that std::terminate does not get called, as required \nby"
  },
  {
    "rule": "Rule 18.5.2.\n\nExceptions from destructors are also undesirable for objects that are at non-local scope or that are \ndeclared  static, as they are destroyed in a \u201cclose-down\u201d phase after  main  terminates. There is \nnowhere within the code that a handler can be placed to catch any exception that may be thrown, \nleading to a call to std::terminate. Similarly, non-local objects may be constructed before main \nstarts, meaning that any exception thrown during their construction cannot be caught.\n\nMost destructors are noexcept by default, meaning that the omission of an explicit noexcept-specifier \nis generally compliant.\n\nNote: this rule does not apply to the constructors of classes used to construct local objects with static  \nstorage duration, as these are constructed the 9rst time their owning function is called (i.e. after main \nhas started), allowing exceptions thrown by them to be caught.\n\nWhen an exception is thrown, the exception object is copy-initialized from the operand of the throw-\nexpression. If an exception is thrown during this copy, this is the exception that will be propagated, \nwhich may surprise developers. Furthermore, if a catch handler catches by value (which is prohibited \nby"
  },
  {
    "rule": "Rule 18.3.2), another copy-initialization will happen. If this throws, the program will terminate. It is \ntherefore better to ensure that exception objects\u2019 copy constructors do not throw.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nFunctions named \u201cswap\u201d are conventionally used as customization points for  std::swap. The C++ \nStandard Library containers and algorithms will not work correctly if swapping of two elements exits \nwith an exception.\n\nNon-throwing \u201cswap\u201d functions are also important when implementing the strong exception safety \nguarantee in a copy (or move) assignment operator. Similarly, move constructors and move assignment \noperators are usually expected to be non-throwing. If they are not declared   noexcept, strong \nexception safety is more difficult to achieve. Furthermore, algorithms may choose a different, possibly \nmore expensive, code path if move operations are not noexcept.\n\nFunctions passed as arguments to extern \"C\" functions are likely to be invoked from C code that is \nnot able to handle exceptions.\n\nThe C++ Standard states that if a function registered using std::atexit or std::at_quick_exit \nis called and exits with an exception, then std::terminate is called. The C++ Standard requires \nthat a terminate handler set via std::set_terminate must not return to its caller, including with \nan exception (see [terminate.handler]).\n\nExample\n\nclass C1\n{\npublic:\n  C1(){}                           // Compliant - never used at non-local scope\n\n  ~C1(){}                          // Compliant - noexcept by default\n};\n\nclass C2\n{\npublic:\n  C2(){}                           // Not noexcept - see declaration of c2 below\n  C2( C2 && other ) {}             // Non-compliant - move constructor\n\n  C2 & operator=( C2 && other );   // Non-compliant - move assignment\n\n  ~C2() noexcept( true ) {}        // Compliant\n\n  friend void swap( C2 &, C2 & );  // Non-compliant - function named swap\n};\n\nC2 c2;                             // Non-compliant - construction is non-local\n\nclass C3\n{\npublic:\n  C3(){}                           // Compliant - c3 in foo not in non-local scope\n\n  ~C3() noexcept( false ) {}       // Non-compliant\n};\n\nclass MyException : public std::exception       // Non-compliant - implicit copy\n{                                               // constructor is noexcept( false )\npublic:\n  MyException ( std::string const & sender );   // Rule does not apply\n  const char * what() const noexcept override;\n\n  std::string sender;\n};\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n177\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n178\n\nvoid foo()\n{\n  static C3 c3;                    // Compliant - constructed on first call to foo\n\n  throw MyException( \"foo\" );\n}\n\nvoid exit_handler1();              // Non-compliant - passed to atexit\n\nvoid exit_handler2() noexcept;     // Compliant - also passed to atexit\n\nint main()\n{\n  try\n  {\n    const int32_t result1 = std::atexit( exit_handler1 );\n    const int32_t result2 = std::atexit( exit_handler2 );\n    C1 c1;\n\n    foo();                         // Any exception thrown will be caught below\n  }\n  catch ( ... ) {}\n}\n\nextern \"C\"\n{\n  void f( void( *func )() );\n}\n\nf( [](){} );                       // Non-compliant - function passed to extern \"C\"\n\nSee also"
  },
  {
    "rule": "Rule 18.3.2,"
  },
  {
    "rule": "Rule 18.5.1,"
  },
  {
    "rule": "Rule 18.5.2\n\n4.18.5 Special functions \n\n [except.special]"
  },
  {
    "rule": "Rule 18.5.1 A noexcept function should not attempt to propagate an exception to \n\nthe calling function\n\n[except.terminate] Implementation 2\n\nCategory Advisory\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nA noexcept function attempts to propagate an exception when it directly or indirectly throws an  \nexception that is not caught within the function. Any exception that would escape the function causes  \nthe program to terminate.\n\nThis rule also applies to all functions that are implicitly noexcept.\n\nIf a function\u2019s exception-specifier is of the form noexcept( condition ), then the function is only \npermitted to throw an exception when the condition is false.\n\nA function\u2019s compliance with this rule is independent of the context in which it is called.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nRationale\n\nMarking a function noexcept or noexcept( true ) does not prevent an exception from being \nraised in the body of the function. However, if the function attempts to propagate an exception to a \ncalling function, the program will be terminated through a call to std::terminate. This results in \nimplementation-defined behaviour, including whether or not the stack is unwound before the program \nterminates (which may result in dangling resources).\n\nExample\n\nvoid mayThrow( int32_t x )\n{\n  if ( x < 0 )\n  {\n    throw std::exception {};\n  }\n}\n\nvoid notThrowing()\n{\n}\n\nvoid f1( int32_t x ) noexcept    // Compliant\n{\n  notThrowing();\n}\n\nvoid f2( int32_t x ) noexcept    // Compliant\n{\n  if ( x > 0 )                   // This guard ...\n  {\n    mayThrow( x );               // ... ensures the call to mayThrow cannot throw\n  }\n}\n\nvoid f3( int32_t x ) noexcept    // Non-compliant - even if f3 is only called in\n{                                // contexts where x > 0\n  mayThrow( x );\n}\n\nvoid f4( int32_t x ) noexcept    // Compliant - any exception will not propagate\n{\n  try\n  {\n    mayThrow( x );\n  }\n  catch( ... )\n  {\n  }\n}\n\nvoid f5( int32_t x ) noexcept    // Non-compliant - exception is rethrown \n{\n  try\n  {\n    mayThrow( x );\n  }\n  catch ( ... )\n  {\n    throw;\n  }\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n179\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n180\n\nInstantiations of the following template are compliant as they will only be noexcept( true ) when \nthe addition is non-throwing: \n\ntemplate< class T >                                 // Compliant\nT plus( T a, T b ) noexcept( noexcept( a + b ) )\n{\n  return a + b;\n}\n\nclass A\n{\n  ~A()\n  {\n    throw std::exception {};   // Non-compliant - destructor is implicitly noexcept\n  }\n};\n\nvoid f6( int32_t x ) throw()   // throw() makes function noexcept\n{\n  throw std::exception {};     // Non-compliant\n}"
  },
  {
    "rule": "Rule 18.5.2 Program-terminating functions should not be used\n\n[support.start.term] Implementation 3, 5, 9.1, 13\n[except.terminate] Implementation 2\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA program should not contain calls to the C++ Standard Library functions abort, exit, _Exit, \nquick_exit or terminate. Additionally, the address of any of these functions should not be taken.\n\nRationale\n\nIf a program terminates due to a call to any of the functions listed above, then the stack will not be  \nunwound and object destructors will not be called. This will potentially leave the environment in an \nundesirable state (e.g. a 9le permanently locked).\n\nTaking the address of the functions is not recommended to prevent them from being called via a  \nfunction pointer.\n\nNotes:\n\n1. This rule only covers explicit calls to the termination functions. The majority of ways in which \n\nthey may be called implicitly are prevented by"
  },
  {
    "rule": "Rule 18.1.2,"
  },
  {
    "rule": "Rule 18.3.1 and"
  },
  {
    "rule": "Rule 18.5.1.\n\n2. This rule aims to prevent program-terminating functions from being called without the system \nlevel implications (such as unreleased resources) being duly considered. If the safety architecture \nrequires rapid termination on the detection of an error, then it may be appropriate to disapply \nthis rule.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nException\n\nThe call to abort that occurs due to the macro expansion of assert is not considered to be an \nexplicit call, as it is not expected to be reachable.\n\nNote: a project may consider disallowing this exception if the behaviour of  abort is not a suitable \nresponse to a failed assertion, such as when there is no external mechanism to recover the terminated \nprogram. \n\nSee also"
  },
  {
    "rule": "Rule 18.1.2,"
  },
  {
    "rule": "Rule 18.3.1,"
  },
  {
    "rule": "Rule 18.5.1\n\n4.19\n\nPreprocessing directives\n\n4.19.0 MISRA \n\n [misra]"
  },
  {
    "rule": "Rule 19.0.1 A line whose 9rst token is # shall be a valid preprocessing directive\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to all the lines within a translation unit, even if they are excluded by preprocessing.\n\nNote: white-space is permitted before and after the # token.\n\nRationale\n\nA preprocessor directive may be used to conditionally exclude source code until a corresponding  \n#else,  #elif  or  #endif  directive is encountered. A malformed or invalid preprocessing directive \ncontained within the excluded source code may not be detected by the compiler, possibly leading to \nthe exclusion of more code than was intended.\n\nRequiring all preprocessor directives to be syntactically valid, even when they occur within an excluded \nblock of code, ensures that this cannot happen.\n\nExample\n\nIn the following example all the code between the #ifndef and #endif directives may be excluded \nif AAA is defined. The developer intended that AAA be assigned to x, but the #else directive was \nentered incorrectly and not diagnosed by the compiler. \n\n#define AAA 2\n\nint32_t foo()\n{\n  int32_t x = 0;\n\n#ifndef AAA\n  x = 1;\n#else1        // Non-compliant\n  x = AAA;\n#endif\n\n  return x;\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n181\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n182\n\nThis rule does not apply to the following examples as the # is not a preprocessing token: \n\n// Not a preprocessing token within a comment \\\n#not a token\n\nauto s = R\"(\n#text)\";      // Use in a raw string literal is not a preprocessing token"
  },
  {
    "rule": "Rule 19.0.2\n\nFunction-like macros shall not be de9ned\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nFunctions have a number of advantages over function-like macros, including:\n\n\u25cf Function arguments and return values are type-checked;\n\n\u25cf Function   arguments   are   evaluated   once,   preventing   problems   with   potential   multiple   side \n\neCects;\n\n\u25cf Function names follow classical scoping rules;\n\n\u25cf Functions can be overloaded and templatized;\n\n\u25cf The address of a function can be passed to another function;\n\n\u25cf Function calls can be inlined, providing the same performance characteristics as macros;\n\n\u25cf constexpr functions can be evaluated at compile-time and may be used in all contexts where \n\na compile-time constant is required;\n\n\u25cf In many debugging systems, it is easier to step through execution of a function than a macro.\n\nException\n\nAs it is not possible to implement equivalent behaviour within a function, a function-like macro may  \nbe de9ned if its de9nition includes any of the following:\n\n1. __LINE__, __FILE__ or __func__;\n\n2. The # or ## operators.\n\nExample\n\n#define FUNC( X ) \\\n  ( ( X ) + ( X ) )             // Non-compliant\n\ntemplate< typename T >\nconstexpr auto func( T x )      // Possible alternative\n{\n  return x + x;\n}\n\nThe following examples are compliant by exception: \n\n#define ID( name ) \\\n  constexpr auto name = #name;  // Compliant - use of #\n\n#define TAG( name ) \\\n  class name##Tag {};           // Compliant - use of ##\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n#define LOG( message ) \\\n  log( __func__, message );     // Compliant - use of __func__\n\nSee also"
  },
  {
    "rule": "Rule 19.3.1"
  },
  {
    "rule": "Rule 19.0.3 #include directives should only be preceded by preprocessor \n\ndirectives or comments\n\n[using.headers]\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule shall be applied to the contents of a 9le before preprocessing occurs.\n\nFor purposes of this rule, the tokens used to open and close a linkage-speci%cation are ignored.\n\nRationale\n\nTo aid code readability, all of the #include directives in a particular code file should be grouped \ntogether near the top of the 9le.\n\nAdditionally, using #include to include a standard header file within a declaration or definition, or \nusing part of the C++ Standard Library before the inclusion of the related standard header %le results \nin unde%ned behaviour.\n\nExample\n\n// f.h\nxyz = 0;\n\n// f.cpp\nint16_t             // No more includes allowed in f.cpp after this code\n#include \"f.h\"      // Non-compliant\n\n// f1.cpp\n#define F1_MACRO\n#include \"a.h\"      // Compliant\n\nextern \"C\"          // Linkage-specification tokens are ignored\n{                   // Linkage-specification token is ignored\n  #include \"b.h\"    // Compliant\n}                   // Linkage-specification token is ignored\n\n#include \"c.h\"      // Compliant\n\nextern \"C\"          // Linkage-specification tokens are ignored\n{                   // Linkage-specification token is ignored\n  #include \"d.h\"    // Compliant\n\n  void g();         // No more includes allowed in f1.cpp after this code\n}                   // Linkage-specification token is ignored\n\n#include \"e.h\"      // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n183\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:"
  },
  {
    "rule": "Rule 19.0.4 #undef should only be used for macros de9ned previously in the \n\nsame 9le\n\n[cpp.prede9ned] Unde9ned 4\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nn\ne\ns\n\nRationale\n\nSince macros are not subject to the usual scoping rules of the language, complex use of  #undef can \nlead to confusion with respect to the existence or meaning of a macro when it is used in the code.  \nHowever, it might be desirable to limit the number of active macros at any point in the code to help  \nprevent inappropriate use; if a macro is only required for a speci9c purpose, a common idiom is to \n#define it, use it and #undef it immediately afterwards.\n\nPermitting #undef to be used for macros that are defined in the same file enables the scope of those  \nmacros to be restricted whilst preventing complex uses that could lead to confusion.\n\nNote: unde9ning a macro de9ned by the C++ Standard Library can result in unde%ned behaviour.\n\nExample\n\n// File.cpp\n\n#include \"A.h\"       // This header defines the macro M\n#undef M             // Non-compliant - defined in another file\n\n#define ID( name ) constexpr auto name = #name\n\nID( IdA );\nID( IdB );\n\n#undef ID            // Compliant - defined in this file\n\n4.19.1 Conditional inclusion \n\n [cpp.cond]"
  },
  {
    "rule": "Rule 19.1.1\n\nThe defined preprocessor operator shall be used appropriately\n\n[cpp.cond] Unde9ned 8\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe only two forms for the defined preprocessor operator that are permitted by the C++ Standard \nare: \n\ndefined ( identifier )\ndefined   identifier\n\nGeneration of the token defined during expansion of a macro within a #if or #elif preprocessing \ndirective is not permitted.\n\nRationale\n\n184\n\nViolation of this rule results in unde%ned behaviour.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nExample\n\n#if defined 1                                 // Non-compliant - 1 is not an\n                                              //                 identifier\n#define FEATURE(x) defined(x) && ( x != 0 )\n#if FEATURE(X)                                // Non-compliant - defined resulting\n                                              //                 from expansion\n#if defined(x) && ( x != 0 )                  // Compliant"
  },
  {
    "rule": "Rule 19.1.2 All #else, #elif and #endif preprocessor directives shall reside in \nthe same 9le as the #if, #ifdef or #ifndef directive to which they \nare related\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nConfusion can arise when code blocks are included or excluded by the use of conditional compilation \ndirectives which are spread over multiple 9les. Requiring that a #if directive be terminated within \nthe same file reduces the visual complexity of the code and the chance that errors will be made during  \nmaintenance.\n\nNotes:\n\n1. #if directives may be used within included 9les, provided they are terminated within the same \n\n9le.\n\n2.\n\nIt is not clear from the C++ Standard whether such constructs are allowed. Some compilers \ndo require that a #endif (etc.) must be in the same file as the associated  #if (etc.), and \nall compilers tested raise an error if this is not the case. However, this requirement is not  \nexplicitly expressed in the C++ Standard, and there is a reading of the grammar that would allow \nit. This rule aims to prevent this construct, should any compiler actually allow it.\n\nExample\n\n// file1.c\n#ifdef A               // Compliant\n#include \"file1.h\"\n#endif\n// End of file1.c\n\n// file1.h\n#if 1                  // Compliant\n#endif\n// End of file1.h\n\n// file2.c\n#if 1                  // Non-compliant\n#include \"file2.h\"\n// End of file2.c\n\n// file2.h\n#endif\n// End of file2.h\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n185\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 19.1.3 All identi9ers used in the controlling expression of #if or #elif \n\npreprocessing directives shall be de9ned prior to evaluation\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nn\ne\ns\n\nAs well as using a #define preprocessor directive, macro names may eCectively be de9ned in other \nimplementation-de%ned, ways. For example some implementations support:\n\n\u25cf Using a compiler command-line option, such as -D, to allow macros to be defined prior to \n\ntranslation;\n\n\u25cf Pre-de9ned macros provided by the compiler.\n\nRationale\n\nIf an attempt is made to use an identi9er in a preprocessor directive, and that identi9er has not been \nde9ned as a macro name, then the preprocessor will assume that it has a value of zero. This may not \nmeet developer expectations.\n\nExample\n\nThe following example assumes that the identi9er M is not de9ned as a macro name. \n\n#if M == 0        // Non-compliant\n#endif\n\n#if defined( N )  // Compliant - N is not evaluated, even if not a macro\n#if N == 0        // Compliant - N is known to be defined at this point\n#endif\n#endif\n\n// Compliant - B is only evaluated in ( B == 0 ) if it is defined\n#if defined( B ) && ( B == 0 )\n#endif\n\n4.19.2 Source 2le inclusion \n\n [cpp.include]"
  },
  {
    "rule": "Rule 19.2.1 Precautions shall be taken in order to prevent the contents of a \n\nheader %le being included more than once\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nIn order to facilitate checking, the contents of the header %le shall be protected from being included \nmore than once using one of the following two forms of include guard: \n\n<start-of-file>\n#if !defined ( IDENTIFIER )\n#define IDENTIFIER\n  // Contents of file\n#endif\n<end-of-file>\n\n186\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n<start-of-file>\n#ifndef IDENTIFIER\n#define IDENTIFIER\n  // Contents of file\n#endif\n<end-of-file>\n\nNotes:\n\n1. The identifier used to test and record whether a given header file has already been included \n\nshall be unique across all the header %les included within the translation unit;\n\n2. Comments are permitted anywhere within these forms.\n\nRationale\n\nWhen a translation unit contains a complex hierarchy of nested header files, it is possible for a particular \nheader %le to be included more than once. This can be, at best, a source of confusion. If this multiple  \ninclusion leads to multiple or con^icting de9nitions, then this can result in erroneous or undefined \nbehaviour.\n\nNote: implementations may provide other mechanisms to prevent multiple inclusion \u2014 for example \n#pragma once (use of which is restricted by"
  },
  {
    "rule": "Rule 19.6.1). However, their use is not permitted as they \nare not speci9ed within the C++ Standard.\n\nExample\n\n// file.h\n#ifndef FILE_H    // Non-compliant - no include guard in this file\n#define FILEH     // <-- this does not #define FILE_H\n#endif"
  },
  {
    "rule": "Rule 19.2.2\n\nThe #include directive shall be followed by either a <filename> \nor \"filename\" sequence\n\n[cpp.include] Unde9ned 4\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies after macro replacement has been performed.\n\nRationale\n\nUnde%ned behaviour occurs if a #include directive does not use one of the following forms: \n\n#include <filename>\n#include \"filename\"\n\nExample\n\n#include <filename.h>         // Compliant\n#include \"filename.h\"         // Compliant\n#include \"./include/cpu.h\"    // Compliant - filename may include a path\n#include another.h            // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n187\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n#define HEADER \"filename.h\"\n#include HEADER               // Compliant\n#define FILENAME file2.h\n#include FILENAME             // Non-compliant\n\n#define BASE \"base\"\n#define EXT  \".ext\"\n#include BASE EXT             // Non-compliant - expands to an invalid form\n                              //   #include \"base\" \".ext\"\n                              // - string concatenation occurs after preprocessing"
  },
  {
    "rule": "Rule 19.2.3\n\nThe ' or \" or \\ characters and the /* or // character sequences \nshall not occur in a header %le name\n\n[lex.header] Implementation 2\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nUse of the following are conditionally-supported with implementation-de%ned behaviour:\n\n\u25cf The ' or \" or \\ characters, and the /* or // character sequences are used between < and > \n\ndelimiters in a header %le name preprocessing token;\n\n\u25cf The ' or \\ characters, or the /* or // character sequences are used between the \" delimiters \n\nin a header %le name preprocessing token.\n\nNote: even on systems where \\ is the path separator, most implementations will accept the / character \nas an alternative.\n\nExample\n\n#include \"file.h\"       // Compliant\n#include \"fi'le.h\"      // Non-compliant\n#include \"path\\file\"    // Non-compliant\n#include \"path\\\\file\"   // Non-compliant\n#include \"path/file\"    // Compliant\n\n4.19.3 Macro replacement \n\n [cpp.replace]"
  },
  {
    "rule": "Rule 19.3.1\n\nThe # and ## preprocessor operators should not be used\n\n[cpp.stringize] Unspeci9ed 2\n[cpp.concat] Unspeci9ed 3\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThe order of evaluation associated with multiple #, multiple ## or a mix of # and ## preprocessor \noperators is unspeci9ed. It is therefore not always possible to predict the result of macro expansion.\n\nThe use of the ## operator can result in code that is hard to understand.\n\n188\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nNote:"
  },
  {
    "rule": "Rule 4.1.3 covers the unde%ned behaviour that arises if either:\n\n\u25cf The result of a # operator is not a valid string literal; or\n\n\u25cf The result of a ## operator is not a valid preprocessing token.\n\nSee also"
  },
  {
    "rule": "Rule 4.1.3,"
  },
  {
    "rule": "Rule 19.3.2,"
  },
  {
    "rule": "Rule 19.3.3"
  },
  {
    "rule": "Rule 19.3.2 A macro parameter immediately following a # operator shall not be \n\nimmediately followed by a ## operator\n\n[cpp.stringize] Unspeci9ed 2\n[cpp.concat] Unspeci9ed 3\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThe order of evaluation associated with multiple #, multiple ## or a mix of # and ## preprocessor \noperators is unspeci9ed. The use of # and ## is discouraged by"
  },
  {
    "rule": "Rule 19.3.1. In particular, the result of \na # operator is a string literal and it is unlikely that pasting this to any other preprocessing token will  \nresult in a valid token.\n\nExample\n\n#define A( x )      #x         // Compliant\n#define B( x, y )   x ## y     // Compliant\n#define C( x, y )   x ## #y    // Compliant\n#define D( x, y )   #x ## y    // Non-compliant\n\nSee also"
  },
  {
    "rule": "Rule 19.3.1,"
  },
  {
    "rule": "Rule 19.3.3"
  },
  {
    "rule": "Rule 19.3.3\n\nThe argument to a mixed-use macro parameter shall not be subject \nto further expansion\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nA mixed-use macro parameter is a macro parameter that is used both:\n\n\u25cf As an operand to # or ##; and\n\n\u25cf Not as an operand to these operators.\n\nThis rule prohibits invoking a macro with a mixed-use macro parameter when the corresponding macro \nargument is itself subject to further macro replacement.\n\nRationale\n\nA macro parameter that is used as an operand of a # or ## operator is not expanded prior to being \nused, whilst the same parameter appearing elsewhere in the replacement text is expanded. This  \n\n189\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n190\n\ncauses a macro to exhibit diCerent behavior depending on whether or not its arguments are subject  \nto macro replacement.\n\nExample\n\nIn the macro SCALE, X is a mixed-use macro parameter. \n\n#define SCALE( X ) ( ( X ) * X ## _scale )\n\nint32_t speed;\nint32_t speed_scale;\n\nint32_t scaled_speed = SCALE( speed );  // Compliant - speed not expanded\n                                        // SCALE expands to\n                                        // ( ( speed ) * speed_scale )\n\n#define AA BB\nint32_t AA_scale = 1;\nint32_t BB = 42;\nint32_t BB_scale = 2;\n\nint32_t scaled_AA = SCALE( AA );        // Non-compliant - AA is expanded further\n                                        // SCALE expands to ( (BB) * AA_scale )\n                                        // User might expect ( (BB) * BB_scale )\n\nThe rule does not apply to expansions of the following macro as the parameter Y is not a mixed-use  \nmacro parameter.\n\n#define CC( Y ) ( var1 ## Y + var2 ## Y )\n\nSee also"
  },
  {
    "rule": "Rule 19.3.1,"
  },
  {
    "rule": "Rule 19.3.2"
  },
  {
    "rule": "Rule 19.3.4 Parentheses shall be used to ensure macro arguments are \n\nexpanded appropriately\n\n[Koenig] 78\u201381\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nFor the purposes of this rule, a critical operator is an operator that has a ranking between 2 and 13 \n(inclusive), as speci9ed in the table to"
  },
  {
    "rule": "Rule 8.0.1.\n\nA macro argument containing a top-level token (see definition below) that expands as a critical operator \nis inappropriately expanded if, within the macro de9nition, there is an occurrence of the corresponding \nmacro parameter that is not:\n\n\u25cf Directly parenthesized (a parameter x is directly parenthesized in ( x )); or\n\n\u25cf Stringi9ed (used as an operand to the # operator).\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nWhen a macro is expanded, a level can be associated with every token in the expansion of a macro \nargument. For each argument, the level of its 9rst token is zero, and then the level of each of its  \nsubsequent tokens relative to the level of the previous token is:\n\n\u25cf One more, if the previous token is (\n\n\u25cf One less, if the previous token is )\n\n\u25cf The same, for any other previous token.\n\nA token is said to be top-level when its level is less than or equal to zero.\n\nRationale\n\nWhen a macro is invoked with an argument that looks like an expression, it is generally assumed that \nthis expression will behave as if it were an argument to a function call \u2014 in particular, that it will be  \nevaluated in isolation.\n\nHowever, since macro expansion result in textual replacement, a macro parameter is simply replaced \nby the text corresponding to the argument. This means that the diCerent tokens that form the  \nargument can end up forming parts of diCerent sub-expressions. This typically happens when the  \nargument contains an operator having a low precedence, and the parameter is expanded next to an \noperator having a higher precedence. This behaviour can generally be avoided by adding parentheses \naround the macro parameter.\n\nExample\n\nIn the following example, the operator + is a top-level token in the x argument to the macro. However, x \nis neither parenthesized nor stringi9ed in the macro de9nition. The value of the resulting expression \nis 7, whereas the value 9 might have been expected. \n\n#define M1( x, y ) ( x * y )\n\nr = M1( 1 + 2, 3 );                   // Non-compliant - x not parenthesized\n                                      // Expands as r = ( 1 + 2 * 3 );\n\nIdeally, the above can be re-written in a compliant manner by parenthesizing the macro parameters \nin the macro de9nition: \n\n#define M2( x, y ) ( ( x ) * ( y ) )\n\nr = M2( 1 + 2, 3 );                   // Compliant - x is directly parenthesized\n                                      // Expands as r = ( ( 1 + 2 ) * ( 3 ) );\n\nIf this is not possible, it is also acceptable to parenthesize the macro argument: \n\nr = M1( ( 1 + 2 ), 3 );               // Compliant - operator + is not top-level\n                                      // Expands as r = ( ( 1 + 2 ) * 3 );\n\nIn the following example, the macro M1 is invoked with 1 + 2 as its x parameter, and the top level + \ntoken is a critical operator. Therefore, x is inappropriately expanded, as it is neither parenthesized \nnor stringi9ed in the macro de9nition. \n\n#define M3( z ) z + 2\n\nr = M1( M3( 1 ), 3 );                 // Non-compliant - operator + is top-level\n                                      // Expands as r = ( 1 + 2 * 3 );\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n191\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nGiven the macro de9nition: \n\n#define MY_ASSERT( cond )                 \\\n  do                                      \\\n  {                                       \\\n    if ( !cond )                          \\\n    {                                     \\\n      std::cerr << #cond << \" failed!\\n\"; \\\n      std::abort();                       \\\n    }                                     \\\n  } while( false )\n\nand its use: \n\nint32_t x = 0;\n\nMY_ASSERT( x < 42 );  // Non-compliant - argument expansions result in:\n                      //   if ( !x < 42 ) - neither parenthesized nor stringified\n                      //   \"!x < 42\"      - stringified\n\nDuring expansion of  MY_ASSERT, the  cond  parameter is replaced by the argument  x < 42. This \nargument includes < as a top-level token that expands as a critical operator, which means that all \noccurrences of cond in the macro definition have to be checked for compliance. Within the macro,  \ncond is used:\n\n1. As the operand to #, which is compliant as it is stringi9ed; and\n\n2. Within if( !cond ), which is non-compliant as it is neither parenthesized nor stringified \u2014 the \nmacro expansion will contain if ( !x < 42 ), which is true for any value of x (which is equivalent \nto if ( ( !x ) < 42 )).\n\nSimilarly, MY_ASSERT( a or b ) would also be non-compliant as the rule applies irrespective of the \nway in which an operator is spelled.\n\nThe following example is compliant as the < and > tokens are not operators in the expanded code. \n\n#define PROP( Type, Name ) \\\n Type Name;                \\\n Type get_##Name() { return Name; }\n\nstruct Student\n{\n  PROP( vector< int32_t >, grades );\n}\n\nSee also"
  },
  {
    "rule": "Rule 8.0.1,"
  },
  {
    "rule": "Rule 19.0.2"
  },
  {
    "rule": "Rule 19.3.5\n\nTokens that look like a preprocessing directive shall not occur within \na macro argument\n\n[cpp.replace] Unde9ned 11\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nA macro argument containing sequences of tokens that would otherwise act as preprocessing  \ndirectives results in unde%ned behaviour.\n\n192\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nExample\n\n#define M(A) printf ( #A )\n\nint main()\n{\n   M(\n#ifdef SW        // Non-compliant\n   \"Message 1\"\n#else            // Non-compliant\n   \"Message 2\"\n#endif           // Non-compliant\n    );\n}\n\nThe above could print:\n\n#ifdef SW \"Message 1\" #else \"Message 2\" #endif\n\nor it could print:\n\nMessage 2\n\nor it could exhibit some other behaviour.\n\n4.19.6 Pragma directive \n\n [cpp.pragma]"
  },
  {
    "rule": "Rule 19.6.1\n\nThe #pragma directive and the _Pragma operator should not be \nused\n\n[cpp.pragma] Implementation 1\n[cpp.pragma.op] 1\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThe eCects of the #pragma directive and the _Pragma operator are implementation-de%ned.\n\nExample\n\n#pragma once                    // Non-compliant\n\n#define P( x ) _Pragma( #x )    // Non-compliant\n\n_Pragma( \"once\" )               // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n193\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\n4.21\n\nLanguage support library\n\n4.21.2 Common de2nitions \n\n [support.types]"
  },
  {
    "rule": "Rule 21.2.1\n\nThe library functions atof, atoi, atol and atoll from <cstdlib> \nshall not be used\n\nn\ne\ns\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\n[C11] / 7.22.1; Unde9ned 1\n\nThese functions shall not be called or have their addresses taken, and no macro having one of these \nnames shall be expanded. \n\nNote: the same functions from <stdlib.h> are also covered by this rule.\n\nRationale\n\nThese functions have undefined behaviour associated with them when the string cannot be converted. \nThe C++ library provides safer conversion routines \u2014 see [string.conversions], [charconv.from.chars]. \n\nNote: [charconv.from.chars] was changed from [utility.from.chars] as the result of a defect report  \nagainst the C++ Standard. \n\nExample\n\nint32_t f( const char * numstr )\n{\n  return atoi( numstr );          // Non-compliant\n}"
  },
  {
    "rule": "Rule 21.2.2\n\nThe string handling functions from <cstring>, <cstdlib>, \n<cwchar> and <cinttypes> shall not be used\n\n[cstring.syn]\n[cerrno.syn] \n[C11] / 7.1.4; Unde9ned 1\n[C11] / 7.24.1; Unde9ned 1\n[C11] / 7.29.4; Unde9ned 1\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe string handling functions are: \n\nFrom <cstring>\n\nFrom <cstdlib>\n\nstrcat\nstrerror\nstrrchr\n\nstrtol\nstrtold\n\n194\n\nstrchr\nstrlen\nstrspn\n\nstrcmp\nstrncat\nstrstr\n\nstrcoll\nstrncmp\nstrtok\n\nstrcpy\nstrncpy\nstrxfrm\n\nstrcspn\nstrpbrk\n\nstrtoll\n\nstrtoul\n\nstrtoull\n\nstrtod\n\nstrtof\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nFrom <cstring>\n\nFrom <cwchar>\n\nstrcat\nstrerror\nstrrchr\n\nfgetwc\nwcstod\n\nstrchr\nstrlen\nstrspn\n\nfputwc\nwcstof\n\nstrcmp\nstrncat\nstrstr\n\nwcstol\nwcstold\n\nstrcoll\nstrncmp\nstrtok\n\nstrcpy\nstrncpy\nstrxfrm\n\nstrcspn\nstrpbrk\n\nwcstoll\n\nwcstoul\n\nwcstoull\n\nFrom <cinttypes>\n\nstrtoumax strtoimax wcstoumax wcstoimax\n\nThese functions shall not be called or have their addresses taken, and no macro having one of these \nnames shall be expanded. \n\nNote: the same functions from <string.h>, <stdlib.h>, <wchar.h> and <inttypes.h> are also \ncovered by this rule.\n\nRationale\n\nIncorrect use of some string handling function may result in a read or write access beyond the bounds \nof an object passed as a parameter, resulting in undefined behaviour. Also, some string handling \nfunctions only report errors through the use of errno, which is a fragile mechanism \u2014 a non-zero \nvalue may reveal an error in any function that was called between the last point the value  0 was \nassigned to errno and the current point.\n\nIn all cases, the features provided by these functions can be obtained through other C++ Standard  \nLibrary features which are less error-prone.\n\nExample\n\nvoid f1( char * buffer, size_t bufferSize )\n{\n  char const * str = \"Msg\";\n\n  if ( ( strlen( str ) + 1u ) < bufferSize )      // Non-compliant\n  {\n    ( void ) strcpy( buffer, str );               // Non-compliant\n  }\n}\n\nThe following example performs the same operations in a compliant way:\n\nvoid f2( char * buffer, size_t bufferSize )\n{\n  std::string_view str = \"Msg\";\n\n  if ( str.size() + 1u < bufferSize )\n  {\n    str.copy( buffer, str.size() );\n    buffer[ str.size() ] = 0;\n  }\n}\n\nSee also"
  },
  {
    "rule": "Rule 8.7.1\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n195\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 21.2.3\n\nThe library function system from <cstdlib> shall not be used\n\n[C11] / 7.22.4.8; Unde9ned 2; Implementation 2, 3\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nn\ne\ns\n\nThis function shall not be called or have its address taken, and no macro having this name shall be  \nexpanded. \n\nNote: this rule also applies to system from <stdlib.h>. \n\nRationale\n\nThe system function has unde%ned and implementation-de%ned behaviour associated with it. \n\nErrors related to its use are a common cause of security vulnerabilities."
  },
  {
    "rule": "Rule 21.2.4\n\nThe macro offsetof shall not be used\n\n[support.types.layout] Unde9ned 1\n[C11] / 7.19; Unde9ned 3\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThe offsetof macro is used to access the underlying representation of an object, breaking its \nencapsulation. In addition, its use results in unde%ned behaviour when the speci9ed member is a bit-\n9eld, a static data member, or a member function.\n\nExample\n\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1()\n{\n  offsetof( A, i );      // Non-compliant\n}\n\n4.21.6 Dynamic memory management \n\n [support.dynamic]\n\nC++ allows the construction of objects with dynamic storage duration (see [basic.stc.dynamic]). Dynamic \nmemory may be used explicitly within a program (e.g. sharing or transmitting data across threads in \nfutures and promises), but implicit uses may also occur (e.g. exception handling, containers, run-time \ntype information (RTTI), type erasure with std::function). Because of this, only a limited number of  \nprograms are able to completely avoid the use of dynamic memory. In addition, custom memory  \nallocation is not fully supported in all case, making it hard for a program to have complete control over \nthe use of dynamic memory.\n\n196\n\nThis section enumerates a number of potential issues with the use of dynamic memory, and offers \nsome advice on how these can be mitigated within a program.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\f4.21.6.1 Terminology\n\nDefault allocator\n\nThe default definition for the global new allocation and delete deallocation functions, the malloc and \nfree functions provided by the system, as well as std::allocator.\n\nCustom allocator\n\nAny custom implementation of allocation or deallocation functions, in the form of:\n\n\u25cf A replacement de9nition of the global new or delete functions; or\n\n\u25cf An implementation of the std::pmr::memory_resource interface; or\n\n\u25cf Some other form.\n\nLocal allocator\n\nA custom allocator that is accessible through a local reference to an allocator object, but not via global \nfunctions. For example,  std::pmr::monotonic_buffer_resource  is typically used as a local \nallocator, while the object returned by std::pmr::new_delete_resource is not a local allocator.\n\nFragmentation\n\nECects which lead to ine[cient or wasteful use of memory. \n\n\u25cf External fragmentation occurs when free regions of memory are scattered in a way that large \ncontiguous regions of memory become harder or impossible to 9nd. This may prevent an  \nallocation request from succeeding, even though the total amount of free memory is larger than \nthe size requested for the allocation. External fragmentation has a negative eCect on execution \ntimes.\n\n\u25cf Internal fragmentation occurs when an allocator reserves a bigger block of memory than \nrequested, increasing the total amount of consumed memory. The extra memory is not \navailable for use by further allocations and thus is eCectively wasted. Internal fragmentation \nhas no direct, negative eCect on execution times, and often occurs when using a local allocator  \nthat has been designed to give deterministic execution times.\n\n4.21.6.2 Potential safety issues with dynamic memory\n\nMemory management defects\n\nEach dynamically allocated object should be deallocated exactly once and must not be used after \ndeallocation. Failure to do so can lead to a number of undesirable behaviours:\n\n1. Memory leaks \u2014 Failure to delete dynamically allocated objects can prevent the system from \nreclaiming the memory for other uses. While this is not necessarily a critical issue in and of  \nitself, it can lead to resource exhaustion, in particular when leaking memory obtained from a  \ndefault allocator. Since destructors of leaked objects are usually not executed, leaks can also  \nresult in a corruption of the logical program state.\n\n2. Double-delete \u2014 Attempting to delete the same memory block twice results in   undefined \n\nbehaviour.\n\n3. Passing an invalid pointer to a deallocation function \u2014 This results in unde%ned behaviour, and \nincludes the case where a pointer that was obtained from one allocator is passed to the  \ndeallocation function of another. Mixing the plain and array forms of the default allocator ( new \nor delete and new[] or delete[]) is a common example.\n\n4. Use-after-free \u2014 Dereferencing a pointer to an object that has already been deleted results in \nundefined behaviour. Note that dereferencing a pointer to an object with automatic storage \nduration that has gone out of scope also results in unde%ned behaviour.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n197\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nNote: similar issues also apply to other kinds of system-provided resources (e.g. 9le-handles, locks, \u2026), \nand mitigation mechanisms are also necessary when they are used.\n\nResource exhaustion\n\nThe total amount of memory that can be provided by the system is limited. Memory exhaustion errors  \nare difficult to recover from within an application, as the recovery path has to operate under conditions \nwhere it is not possible to allocate additional memory.\n\nCertain properties of the default allocator can make memory exhaustion errors more difficult to  \ndiagnose. For example, default allocator implementations backed by virtual memory may never fail  \nduring memory allocation. Exceeding the amount of available physical memory may not be diagnosed \nby the allocator, in which case the issue will only surface on the first attempt to access an area of  \nmemory that cannot be backed by physical memory. The behaviour will depend on the implementation.\n\nExternal fragmentation may lead to an allocation failure, as a single block of contiguous memory may \nnot be available, even though the total amount of free memory is still much larger than the amount  \nrequested. Internal fragmentation may result in a memory requirement that is larger than the sum of \nthe sizes of the individual allocations \u2014 this needs to be taken into account when determining the  \noverall memory requirements of the system.\n\nNon-deterministic execution times\n\nIt is generally not possible to determine how long the calls to allocation and deallocation functions will  \ntake at runtime:\n\n1. Algorithmic complexity \u2014 Many general-purpose allocator implementations are very complex, \nwith runtimes depending on numerous factors that are not known. For example, an allocation \ncall may need to traverse a free list to 9nd a memory block of suitable size, or a deallocation  \ncall may have to coalesce multiple, adjacent elements in a free list into a single, contiguous \nelement.\n\n2. Shared global state \u2014 The default allocator is a global variable, whose state is manipulated by \ncalls from all over the program. Using the default allocator or a shared allocator object makes \nit di[cult to estimate allocation time at a speci9c point during program execution.\n\n3. Page allocation \u2014 For a hosted application, allocators may need to map additional pages to fulfil \nan allocation request, requiring additional calls into the operating system (e.g. context switches, \nsyscalls) to provision that memory.\n\n4. Cache behaviour \u2014 When using dynamic memory, the layout of objects in memory may change \nfrom one run to the next. This can impact execution times as the layout may or may not permit \nthe e[cient use of memory caches.\n\n4.21.6.3 Recommended mitigations\n\nDe2ne a lifetime management policy\n\nAs for other types of resources, the software design should de9ne a policy for managing the lifetime \nof allocated memory in order to minimize the risk of memory management defects. Ownership of \nallocated memory should be clearly assigned to speci9c entities in the software, for example by the  \nuse of RAII managing types (smart pointers, containers). The policy should aim to keep ownership  \nrelationships as simple as possible, for example, by the use of unique ownership in preference to  \nshared ownership. Note that circular references may prevent memory from being reclaimed when  \nreference counting is used to manage lifetimes (as is the case with std::shared_ptr).\n\nRestrict the use of dynamic memory to non-critical phases of execution\n\n198\n\nThe impact of dynamic memory related issues on code can be limited by only allowing calls to allocation \nor deallocation functions during non-critical phases of program execution \u2014 for example, the need  \nfor a deterministic execution time is often less strict during startup or shutdown of a system. An \napplication could permit allocation and deallocation calls during the startup phase, but not once the  \n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fsystem is running. Populating the memory immediately after allocation (which is sometimes known as \nprefaulting) allows memory exhaustion errors to be detected at the point of allocation instead of at  \nthe point of 9rst use.\n\nUse custom allocator implementations\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\nImplementations of general-purpose allocators commonly use complex algorithms that are not  \noptimized for providing reliable worst case execution times. When execution time is critical, it is  \nrecommended that a custom allocator be used that relies on an algorithm that makes it easier to  \nreason about worst case execution times and memory consumption. Note that a custom allocator \nhaving these attributes may not perform as e[ciently in the general case, and it may result in a larger \nmemory footprint when compared to the default allocator. It is also usually preferable to choose an \nallocator that does not cause external fragmentation.\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nUse local allocators\n\nThe default allocator is a shared global resource, making detection of the issue identi9ed above more \ndi[cult. A project should consider the use of local allocators to partition the problem space into smaller \nsubproblems, as these will be easier to analyse in isolation. Note that the use of local allocators has \nan implicit cost that needs to be considered in the design phase, as their use may considerably  \nincrease the complexity of the lifetime management policy. In particular, they introduce new classes \nof potential lifetime defects, as memory allocations must never outlive their associated allocator, and \nthey must only be deallocated by the allocator they were acquired with."
  },
  {
    "rule": "Rule 21.6.1 Dynamic memory should not be used\n\nCategory Advisory\n\nAnalysis Undecidable, Single Translation Unit\n\nAmpli2cation\n\nDynamic memory refers to any object with dynamic storage duration that is managed using operator \nnew (excluding the non-allocating placement versions), operator delete, the functions calloc, \nmalloc,  realloc,  aligned_alloc  and  free, or any platform-specific memory allocation or \ndeallocation function.\n\nUses of dynamic memory may occur implicitly (e.g., when throwing exceptions or using C++ Standard \nLibrary classes). Therefore, any instantiation of a C++ Standard Library  entity  having a template \nargument that is a specialization of std::allocator is a violation of this rule, as is any call to a C++ \nStandard Library function that may use dynamic memory.\n\nRationale\n\nIt is acknowledged that applications may need to use dynamic memory, leading to violations of this  \nrule. Any uses of dynamic memory need to be justified through supporting documentation that explains \nhow the issues that have been identi9ed in Section 4.21.6 are managed within the project.\n\nNote: a project may reclassify this rule (see MISRA Compliance [1]) if the risks related to the use \nof dynamic memory are considered to be unacceptable.\n\nExample\n\nauto i = std::make_unique< int32_t >( 42 );   // Non-compliant\nauto j = std::vector< int32_t > {};           // Non-compliant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n199\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni"
  },
  {
    "rule": "Rule 21.6.2 Dynamic memory shall be managed automatically\n\n[expr.delete]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nn\ne\ns\n\nA program shall not take the address of or use:\n\n1. Any non-placement form of new or delete;\n\n2. Any of the functions malloc, calloc, realloc, aligned_alloc, free;\n\n3. Any member function named allocate or deallocate enclosed by namespace std;\n\n4. std::unique_ptr::release.\n\nRationale\n\nThe use of dynamic memory requires the tracking of any memory resources that are allocated to  \nensure that they are released appropriately (no memory leaks, no double frees, use of a matching  \ndeallocation function). This is likely to be error prone (possibly leading to unde%ned behaviour) if it is \nnot managed automatically using facilities such as std::make_unique or std::vector.\n\nIn addition, C-style allocation is not type safe and does not invoke constructors or destructors. \n\nNote: the use of placement new, which is non-allocating, is restricted by"
  },
  {
    "rule": "Rule 21.6.3.\n\nExample\n\nclass A { /* ... */ };\n\nauto p1 = static_cast< A * >( malloc( sizeof( A ) ) );  // Non-compliant\nauto p2 = new A;                                        // Non-compliant\nauto p3 = std::make_unique< A >();                      // Compliant\nauto p4 = p3.release();                                 // Non-compliant\n\nvoid f1( std::pmr::memory_resource & mr, A * p )\n{\n  void * iptr = mr.allocate( sizeof( A ) );             // Non-compliant\n\n  delete p;   // Non-compliant - undefined behaviour if p was allocated using new[]\n}\n\nSee also"
  },
  {
    "rule": "Rule 21.6.1,"
  },
  {
    "rule": "Rule 21.6.3\n\n200\n\nLicensed to: gunjanjain\n22 Apr 2025"
  },
  {
    "rule": "Rule 21.6.3 Advanced memory management shall not be used\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n[expr.new]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nAll overloads of  operator new  and  operator delete  that are not listed below are  advanced \nmemory management functions: \n\nvoid * operator new  ( std::size_t count );\nvoid * operator new[]( std::size_t count );\nvoid * operator new  ( std::size_t count, const std::nothrow_t & tag );\nvoid * operator new[]( std::size_t count, const std::nothrow_t & tag );\n\nvoid operator delete  ( void * ptr ) noexcept;\nvoid operator delete[]( void * ptr ) noexcept;\nvoid operator delete  ( void * ptr, std::size_t sz ) noexcept;\nvoid operator delete[]( void * ptr, std::size_t sz ) noexcept;\nvoid operator delete  ( void * ptr, const std::nothrow_t & tag ) noexcept;\nvoid operator delete[]( void * ptr, const std::nothrow_t & tag ) noexcept;\n\nAdditionally, std::launder and the following functions from the <memory> header file are also \nadvanced memory management functions: \n\nuninitialized_default_construct   uninitialized_default_construct_n   destroy\nuninitialized_value_construct     uninitialized_value_construct_n     destroy_at\nuninitialized_copy                uninitialized_copy_n                destroy_n\nuninitialized_move                uninitialized_move_n\nuninitialized_fill                uninitialized_fill_n\n\nAdvanced memory management occurs when:\n\n1. An advanced memory management function is either called directly or through a new-expression \n\nor a delete-expression; or\n\n2. The address of an advanced memory management function is taken; or\n\n3. A destructor is called explicitly; or\n\n4. Any operator new or operator delete is user-declared.\n\nRationale\n\nThere are a number of complex issues, such as alignment, object lifetimes and the need to use  \nstd::launder, that must be considered when using advanced memory management. Failure to deal \nwith these appropriately results in the introduction of unde%ned behaviour that is hard to identify.\n\nIn addition,  unde%ned behaviour  results if a user does not provide matching versions of  operator \nnew and operator delete.\n\nThese features are generally only used (requiring a deviation) for low-level programming. Ideally, they \nshould be encapsulated to reduce the amount of additional code review that will be required.\n\nExample\n\nauto f() noexcept\n{\n  return new( std::nothrow ) int{ 42 }; // Compliant\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n201\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nstruct X { int32_t a; };\n\nint32_t g()\n{\n  alignas( X ) std::byte mem[ sizeof( X ) ];\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\n  X * px = new( &mem ) X{ 1 };          // Non-compliant - placement new\n\n  px->~X();                             // Non-compliant - explicit destructor call\n\nn\ne\ns\n\n  new( px ) X { 2 };                    // Non-compliant - placement new\n\n  return px->a ;                        // Undefined behaviour\n}\n\nstruct A\n{\n  void * operator new( size_t );        // Non-compliant\n};\n\nSee also"
  },
  {
    "rule": "Rule 21.6.4"
  },
  {
    "rule": "Rule 21.6.4\n\nIf a project de9nes either a sized or unsized version of a global \noperator delete, then both shall be de9ned\n\n[expr.delete]\n[new.delete.single]\n\nCategory Required\n\nAnalysis Decidable, System\n\nRationale\n\nWithin a delete-expression, the C++ Standard does not always specify if the sized or the unsized version \nof the deallocation function will be selected. Therefore, both versions should be provided, and have \nthe same eCect, to ensure that the behaviour is well-de9ned.\n\nExample\n\nThe following example is compliant as sized and unsized versions of operator delete are provided: \n\nvoid operator delete( void * ptr ) noexcept\n{\n  std::free( ptr );\n}\n\nvoid operator delete( void * ptr, std::size_t size ) noexcept \n{\n  delete( ptr );\n}\n\n202\n\nLicensed to: gunjanjain\n22 Apr 2025"
  },
  {
    "rule": "Rule 21.6.5 A pointer to an incomplete class type shall not be deleted\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n[expr.delete] Unde9ned 5\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nAn incomplete class type is a forward declared class type for which the compiler has not yet seen \na complete de9nition.\n\nDeleting a pointer to an incomplete class type results in undefined behaviour when the complete \nclass type has a non-trivial destructor or a deallocation function.\n\nThis rule prohibits deletion of a pointer to an incomplete class type even when it is a trivially destructible \nclass without a deallocation function. This restriction defends against a non-trivial destructor or a \ndeallocation function being added during development.\n\nExample\n\nThe following examples violate"
  },
  {
    "rule": "Rule 21.6.2. \n\nclass Bad\n{\n  class Impl;\n\n  Impl * pImpl;\n\npublic:\n  ~Bad()\n  {\n    delete pImpl;   // Non-compliant - at the point of deletion, pImpl points\n                    // to an object of incomplete class type.\n  }\n};\n\n// Header file\nclass Good\n{\n  class Impl;\n\n  Impl * pImpl;\n\npublic:\n  ~Good();\n};\n\n// Implementation file\nclass Good::Impl\n{\n};\n\n// Good::Impl is a complete type now\nGood::~Good()\n{\n  delete pImpl;   // Compliant - at the point of deletion, pImpl points to\n                  // a complete class type.\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n203\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\n4.21.10 Other runtime support \n\n [support.runtime]"
  },
  {
    "rule": "Rule 21.10.1 The features of <cstdarg> shall not be used\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule also applies to the features of <stdarg.h>.\n\n[C11] / 6.9.1; Unde9ned 8\n[C11] / 7.16; Indeterminate 3\n[C11] / 7.16.1.1; Unde9ned 2\n[C11] / 7.16.1.2; Unde9ned 2\n[C11] / 7.16.1.3; Unde9ned 2\n[C11] / 7.16.1.4; Unde9ned 2, 3, 4\n\nNone of va_list, va_arg, va_start, va_end and va_copy shall be used.\n\nRationale\n\nPassing arguments via an ellipsis bypasses the type checking performed by the compiler.\n\nThere are many instances of undefined behaviour associated with the features of <cstdarg>, including:\n\n\u25cf va_end not being used prior to end of a function in which va_start was used;\n\n\u25cf va_arg being used in diCerent functions on the same va_list;\n\n\u25cf The type of an argument not being compatible with the type speci9ed to va_arg.\n\nNote: this rule does not restrict the use of existing library functions that are implemented as variadic \nfunction or the declaration of functions that use the ellipsis.\n\nExample\n\n#include <cstdarg>\n\nvoid h( va_list ap )             // Non-compliant\n{\n  double y;\n\n  y = va_arg( ap, double );      // Non-compliant\n}\n\nvoid f( uint16_t n, ... )\n{\n  uint32_t x;\n\n  va_list  ap;                   // Non-compliant\n\n  va_start( ap, n );             // Non-compliant\n  x = va_arg( ap, uint32_t );    // Non-compliant\n\n  h( ap );\n\n  // Undefined behaviour - ap is indeterminate because va_arg used in h\n  x = va_arg( ap, uint32_t );    // Non-compliant\n\n  // Undefined behaviour - returns without using va_end\n}\n\n204\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nvoid g( void )\n{\n  // Undefined behaviour - uint32_t / double type mismatch when f uses va_arg\n  f( 1, 2.0, 3.0 );\n}\n\nSee also"
  },
  {
    "rule": "Rule 8.2.11"
  },
  {
    "rule": "Rule 21.10.2 The standard header %le <csetjmp> shall not be used\n\n[csetjmp.syn]\n[C11] / 7.13; Unde9ned 3\n[C11] / 7.13.2.1; Unde9ned 2; Indeterminate 3\n[C11] / 7.22.4.4; Unde9ned 3\n[Koenig] 74\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nIn addition, none of the facilities that are speci9ed as being provided by <csetjmp> shall be used.\n\nNote: use of <setjmp.h> and the facilities it provides are also prohibited by this rule.\n\nRationale\n\nThe use of setjmp and longjmp allow the normal function return mechanisms to be bypassed. \nTheir use may result in unde%ned and unspeci%ed behaviour. For example, it is unde%ned behaviour if \nlongjmp results in the omission of non-trivial object destruction.\n\nSafety standards, such as IEC 61508 [11]  (Part 3, Table B.9) or ISO 26262 [9]  (Part 6, Table 6), \nencourage the use of the \u201csingle-entry single-exit\u201d principle as part of the \u201cmodular approach\u201d.  \nUnstructured languages, such as assembly, allow jumps between arbitrary points in a program,  \nviolating this principle. C++, with its concept of functions and the corresponding calling mechanism, \nenforces the \u201csingle-entry single-exit\u201d principle through its language definition \u2014 for example, multiple \nreturn statements within a function all return to the call site.\n\nNote: the C++ Standard states that aspects of the behaviour associated with these facilities are defined \nin the related version of ISO 9899 [6]."
  },
  {
    "rule": "Rule 21.10.3 The facilities provided by the standard header %le <csignal> shall \n\nnot be used\n\n[C11] / 7.14.1.1; Unde9ned 3, 5, 7; Implementation 3, 6; Indeterminate 5\n[Koenig] 74\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nNone of the facilities that are speci9ed as being provided by <csignal> shall be used. \n\nNote: this rule also applies to the facilities provided by <signal.h>.\n\n205\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n206\n\nRationale\n\nThe inappropriate use of signal handling can lead to unde%ned and implementation-de%ned behaviour. \n\nNote: the C++ Standard states that signal handling behaviour is specified in the related version of  \nISO 9899 [6].\n\nException\n\nCalls to signal with a value of SIG_IGN as the second (func) parameter may be used to disable one \nor more signals. For example: \n\nsignal( SIGTERM, SIG_IGN );\n\n4.22 Diagnostics library\n\n4.22.3 Assertions \n\n [assertions]"
  },
  {
    "rule": "Rule 22.3.1\n\nThe assert macro shall not be used with a constant-expression\n\n[dcl.dcl]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThere are a number of limitations to consider when using the assert macro. For example:\n\n\u25cf An assert failure is only reported at run-time, requiring that a failure also has to be managed \n\nat run-time;\n\n\u25cf The assert macro can only be used in contexts where an expression is allowed;\n\n\u25cf The assert macro may be disabled at build-time.\n\nIt is better to use static_assert when the condition being asserted is a constant-expression, as this \nensures that any failure will be detected at compile time.\n\nException\n\nassert( false ) or assert( false && \"any string literal\" ) may be used to identify paths \nthat are not expected to be executed.\n\nExample\n\nstatic_assert( ( sizeof( int ) == 4 ), \"Bad size\" );  // Rule does not apply\n\nvoid f( int32_t i )\n{\n  assert( i < 1000 );                                 // Compliant - not constant\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\n  if ( i >= 0 )\n  {\n    assert( ( sizeof( int ) == 4 ) && \"Bad size\" );   // Non-compliant - constant\n  }\n  else\n  {\n    assert( false && \"i is negative\" );               // Compliant by exception\n  }\n}\n\n4.22.4 Error numbers \n\n [errno]"
  },
  {
    "rule": "Rule 22.4.1\n\nThe literal value zero shall be the only value assigned to errno\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nNote: the C++ Standard Library is permitted to assign a non-zero value to errno.\n\nRationale\n\nVarious functions within the C++ Standard Library set errno to a non-zero value to indicate that an \nerror has been detected.\n\nThis rule allows this error reporting behaviour to be used, but prevents developers from using errno \nas an error reporting mechanism within a project\u2019s code. C++ provides better mechanisms for error \nhandling.\n\nExample\n\nstd::string getKey ( std::optional< std::string > const & key_data )\n{\n  if ( key_data.has_value() && !key_data->empty() )\n  {\n    return key_data.value();\n  }\n\n  errno = 42;                  // Non-compliant - non-zero value\n  errno = EINVAL;              // Non-compliant - does not expand to literal '0'\n\n  return std::string {};\n}\n\n#define OK 0\n\nvoid f()\n{\n  uint32_t success { 0 };\n\n  errno = success;             // Non-compliant - must use literal '0'\n  errno = OK;                  // Compliant - 'OK' expands to literal '0'\n\n  errnoSettingFunction();\n\n  if ( errno != success )\n  {\n    handleError();\n  }\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n207\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\n4.23 General utilities library\n\n4.23.11 Smart pointers \n\n [smartptr]"
  },
  {
    "rule": "Rule 23.11.1 The raw pointer constructors of std::shared_ptr and \n\nstd::unique_ptr should not be used\n\nn\ne\ns\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\n[unique.ptr]\n[util.smartptr.shared]\n\nThis rule applies to the use of the constructors of std::shared_ptr and std::unique_ptr that \ntake ownership of the raw pointer passed as an argument.\n\nRationale\n\nThe functions  std::make_shared  and  std::make_unique  perform two operations at the same \ntime:\n\n1. Creating an object dynamically (equivalent to new); and\n\n2. Creating a smart pointer that will manage the newly created object\u2019s lifetime.\n\nPerforming both operations in one step ensures that there is no interleaved operation that could  \nthrow an exception before the smart pointer has taken ownership of the object. This also prevents  \ntwo unique_ptr or unrelated shared_ptr instances from \u201cowning\u201d the same object.\n\nNotes: \n\n1. std::make_shared will allocate a single memory area for both the object and the bookkeeping \ndata required for shared pointers (the reference counts). While this is usually beneficial in terms \nof performance, it has the drawback that the memory for the object will not be reclaimed when \nthe last shared_ptr pointing to it is destroyed, but only when all weak_ptr references to the \nobject are also destroyed. If this behaviour is unwanted, a custom variant of std::make_shared \ncan be provided that omits this optimisation.\n\n2. Since C++17, the evaluation order of function calls has been made stricter and some of the \nissues with interleaved calls can no longer happen. However, the use of make_shared or \nmake_unique is still clearer and can result in better performance.\n\nExample\n\nstruct A { int8_t i; };\nclass B { };\n\nvoid f0()\n{\n  auto p = std::make_shared< A > ();      // Compliant\n\n  int8_t * pi = &( p->i );\n  std::shared_ptr< int8_t > q ( p, pi );  // Does not apply - not taking ownership\n}\n\n208\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nauto f1()\n{\n  auto * p1 = new A ();\n  auto   p2 = std::make_unique< A >();    // make_unique may throw\n\n  return std::shared_ptr< A >( p1 );      // Non-compliant - memory leak if\n}                                         //                 make_unique throws\n\nauto f2( std::unique_ptr< A > p )\n{\n  auto q = p.get();\n  // ...\n  return std::unique_ptr< A >( q );       // Non-compliant - causes double delete\n}\n\nvoid f3( std::shared_ptr< A > a, std::shared_ptr< B > b );\n\nvoid f4()\n{\n  f3( std::shared_ptr< A >( new A() ),\n      std::shared_ptr< B >( new B() ) );  // Non-compliant - but well defined\n}                                         //                 in C++17\n\nPrior to C++ 17, a possible sequencing for the operations in the call to f3, where $n represents an \nobject in the abstract machine, was:\n\n1. new A() -> $1\n\n2. new B() -> $2\n\n3. std::shared_ptr< A >( $1 ) -> $3\n\n4. std::shared_ptr< B >( $2 ) -> $4\n\n5. f3( $3, $4 )\n\nIf an exception is thrown during the construction of B, the object of type A will leak. This does not \nhappen in the following as there are no interleaving operations: \n\nvoid f5()\n{\n  f3( std::make_shared< A >(),\n      std::make_shared< B >() );          // Compliant\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n209\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\n4.24\n\nStrings library\n\n4.24.5 Null-terminated sequence utilities \n\n [c.strings]"
  },
  {
    "rule": "Rule 24.5.1\n\nThe character handling functions from <cctype> and <cwctype> \nshall not be used\n\nn\ne\ns\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\n[C11] / 7.4; Unde9ned 1\n[C11] / 7.30.1; Unde9ned 5\n\nThis rule applies to the character classi9cation functions and the character case mapping functions \nfrom <cctype> and <cwctype>. \n\nNote: this rule also applies to the same functions from <ctype.h> and <wctype.h>.\n\nRationale\n\nThe functions declared within <cctype> support the classi9cation and case mapping of characters. \nUnde%ned behaviour occurs if these functions are called with arguments that are not representable \nas an unsigned char, or that are not equal to the value of the macro EOF. Similar issues exist for \nthe functions provided by <cwctype>.\n\nThe C++ Standard Library provides equivalent classification and case mapping functions within  \n<locale> that are safer to use. \n\nNote: the C++ Standard states that the behaviour of the functions covered by this rule is defined in  \nthe related version of ISO 9899 [6].\n\nExample\n\nvoid f( char c )\n{\n  if ( std::isdigit( c ) ) {}                    // Non-compliant\n  if ( std::isdigit( a, std::locale {} ) ) {}    // Compliant version of the above\n}"
  },
  {
    "rule": "Rule 24.5.2\n\nThe C++ Standard Library functions memcpy, memmove and memcmp \nfrom <cstring> shall not be used\n\n[cstring.syn]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThese functions shall not be called or have their addresses taken, and no macro having one of these \nnames shall be expanded.\n\nNote: this rule also applies to the same functions from <string.h>.\n\n210\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nRationale\n\nUse of memmove and memcpy can result in unde%ned behaviour if the blocks of memory pointed to by \ntheir pointer parameters:\n\n\u25cf Overlap (memcpy only); or\n\n\u25cf Are potentially-overlapping; or\n\n\u25cf Are not trivially copyable.\n\nAdditionally, memcmp may not indicate equality for objects that are logically equal. Speci9cally:\n\n\u25cf Floating point values may not compare equal, as the floating point format allows multiple \nrepresentations for some values, such as zero and minus zero (which will not compare equal); \nand\n\n\u25cf Class objects may not compare equal due to:\n\n\u25ac Padding between members, as its content is unspeci9ed and eCectively indeterminate; or\n\n\u25ac Unions having diCerent active members or members of diCerent sizes.\n\n\u25cf Buffers may not compare equal when the meaningful content does not occupy the whole buffer \n\nand the whole buCer is compared. For example, this may happen with:\n\n\u25ac std::vector, where memory is preallocated to enable e[cient growth; or\n\n\u25ac C-style strings, where the \\0 terminator may occur within the buffer and be followed by \n\nirrelevant data.\n\nExample\n\nvoid f1( const uint8_t * src, uint8_t * dst, size_t len )\n{\n  memmove( dst, src, len );                                   // Non-compliant\n}\n\nstruct S\n{\n  bool m1;\n  // There may be padding here\n  int64_t m2;\n};\n\nvoid f2( S s1, S s2 )\n{\n  if ( memcmp( &s1, &s2, sizeof( S ) ) != 0 )                 // Non-compliant\n  {\n  }\n};\n\nextern char buffer1[ 12 ];\nextern char buffer2[ 12 ];\n\nvoid f3()\n{ \n  strcpy( buffer1, \"abc\" );      // Indeterminate contents in elements 4 to 11\n  strcpy( buffer2, \"abc\" );      // Indeterminate contents in elements 4 to 11\n\n  if ( memcmp( buffer1, buffer2, sizeof( buffer1 ) ) != 0 )   // Non-compliant\n  {\n  }\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n211\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\n4.25\n\nLocalization library\n\n4.25.5 C library locales \n\n [c.locales]"
  },
  {
    "rule": "Rule 25.5.1\n\nThe setlocale and std::locale::global functions shall not be \ncalled\n\nn\ne\ns\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\n[locale] Unde9ned 9\n\nCalls to setlocale or std::locale::global may introduce data races (leading to undefined  \nbehaviour) with functions that use the locale (e.g. printf, tolower). It is not as easy to guard against \nthese potential data races due to the ways in which the global locale is used within the C ++ Standard \nLibrary.\n\nThe C++ Standard Library provides functions that allow a locale to be passed as an argument, meaning \nthat it is possible to use a speci9c locale without having to depend on the setting of the global locale  \nobjects.\n\nExample\n\nvoid f1()\n{\n  wchar_t c = L'\\u2002';                     // En-space\n\n  std::setlocale( LC_ALL, \"ja_JP.utf8\" );    // Non-compliant\n\n  if ( std::isspace( c ) ) {}                // Uses global locale\n}\n\nThe following example sets the locale without violating this rule: \n\nvoid f2()\n{\n  wchar_t c = L'\\u2002';                     // En-space\n\n  std::locale utf8( \"ja_JP.utf8\" );\n\n  if ( std::isspace( c, utf8 ) ) {}          // Does not use global locale\n}\n\n212\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS"
  },
  {
    "rule": "Rule 25.5.2\n\nThe pointers returned by the C++ Standard Library functions \nlocaleconv, getenv, setlocale or strerror must only be used \nas if they have pointer to const-quali9ed type\n\n[clocale.syn]\n[cstdlib.syn]\n[cstring.syn]\n[C11] / 7.11.1.1; Unde9ned 8\n[C11] / 7.11.2.1; Unde9ned 8\n[C11] / 7.22.4.6; Unde9ned 4\n[C11] / 7.24.6.2; Unde9ned 3\n\nCategory Mandatory\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThe localeconv function returns a pointer of type struct lconv *. This pointer must be regarded \nas if it had type const struct lconv *.\n\nA struct lconv object includes pointers of type char * and the getenv, setlocale, and strerror \nfunctions each return a pointer of type char *. These pointers are used to access C-style strings \n(null-terminated arrays of type char). For the purposes of this rule, these pointers must be regarded \nas if they had type const char *.\n\nThe addresses of these functions shall not be taken.\n\nRationale\n\nThe C++ Standard states that unde%ned behaviour occurs if a program modi9es:\n\n\u25cf The structure pointed to by the value returned by localeconv;\n\n\u25cf The strings returned by getenv, setlocale or strerror.\n\nNote: the C++ Standard does not specify the behaviour that results if the strings referenced by the \nstructure pointed to by the value returned by localeconv are modified. This rule prohibits any \nchanges to these strings as they are considered to be undesirable.\n\nTreating the pointers returned by the various functions as if they were const-qualified allows an analysis \ntool to detect any attempt to modify an object through one of the pointers. Additionally, assigning  \nthe return values of the functions to const-qualified pointers will result in the compiler issuing a  \ndiagnostic if an attempt is made to modify an object.\n\nNote: if a modified version is required, a program should make and modify a copy of any value covered \nby this rule. \n\nPreventing the addresses of these functions from being taken allows compliance checks to be made \ndecidable.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n213\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n214\n\nExample\n\nThe following examples are non-compliant as the returned pointers are assigned to non const-qualified \npointers. Whilst this will not be reported by a compiler (it is not ill-formed), an analysis tool will be able \nto report a violation.\n\nvoid f1()\n{\n  char         * s1   = setlocale( LC_ALL, 0 );   // Non-compliant\n  struct lconv * conv = localeconv();             // Non-compliant\n\n  s1[ 1 ]             = 'A';                      // Undefined behaviour\n  conv->decimal_point = \"^\";                      // Undefined behaviour\n}\n\nThe following examples are compliant as the returned pointers are assigned to const-qualified pointers. \nAny attempt to modify an object through a pointer will be reported by a compiler or analysis tool as  \nthis is ill-formed. \n\nvoid f2()\n{\n  char str[ 128 ];\n\n  ( void ) strcpy( str,\n                   setlocale( LC_ALL, 0 ) );      // Compliant - 2nd parameter to\n                                                  // strcpy takes a const char *\n  const struct lconv * conv = localeconv();       // Compliant\n\n  conv->decimal_point = \"^\";                      // Ill-formed\n}\n\nThe following example shows that whilst the use of a const-qualified pointer gives compile time \nprotection of the value returned by localeconv, the same is not true for the strings it references. \nModi9cation of these strings can be detected by an analysis tool. \n\nvoid f3()\n{\n  const struct lconv * conv = localeconv();       // Compliant\n\n  conv->grouping[ 2 ] = 'x';                      // Non-compliant\n}"
  },
  {
    "rule": "Rule 25.5.3\n\nThe pointer returned by the C++ Standard Library functions \nasctime, ctime, gmtime, localtime, localeconv, getenv, \nsetlocale or strerror must not be used following a subsequent \ncall to the same function\n\nCategory Mandatory\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nCalls to setlocale may change the values accessible through a pointer that was previously returned \nby localeconv. \n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nFor the purposes of this rule:\n\n\u25cf A call to setlocale following a call to localeconv are treated as if they are calls to the same \n\nfunction; and\n\n\u25cf Calls to asctime and ctime are treated as if they are calls to the same function; and\n\n\u25cf Calls to gmtime and localtime are treated as if they are calls to the same function.\n\nNote: calls to setlocale or localeconv within a different thread of execution may lead to violations \nof this rule.\n\nRationale\n\nThe C++ Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, \nsetlocale and strerror return a pointer to an object within the library\u2019s implementation. The \nimplementation is permitted to use static buffers for any of these objects and a second call (which  \nmay occur in a different thread) to the same function may modify the contents of the buffer. The value \naccessed through a pointer held by the program before a subsequent call to a function may therefore \nchange unexpectedly.\n\nNote: the C++ Standard states that the behaviour of the functions covered by this rule is speci9ed in \nthe related version of ISO 9899 [6]. \n\nExample\n\nvoid f1()\n{\n  const struct lconv * lc = localeconv();\n\n  std::string copy { lc->int_curr_symbol };\n\n  const char * res = std::setlocale ( LC_MONETARY, \"fr_FR\" );\n\n  std::cout << lc->int_curr_symbol;  // Non-compliant - use after setlocale called\n  std::cout << copy;                 // Compliant - copy made before call\n  std::cout << res;                  // Compliant - no subsequent call before use\n}\n\nSee also"
  },
  {
    "rule": "Rule 25.5.1\n\n4.26\n\nContainers library\n\n4.26.3 Sequence containers \n\n [sequences]"
  },
  {
    "rule": "Rule 26.3.1 std::vector should not be specialized with bool\n\n[container.requirements.dataraces]\n\nCategory Advisory\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThe std::vector< bool > specialization\u2019s behaviour differs from that of other uses of std::vector \nas it uses optimized space allocation. For example, the data member function is not available.\n\n215\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nThe C++ Standard guarantees that, in general, elements of a C++ Standard Library container can be \nmodi9ed concurrently, but speci9cally notes that this is not true for std::vector< bool >. \n\nNote: other C++ Standard Library containers do not have specializations for bool and do not exhibit \nthe behaviours identi9ed above.\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nExample\n\nstruct myBool { bool b; };          // Wrapper for bool\n\nn\ne\ns\n\nvoid foo() noexcept\n{\n  std::vector< bool         > a;    // Non-compliant - optimized storage\n  std::vector< std::uint8_t > b;    // Compliant\n  std::vector< myBool       > c;    // Compliant\n  std::array < bool, 20     > d;    // Rule does not apply\n  std::bitset< 200          > e;    // Rule does not apply - efficient storage\n}\n\n4.28 Algorithms library\n\n4.28.3 Algorithms requirements \n\n [algorithms.requirements]"
  },
  {
    "rule": "Rule 28.3.1 Predicates shall not have persistent side eAects\n\n[algorithms.requirements]\n[alg.sorting]\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nWhen a template parameter is named Compare, Predicate, or BinaryPredicate in the C++ \nStandard Library, every callable passed as an argument of that type is a predicate.\n\nIn addition to not having persistent side effects, if the predicate is a function object, its operator() \nshall be declared const. \n\nNote: the operator() of a lambda closure is const unless the lambda is declared mutable.\n\nRationale\n\nIt is implementation defined if the predicate used by an algorithm will be copied. The state of such a \npredicate may therefore unexpectedly be diCerent if a copy is made. Additionally, most algorithms do \nnot specify in which order the predicates will be invoked, or on which objects. This makes it very difficult \nto implement a sensible predicate with mutable internal state.\n\nIdeally, a tool will provide a mechanism that allows the identi9cation of additional predicates in order \nto include them in the analysis scope of this rule.\n\n216\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nExample\n\nbool bar( std::vector< int32_t > & v, int32_t & count )\n{\n  return std::any_of( v.begin(), v.end(),\n    [&count]( int32_t i )                              // Non-compliant\n    {\n      if ( i == 3 )\n      {\n        ++count;                                       // Persistent side effect\n        return true;\n      }\n      return false;\n    } );\n}\n\nstruct Comp\n{\n  bool operator()( int32_t a, int32_t b )              // Non-compliant - not const\n  {\n    return a > b;\n  }\n};\n\nstd::set< int32_t, Comp > mySet;\n\n4.28.6 Mutating sequence operations \n\n [alg.modifying.operations]"
  },
  {
    "rule": "Rule 28.6.1\n\nThe argument to std::move shall be a non-const lvalue\n\n[forward]\n[class.copy.ctor]\n[class.copy.assign]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nRationale\n\nThe result of calling std::move on an object that is const will result in the object\u2019s content not \nbeing moved. \n\nCalling std::move on an rvalue is redundant.\n\nExample\n\nvoid f1( std::string && );                  // #1\nvoid f1( std::string const & );             // #2\n\nvoid f2( std::string const & s1, std::string s2 )\n{\n  f1( s1 );                                 // Calls #2\n  f1( std::move( s1 ) );                    // Non-compliant - calls #2\n\n  f1( std::move( s2 ) );                    // Compliant - calls #1\n\n  f1( std::string( \"abc\" ) );               // Calls #1\n  f1( std::move( std::string( \"abc\" ) ) );  // Non-compliant - redundant move of\n}                                           // temporary, also calls #1\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n217\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:"
  },
  {
    "rule": "Rule 28.6.2 Forwarding references and std::forward shall be used together\n\n[dcl.ref]\n[temp.deduct.call]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nAmpli2cation\n\nA forwarding reference parameter (of type T &&) shall be forwarded when passed to other functions \nby wrapping the parameter in a call to the function std::forward< T >.\n\nFurthermore, std::forward shall only be used to forward a forwarding reference.\n\nRationale\n\nPerfect forwarding relies on language features such as reference collapsing and type deduction, which \nare complex to master. Enforcing the use of well known idioms avoids the risk of writing code that  \ndoes not do what was intended.\n\nNote: care must be taken not to forward the same argument twice \u2014 see"
  },
  {
    "rule": "Rule 28.6.3.\n\nExample\n\nvoid f1( std::string &  );          // #1\nvoid f1( std::string && );          // #2\n\ntemplate< typename T1, typename T2 >\nvoid f2( T1 && t1, T2 & t2 )\n{\n  f1( t1 );                         // Non-compliant - calls #1\n\n  f1( std::forward< T1 >( t1 ) );   // Compliant - calls #1 (for #4) or #2 (for #3)\n  f1( std::forward< T2 >( t2 ) );   // Non-compliant - calls #2\n  f1( std::forward< T2 >( t1 ) );   // Non-compliant - wrong template parameter\n\n  f1( std::move( t1 ) );            // Non-compliant - calls #2\n  f1( std::move( t2 ) );            // Rule does not apply - calls #2\n\n  auto lambda = [] ( auto && t )\n                   { f1(t); };      // Non-compliant - calls #1\n}\n\nvoid f3()\n{\n  std::string s;\n\n  f2( std::string { \"Hello\" }, s ); // #3\n  f2( s, s );                       // #4\n}\n\n218\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\ftemplate< typename T >\nstruct A\n{\n  void foo( T && t )\n  {\n    std::move( t );    // Rule does not apply - not a forwarding reference\n  }\n};\n\nSee also"
  },
  {
    "rule": "Rule 28.6.1,"
  },
  {
    "rule": "Rule 28.6.3"
  },
  {
    "rule": "Rule 28.6.3 An object shall not be used while in a potentially moved-from state\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nCalling std::move, std::forward or using an equivalent static_cast puts its argument into a \npotentially moved-from state.\n\nAn object in a potentially moved-from state shall not be used on any path, regardless of the path\u2019s \nfeasibility.\n\nAn object passed as an lvalue reference function parameter shall not be in a potentially moved-from  \nstate when the function returns. This additional restriction is included as it allows compliance to be  \ndetermined within a translation unit.\n\nThis rule does not apply to the following:\n\n\u25cf Assigning to an object; or\n\n\u25cf Destroying an object; or\n\n\u25cf Using an object having type std::unique_ptr.\n\nFor the purposes of this rule, aliases of an object are considered to refer to different objects. This  \nallows compliance checks to be decidable.\n\nRationale\n\nUsing std::forward or std::move on an lvalue to pass it as an rvalue reference argument in a \nfunction call can result in the lvalue object being in an indeterminate state after the call. However, a \nstd::unique_ptr that has been moved-from is in a well-de9ned state, equal to nullptr.\n\nExample\n\nsize_t a( std::string s1 )\n{\n  std::string s2 = std::move( s1 );\n  return s1.size();                      // Non-compliant - s1 has potentially\n}                                        //                 moved-from state\n\nsize_t b( std::string s1 )\n{\n  std::string s2 =\n    static_cast< std::string && >( s1 ); // Equivalent to std::move\n  return s1.size();                      // Non-compliant - s1 has potentially\n}                                        //                 moved-from state\n\n219\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nvoid c( std::string s1 )\n{\n  std::string s2 = std::move( s1 );\n  std::string s3 = s1;                   // Non-compliant - s1 has potentially\n}                                        //                 moved-from state\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\ntemplate< typename T >\nvoid bar( T & t );\n\ntemplate< typename T >\nvoid foo( T && t )\n{\n  bar( std::forward< T >( t ) );\n  ++t;                                   // Non-compliant - std::forward leaves t\n}                                        //   in a potentially moved-from state\n\nstruct X { std::string s; };\n\nvoid f( X & x )\n{\n  X y ( std::move( x ) );                // Non-compliant - lvalue reference\n                                         //   parameter left in potentially moved-\n}                                        //   from state when function returns\n\nvoid g( X x )\n{\n  X y;\n\n  y = std::move( x );                    // Compliant - no more uses of x\n}\n\nvoid h( X x )\n{\n  X y;\n\n  y = std::move( x );\n  x = X{};                               // Compliant - assigns to potentially\n}                                        //             moved-from object\n\nThe following is non-compliant as the evaluation order of the arguments to  d1 is implementation-\nde%ned and there is a permitted order in which the 9rst argument s has potentially moved-from state. \n\nvoid    d1 ( std::string const &, int32_t );\nint32_t d2 ( std::string && );\n\nvoid d3( std::string s )\n{\n  d1( s, d2( std::move( s ) ) );         // Non-compliant\n}"
  },
  {
    "rule": "Rule 28.6.4\n\nThe result of std::remove, std::remove_if, std::unique and \nempty shall be used\n\n[container.requirements.general]\n[alg.modifying.operations]\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\n220\n\nFor the purposes of this rule, a cast to void is not considered to be a use.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fThis rule applies to member and non-member forms of empty within the C++ Standard Library.\n\nThis rule does not apply to the std::remove( const char * ) overload de9ned in <cstdio>.\n\nRationale\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\nThe mutating algorithms std::remove, std::remove_if and overloads of std::unique operate \nby swapping or moving elements of the range they are operating over. On completion, they return an \niterator to one past the last valid element. In the majority of cases, the correct behaviour is to use this  \nresult as the 9rst operand in a call to std::erase.\n\nIgnoring the result of empty may indicate that a developer expects the call to purge the contents of \nthe container, while it actually reports if it contains data.\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nExample\n\nvoid f1()\n{\n  std::vector< int32_t > v1 = { 0, 0, 1, 1, 2, 2, 3, 3 };\n  std::vector< int32_t > v2 = v1;\n\n  std::unique( v1.begin(), v1.end() );           // Non-compliant\n\n  // v1 now holds { 0, 1, 2, 3, ?, ?, ?, ? }\n  // where ? represents an unknown value\n\n  v2.erase( std::unique( v2.begin(), v2.end() ),\n                         v2.end() );             // Compliant\n\n  // Contents of v2 is now { 0, 1, 2, 3 }\n}\n\nvoid f2( std::vector< int32_t > & v3 )\n{\n  empty( v3 );                                   // Non-compliant - result not used\n  v3.empty();                                    // Non-compliant - result not used\n\n  if ( !empty( v3 ) )                            // Compliant\n  {\n    v3.clear();                                  // Purges the vector\n  }\n}\n\nSee also"
  },
  {
    "rule": "Rule 0.1.2\n\n4.30\n\nInput/output library\n\n4.30.0 MISRA \n\n [misra]"
  },
  {
    "rule": "Rule 30.0.1\n\nThe C Library input/output functions shall not be used\n\nCategory Required\n\nAnalysis Decidable, Single Translation Unit\n\nAmpli2cation\n\nThis rule applies to the functions that are specified as being provided by  <cstdio> and the wide-\ncharacter equivalents speci9ed as being provided by <cwchar>.\n\n221\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fS\ne\nc\nt\ni\no\nn\n4\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\n222\n\nNone of these identi9ers shall be used and no macro with one of these names shall be expanded.\n\nNotes:\n\n1. Use of the same functions from <stdio.h> and <wchar.h> are also prohibited by this rule.\n\n2. This rule does not prohibit the use of the facilities provided by <fstream>, even though they \n\nmay indirectly use functions from <cstdio> or <cwchar>.\n\nRationale\n\nStreams and file input/output have undefined, unspecified and implementation-defined behaviours \nassociated with them."
  },
  {
    "rule": "Rule 30.0.2 Reads and writes on the same 9le stream shall be separated by a \n\npositioning operation\n\n[9lebuf]\n[C11] / 7.21.5.3; Unde9ned 7\n\nCategory Required\n\nAnalysis Undecidable, System\n\nAmpli2cation\n\nAn explicit, interleaving stream positioning operation shall be used between input operations and \noutput operations on a std::basic_filebuf.\n\nThis rule applies to direct and indirect calls (e.g. from std::fstream) to std::basic_filebuf. \n\nNote: for the purposes of this rule, a call to fflush after an output operation is considered to be an \nexplicit 9le positioning operation.\n\nRationale\n\nThe C FILE * abstraction, used as the underlying system file input/output for std::basic_filebuf, \nholds a single 9le position that is used when reading from or writing to the 9le. Using an input operation \non a FILE * immediately after an output operation (or vice versa) results in undefined behaviour, unless \nan interleaving file positioning operation is used to update the file\u2019s position.\n\nIn addition, a streambuf object keeps separate buffer positions for reading and writing characters \nfrom its internal buffer. A basic_filebuf object is only guaranteed to synchronize the separate \ninternal streambuf read and write positions that it maintains when a positioning operation is called \nwhen alternating between reading and writing (and vice versa). Failure to include such a positioning \noperation leads to unde%ned behaviour.\n\nThe accessible positioning operations for streambuf are pubseekoff and pubseekpos, whilst for \n9le streams they are tellg, seekg, tellp, and seekp. One of these functions shall be called when \nswitching from output to input, or vice versa.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fExample\n\nvoid show_fstream_non_compliant()\n{\n  std::fstream f { \"hello.txt\" };\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n  f << \"Hello world!\\n\" << std::flush;   // flush is not a positioning operation\n\n  std::string s {};\n\n  std::getline( f, s );                  // Non-compliant - undefined behaviour\n}\n\n:\n\n4\nn\no\ni\nt\nc\ne\nS\n\nvoid show_fstream_compliant()\n{\n  std::fstream f { \"hello.txt\" };\n\n  f << \"Hello world!\\n\";\n\n  std::string s {};\n\n  f.seekg( 0, std::ios_base::beg );\n\n  std::getline(f, s);                    // Compliant - s holds \"Hello world!\"\n}\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n223\n\n \n \n\f5 References\n\n5.0\n\nMISRA publications\n\n[1] MISRA Compliance:2020, Achieving compliance with MISRA coding guidelines\n\nISBN 978-1-906400-26-2\nHORIBA MIRA Limited, February 2020\n\n[2] MISRA C++:2008, Guidelines for the use of the C++ language in critical systems\n\nISBN 978-1-906400-03-3\nMIRA Limited, June 2008\n\n[3] MISRA Development guidelines for vehicle based software\n\nISBN 0-9524156-0-7\nMotor Industry Research Association, November 1994\n\n[4] MISRA AC GMG:2023, Generic modelling design and style guidelines\nISBN 978-1-911700-04-3 Paperback, ISBN 978-1-911700-05-0 PDF\nThe MISRA Consortium Limited, June 2023\n\n[5] MISRA AC SLSF:2023, Modelling design and style guidelines for the application of Simulink and \n\nState+ow\nISBN 978-1-911700-06-7 Paperback, ISBN 978-1-911700-07-4 PDF\nThe MISRA Consortium Limited, June 2023\n\n5.1\n\nInternational standards\n\n[6]\n\n[7]\n\n[8]\n\n[9]\n\nISO/IEC 9899:2011, Programming languages \u2014 C\nInternational Organization for Standardization\n\nISO/IEC 10646:2020, Information technology \u2014 Universal coded character set (UCS)\nInternational Organization for Standardization\n\nISO/IEC 14882:2017, Information technology \u2014 Programming languages \u2014 C++\nInternational Organization for Standardization\n\nISO 26262:2018, Road vehicles \u2014 Functional safety\nInternational Organization for Standardization\n\n[10] ISO/IEC/IEEE 60559:2011, Information technology \u2014 Microprocessor Systems \u2014 Floating-Point \n\narithmetic\nInternational Organization for Standardization\n\n[11] IEC 61508:2010, Functional safety of electrical/electronic/programmable electronic safety-related \n\nsystems\nInternational Electromechanical Commission\n\n[12] DO-178C/ED-12C, Software Considerations in Airborne Systems and Equipment Certi%cation\n\nRTCA/EUROCAE, 2011\n\n[13] Unicode 13.0.0, Unicode Standard Annex #44\n\nUnicode, Inc.\n\n224\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n\f5.2\n\nOther references\n\n[14] Koenig A., C Traps and Pitfalls\n\nISBN 0-201-17928-8\nAddison-Wesley, 1988\n\ns\ne\nc\nn\ne\nr\ne\nf\ne\nR\n\n:\n\n5\nn\no\ni\nt\nc\ne\nS\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n225\n\n \n \n\fAppendix A Summary of guidelines\n\nLanguage independent issues\n\nPath feasibility   [misra]"
  },
  {
    "rule": "Rule 0.0.1\n\nRequired\n\nA function shall not contain unreachable statements"
  },
  {
    "rule": "Rule 0.0.2\n\nAdvisory\n\nControlling expressions should not be invariant\n\nUnused values   [misra]"
  },
  {
    "rule": "Rule 0.1.1\n\nAdvisory\n\nA value should not be unnecessarily written to a local object"
  },
  {
    "rule": "Rule 0.1.2\n\nRequired\n\nThe value returned by a function shall be used\n\nUnused declarations   [misra]"
  },
  {
    "rule": "Rule 0.2.1\n\nAdvisory\n\nVariables with limited visibility should be used at least once"
  },
  {
    "rule": "Rule 0.2.2\n\nRequired\n\nA named function parameter shall be used at least once"
  },
  {
    "rule": "Rule 0.2.3\n\nAdvisory\n\nTypes with limited visibility should be used at least once"
  },
  {
    "rule": "Rule 0.2.4\n\nAdvisory\n\nFunctions with limited visibility should be used at least once\n\nRuntime failures   [misra]\n\nDir 0.3.1\n\nAdvisory\n\nFloating-point arithmetic should be used appropriately\n\nDir 0.3.2\n\nRequired\n\nA function call shall not violate the function\u2019s preconditions\n\nGeneral principles\n\nImplementation compliance   [intro.compliance]"
  },
  {
    "rule": "Rule 4.1.1\n\nRequired\n\nA program shall conform to ISO/IEC 14882:2017 (C++17)"
  },
  {
    "rule": "Rule 4.1.2\n\nAdvisory\n\nDeprecated features should not be used"
  },
  {
    "rule": "Rule 4.1.3\n\nRequired\n\nThere shall be no occurrence of unde9ned or critical unspeci9ed \nbehaviour\n\nProgram execution   [intro.execution]"
  },
  {
    "rule": "Rule 4.6.1\n\nRequired\n\nOperations on a memory location shall be sequenced appropriately\n\nLexical conventions\n\nMISRA   [misra]"
  },
  {
    "rule": "Rule 5.0.1\n\nAdvisory\n\nTrigraph-like sequences should not be used\n\nComments   [lex.comment]\n\n226"
  },
  {
    "rule": "Rule 5.7.1\n\nRequired\n\nThe character sequence /* shall not be used within a C-style comment\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\ng\nf\no\ny\nr\na\nm\nm\nu\nS\n\n:\n\ni\n\nA\nx\nd\nn\ne\np\np\nA\n\nDir 5.7.2\n\nAdvisory\n\nSections of code should not be \u201ccommented out\u201d"
  },
  {
    "rule": "Rule 5.7.3\n\nRequired\n\nLine-splicing shall not be used in // comments\n\nIdenti2ers   [lex.name]"
  },
  {
    "rule": "Rule 5.10.1\n\nRequired\n\nUser-de9ned identi9ers shall have an appropriate form\n\nLiterals   [lex.literal]"
  },
  {
    "rule": "Rule 5.13.1\n\nRequired\n\nWithin character literals and non raw-string literals, \\ shall only be used \nto form a de9ned escape sequence or universal character name"
  },
  {
    "rule": "Rule 5.13.2\n\nRequired\n\nOctal escape sequences, hexadecimal escape sequences and universal \ncharacter names shall be terminated"
  },
  {
    "rule": "Rule 5.13.3\n\nRequired\n\nOctal constants shall not be used"
  },
  {
    "rule": "Rule 5.13.4\n\nRequired\n\nUnsigned integer literals shall be appropriately su[xed"
  },
  {
    "rule": "Rule 5.13.5\n\nRequired\n\nThe lowercase form of L shall not be used as the 9rst character in a \nliteral su[x"
  },
  {
    "rule": "Rule 5.13.6\n\nRequired\n\nAn integer-literal of type long long shall not use a single L or l in any \nsu[x"
  },
  {
    "rule": "Rule 5.13.7\n\nRequired\n\nString literals with diCerent encoding pre9xes shall not be concatenated\n\nBasic concepts\n\nMISRA   [misra]"
  },
  {
    "rule": "Rule 6.0.1\n\nRequired\n\nBlock scope declarations shall not be visually ambiguous"
  },
  {
    "rule": "Rule 6.0.2\n\nAdvisory\n\nWhen an array with external linkage is declared, its size should be \nexplicitly speci9ed"
  },
  {
    "rule": "Rule 6.0.3\n\nAdvisory\n\nThe only declarations in the global namespace should be main, \nnamespace declarations and extern \"C\" declarations"
  },
  {
    "rule": "Rule 6.0.4\n\nRequired\n\nThe identi9er main shall not be used for a function other than the global \nfunction main\n\nOne-de2nition rule   [basic.def.odr]"
  },
  {
    "rule": "Rule 6.2.1\n\nRequired\n\nThe one-de9nition rule shall not be violated"
  },
  {
    "rule": "Rule 6.2.2\n\nRequired\n\nAll declarations of a variable or function shall have the same type"
  },
  {
    "rule": "Rule 6.2.3\n\nRequired\n\nThe source code used to implement an entity shall appear only once"
  },
  {
    "rule": "Rule 6.2.4\n\nRequired\n\nA header 9le shall not contain de9nitions of functions or objects that are \nnon-inline and have external linkage\n\nName lookup   [basic.lookup]"
  },
  {
    "rule": "Rule 6.4.1\n\nRequired\n\nA variable declared in an inner scope shall not hide a variable declared \nin an outer scope\n\n227\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n\fA\np\np\ne\nn\nd\nx\nA\n\ni\n\n:\n\nS\nu\nm\nm\na\nr\ny\no\nf\ng\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns"
  },
  {
    "rule": "Rule 6.4.2\n\nRequired\n\nDerived classes shall not conceal functions that are inherited from their \nbases"
  },
  {
    "rule": "Rule 6.4.3\n\nRequired\n\nA name that is present in a dependent base shall not be resolved by \nunquali9ed lookup\n\nProgram and linkage   [basic.link]"
  },
  {
    "rule": "Rule 6.5.1\n\nAdvisory\n\nA function or object with external linkage should be introduced in a \nheader 9le"
  },
  {
    "rule": "Rule 6.5.2\n\nAdvisory\n\nInternal linkage should be speci9ed appropriately\n\nStorage duration   [basic.stc]"
  },
  {
    "rule": "Rule 6.7.1\n\nRequired\n\nLocal variables shall not have static storage duration"
  },
  {
    "rule": "Rule 6.7.2\n\nRequired\n\nGlobal variables shall not be used\n\nObject lifetime   [basic.life]"
  },
  {
    "rule": "Rule 6.8.1\n\nRequired\n\nAn object shall not be accessed outside of its lifetime"
  },
  {
    "rule": "Rule 6.8.2\n\nMandatory\n\nA function must not return a reference or a pointer to a local variable \nwith automatic storage duration"
  },
  {
    "rule": "Rule 6.8.3\n\nRequired\n\nAn assignment operator shall not assign the address of an object with \nautomatic storage duration to an object with a greater lifetime"
  },
  {
    "rule": "Rule 6.8.4\n\nAdvisory\n\nMember functions returning references to their object should be ref-\nquali9ed appropriately\n\nTypes   [basic.types]"
  },
  {
    "rule": "Rule 6.9.1\n\nRequired\n\nThe same type aliases shall be used in all declarations of the same entity"
  },
  {
    "rule": "Rule 6.9.2\n\nAdvisory\n\nThe names of the standard signed integer types and standard unsigned \ninteger types should not be used\n\nStandard conversions\n\nThe built-in type rules   [misra]"
  },
  {
    "rule": "Rule 7.0.1\n\nRequired\n\nThere shall be no conversion from type bool"
  },
  {
    "rule": "Rule 7.0.2\n\nRequired\n\nThere shall be no conversion to type bool"
  },
  {
    "rule": "Rule 7.0.3\n\nRequired\n\nThe numerical value of a character shall not be used"
  },
  {
    "rule": "Rule 7.0.4\n\nRequired\n\nThe operands of bitwise operators and shift operators shall be \nappropriate"
  },
  {
    "rule": "Rule 7.0.5\n\nRequired\n\nIntegral promotion and the usual arithmetic conversions shall not \nchange the signedness or the type category of an operand"
  },
  {
    "rule": "Rule 7.0.6\n\nRequired\n\nAssignment between numeric types shall be appropriate\n\n228\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n\fPointer conversions   [conv.ptr]\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\ng\nf\no\ny\nr\na\nm\nm\nu\nS\n\n:\n\ni\n\nA\nx\nd\nn\ne\np\np\nA"
  },
  {
    "rule": "Rule 7.11.1\n\nRequired\n\nnullptr shall be the only form of the null-pointer-constant"
  },
  {
    "rule": "Rule 7.11.2\n\nRequired\n\nAn array passed as a function argument shall not decay to a pointer"
  },
  {
    "rule": "Rule 7.11.3\n\nRequired\n\nA conversion from function type to pointer-to-function type shall only \noccur in appropriate contexts\n\nExpressions\n\nMISRA   [misra]"
  },
  {
    "rule": "Rule 8.0.1\n\nAdvisory\n\nParentheses should be used to make the meaning of an expression \nappropriately explicit\n\nPrimary expressions   [expr.prim]"
  },
  {
    "rule": "Rule 8.1.1\n\nRequired\n\nA non-transient lambda shall not implicitly capture this"
  },
  {
    "rule": "Rule 8.1.2\n\nAdvisory\n\nVariables should be captured explicitly in a non-transient lambda\n\nPost2x expressions   [expr.post]"
  },
  {
    "rule": "Rule 8.2.1\n\nRequired\n\nA virtual base class shall only be cast to a derived class by means of \ndynamic_cast"
  },
  {
    "rule": "Rule 8.2.2\n\nRequired\n\nC-style casts and functional notation casts shall not be used"
  },
  {
    "rule": "Rule 8.2.3\n\nRequired\n\nA cast shall not remove any const or volatile quali9cation from the type \naccessed via a pointer or by reference"
  },
  {
    "rule": "Rule 8.2.4\n\nRequired\n\nCasts shall not be performed between a pointer to function and any \nother type"
  },
  {
    "rule": "Rule 8.2.5\n\nRequired\n\nreinterpret_cast shall not be used"
  },
  {
    "rule": "Rule 8.2.6\n\nRequired\n\nAn object with integral, enumerated, or pointer to void type shall not be \ncast to a pointer type"
  },
  {
    "rule": "Rule 8.2.7\n\nAdvisory\n\nA cast should not convert a pointer type to an integral type"
  },
  {
    "rule": "Rule 8.2.8\n\nRequired\n\nAn object pointer type shall not be cast to an integral type other than \nstd::uintptr_t or std::intptr_t"
  },
  {
    "rule": "Rule 8.2.9\n\nRequired\n\nThe operand to typeid shall not be an expression of polymorphic class \ntype"
  },
  {
    "rule": "Rule 8.2.10\n\nRequired\n\nFunctions shall not call themselves, either directly or indirectly"
  },
  {
    "rule": "Rule 8.2.11\n\nRequired\n\nAn argument passed via ellipsis shall have an appropriate type\n\nUnary expressions   [expr.unary]"
  },
  {
    "rule": "Rule 8.3.1\n\nAdvisory\n\nThe built-in unary - operator should not be applied to an expression of \nunsigned type\n\n229\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n\fA\np\np\ne\nn\nd\nx\nA\n\ni\n\n:\n\nS\nu\nm\nm\na\nr\ny\no\nf\ng\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns"
  },
  {
    "rule": "Rule 8.3.2\n\nAdvisory\n\nThe built-in unary + operator should not be used \n\nAdditive operators   [expr.add]"
  },
  {
    "rule": "Rule 8.7.1\n\nRequired\n\nPointer arithmetic shall not form an invalid pointer"
  },
  {
    "rule": "Rule 8.7.2\n\nRequired\n\nSubtraction between pointers shall only be applied to pointers that \naddress elements of the same array\n\nRelational operators   [expr.rel]"
  },
  {
    "rule": "Rule 8.9.1\n\nRequired\n\nThe built-in relational operators >, >=, < and <= shall not be applied to \nobjects of pointer type, except where they point to elements of the same\n array\n\nLogical AND operator   [expr.log.and]"
  },
  {
    "rule": "Rule 8.14.1\n\nAdvisory\n\nThe right-hand operand of a logical && or || operator should not \ncontain persistent side eCects\n\nAssignment and compound assignment   [expr.ass]"
  },
  {
    "rule": "Rule 8.18.1 Mandatory\n\nAn object or subobject must not be copied to an overlapping object"
  },
  {
    "rule": "Rule 8.18.2\n\nAdvisory\n\nThe result of an assignment operator should not be used\n\nComma operator   [expr.comma]"
  },
  {
    "rule": "Rule 8.19.1\n\nAdvisory\n\nThe comma operator should not be used\n\nConstant expressions   [expr.const]"
  },
  {
    "rule": "Rule 8.20.1\n\nAdvisory\n\nAn unsigned arithmetic operation with constant operands should not \nwrap\n\nStatements\n\nExpression statement   [stmt.expr]"
  },
  {
    "rule": "Rule 9.2.1\n\nRequired\n\nAn explicit type conversion shall not be an expression statement\n\nCompound statement   [stmt.block]"
  },
  {
    "rule": "Rule 9.3.1\n\nRequired\n\nThe body of an iteration-statement or a selection-statement shall be a \ncompound-statement\n\nSelection statements   [stmt.select]"
  },
  {
    "rule": "Rule 9.4.1\n\nRequired\n\nAll if ... else if constructs shall be terminated with an else statement"
  },
  {
    "rule": "Rule 9.4.2\n\nRequired\n\nThe structure of a switch statement shall be appropriate\n\nIteration statements   [stmt.iter]"
  },
  {
    "rule": "Rule 9.5.1\n\nAdvisory\n\nLegacy for statements should be simple"
  },
  {
    "rule": "Rule 9.5.2\n\nRequired\n\nA for-range-initializer shall contain at most one function call\n\n230\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n\fs\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\ng\nf\no\ny\nr\na\nm\nm\nu\nS\n\n:\n\ni\n\nA\nx\nd\nn\ne\np\np\nA\n\nJump statements   [stmt.jump]"
  },
  {
    "rule": "Rule 9.6.1\n\nAdvisory\n\nThe goto statement should not be used"
  },
  {
    "rule": "Rule 9.6.2\n\nRequired\n\nA goto statement shall reference a label in a surrounding block"
  },
  {
    "rule": "Rule 9.6.3\n\nRequired\n\nThe goto statement shall jump to a label declared later in the function \nbody"
  },
  {
    "rule": "Rule 9.6.4\n\nRequired\n\nA function declared with the [[noreturn]] attribute shall not return"
  },
  {
    "rule": "Rule 9.6.5\n\nRequired\n\nA function with non-void return type shall return a value on all paths\n\nDeclarations\n\nMISRA   [misra]"
  },
  {
    "rule": "Rule 10.0.1\n\nAdvisory\n\nA declaration should not declare more than one variable or member \nvariable\n\nSpeci2ers   [dcl.spec]"
  },
  {
    "rule": "Rule 10.1.1\n\nAdvisory\n\nThe target type of a pointer or lvalue reference parameter should be \nconst-quali9ed appropriately"
  },
  {
    "rule": "Rule 10.1.2\n\nRequired\n\nThe volatile quali9er shall be used appropriately\n\nEnumeration declarations   [dcl.enum]"
  },
  {
    "rule": "Rule 10.2.1\n\nRequired\n\nAn enumeration shall be de9ned with an explicit underlying type"
  },
  {
    "rule": "Rule 10.2.2\n\nAdvisory\n\nUnscoped enumerations should not be declared"
  },
  {
    "rule": "Rule 10.2.3\n\nRequired\n\nThe numeric value of an unscoped enumeration with no 9xed underlying\n type shall not be used\n\nNamespaces   [basic.namespace]"
  },
  {
    "rule": "Rule 10.3.1\n\nAdvisory\n\nThere should be no unnamed namespaces in header 9les\n\nThe asm declaration   [dcl.asm]"
  },
  {
    "rule": "Rule 10.4.1\n\nRequired\n\nThe asm declaration shall not be used\n\nDeclarators\n\nMeaning of declarators   [dcl.meaning]"
  },
  {
    "rule": "Rule 11.3.1\n\nAdvisory\n\nVariables of array type should not be declared"
  },
  {
    "rule": "Rule 11.3.2\n\nAdvisory\n\nThe declaration of an object should contain no more than two levels of \npointer indirection\n\nInitializers   [dcl.init]"
  },
  {
    "rule": "Rule 11.6.1\n\nAdvisory\n\nAll variables should be initialized\n\n231\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n\fA\np\np\ne\nn\nd\nx\nA\n\ni\n\n:\n\nS\nu\nm\nm\na\nr\ny\no\nf\ng\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns"
  },
  {
    "rule": "Rule 11.6.2 Mandatory\n\nThe value of an object must not be read before it has been set"
  },
  {
    "rule": "Rule 11.6.3\n\nRequired\n\nWithin an enumerator list, the value of an implicitly-speci9ed \nenumeration constant shall be unique\n\nClasses\n\nClass members   [class.mem]"
  },
  {
    "rule": "Rule 12.2.1\n\nAdvisory\n\nBit-9elds should not be declared"
  },
  {
    "rule": "Rule 12.2.2\n\nRequired\n\nA bit-9eld shall have an appropriate type"
  },
  {
    "rule": "Rule 12.2.3\n\nRequired\n\nA named bit-9eld with signed integer type shall not have a length of one \nbit\n\nUnions   [class.union]"
  },
  {
    "rule": "Rule 12.3.1\n\nRequired\n\nThe union keyword shall not be used\n\nDerived classes\n\nMultiple base classes   [class.mi]"
  },
  {
    "rule": "Rule 13.1.1\n\nAdvisory\n\nClasses should not be inherited virtually"
  },
  {
    "rule": "Rule 13.1.2\n\nRequired\n\nAn accessible base class shall not be both virtual and non-virtual in the \nsame hierarchy\n\nVirtual functions   [class.virtual]"
  },
  {
    "rule": "Rule 13.3.1\n\nRequired\n\nUser-declared member functions shall use the virtual, override and 9nal \nspeci9ers appropriately"
  },
  {
    "rule": "Rule 13.3.2\n\nRequired\n\nParameters in an overriding virtual function shall not specify diCerent \ndefault arguments"
  },
  {
    "rule": "Rule 13.3.3\n\nRequired\n\nThe parameters in all declarations or overrides of a function shall either \nbe unnamed or have identical names"
  },
  {
    "rule": "Rule 13.3.4\n\nRequired\n\nA comparison of a potentially virtual pointer to member function shall \nonly be with nullptr\n\nMember access control\n\nAccess speci2ers   [class.access.spec]"
  },
  {
    "rule": "Rule 14.1.1\n\nAdvisory\n\nNon-static data members should be either all private or all public\n\nSpecial member functions\n\nMISRA   [misra]"
  },
  {
    "rule": "Rule 15.0.1\n\nRequired\n\nSpecial member functions shall be provided appropriately\n\n232\n\nLicensed to: gunjanjain\n22 Apr 2025"
  },
  {
    "rule": "Rule 15.0.2\n\nAdvisory\n\nUser-provided copy and move member functions of a class should have \nappropriate signatures\n\nConstructors   [class.ctor]"
  },
  {
    "rule": "Rule 15.1.1\n\nRequired\n\nAn object\u2019s dynamic type shall not be used from within its constructor or \ndestructor"
  },
  {
    "rule": "Rule 15.1.2\n\nAdvisory\n\nAll constructors of a class should explicitly initialize all of its virtual base \nclasses and immediate base classes"
  },
  {
    "rule": "Rule 15.1.3\n\nRequired\n\nConversion operators and constructors that are callable with a single \nargument shall be explicit"
  },
  {
    "rule": "Rule 15.1.4\n\nAdvisory\n\nAll direct, non-static data members of a class should be initialized before\n the class object is accessible"
  },
  {
    "rule": "Rule 15.1.5\n\nRequired\n\nA class shall only de9ne an initializer-list constructor when it is the only \nconstructor\n\nCopying and moving class objects   [class.copy]\n\nDir 15.8.1\n\nRequired\n\nUser-provided copy assignment operators and move assignment \noperators shall handle self-assignment\n\nOverloading\n\nOverloaded operators   [over.oper]"
  },
  {
    "rule": "Rule 16.5.1\n\nRequired\n\nThe logical AND and logical OR operators shall not be overloaded"
  },
  {
    "rule": "Rule 16.5.2\n\nRequired\n\nThe address-of operator shall not be overloaded\n\nBuilt-in operators   [over.built]"
  },
  {
    "rule": "Rule 16.6.1\n\nAdvisory\n\nSymmetrical operators should only be implemented as non-member \nfunctions\n\nTemplates\n\nFunction template specialization   [temp.fct.spec]"
  },
  {
    "rule": "Rule 17.8.1\n\nRequired\n\nFunction templates shall not be explicitly specialized\n\nException handling\n\nThrowing an exception   [except.throw]"
  },
  {
    "rule": "Rule 18.1.1\n\nRequired\n\nAn exception object shall not have pointer type"
  },
  {
    "rule": "Rule 18.1.2\n\nRequired\n\nAn empty throw shall only occur within the compound-statement of a \ncatch handler\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\ng\nf\no\ny\nr\na\nm\nm\nu\nS\n\n:\n\ni\n\nA\nx\nd\nn\ne\np\np\nA\n\n233\n\n \n \n \n \n\fA\np\np\ne\nn\nd\nx\nA\n\ni\n\n:\n\nS\nu\nm\nm\na\nr\ny\no\nf\ng\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nHandling an exception   [except.handle]"
  },
  {
    "rule": "Rule 18.3.1\n\nAdvisory\n\nThere should be at least one exception handler to catch all otherwise \nunhandled exceptions"
  },
  {
    "rule": "Rule 18.3.2\n\nRequired\n\nAn exception of class type shall be caught by const reference or \nreference"
  },
  {
    "rule": "Rule 18.3.3\n\nRequired\n\nHandlers for a function-try-block of a constructor or destructor shall not \nrefer to non-static members from their class or its bases\n\nException speci2cations   [except.spec]"
  },
  {
    "rule": "Rule 18.4.1\n\nRequired\n\nException-unfriendly functions shall be noexcept\n\nSpecial functions   [except.special]"
  },
  {
    "rule": "Rule 18.5.1\n\nAdvisory\n\nA noexcept function should not attempt to propagate an exception to \nthe calling function"
  },
  {
    "rule": "Rule 18.5.2\n\nAdvisory\n\nProgram-terminating functions should not be used\n\nPreprocessing directives\n\nMISRA   [misra]"
  },
  {
    "rule": "Rule 19.0.1\n\nRequired\n\nA line whose 9rst token is # shall be a valid preprocessing directive"
  },
  {
    "rule": "Rule 19.0.2\n\nRequired\n\nFunction-like macros shall not be de9ned"
  },
  {
    "rule": "Rule 19.0.3\n\nAdvisory\n\n#include directives should only be preceded by preprocessor directives \nor comments"
  },
  {
    "rule": "Rule 19.0.4\n\nAdvisory\n\n#undef should only be used for macros de9ned previously in the same \n9le\n\nConditional inclusion   [cpp.cond]"
  },
  {
    "rule": "Rule 19.1.1\n\nRequired\n\nThe de9ned preprocessor operator shall be used appropriately"
  },
  {
    "rule": "Rule 19.1.2\n\nRequired\n\nAll #else, #elif and #endif preprocessor directives shall reside in the \nsame 9le as the #if, #ifdef or #ifndef directive to which they are related"
  },
  {
    "rule": "Rule 19.1.3\n\nRequired\n\nAll identi9ers used in the controlling expression of #if or #elif \npreprocessing directives shall be de9ned prior to evaluation\n\nSource 2le inclusion   [cpp.include]"
  },
  {
    "rule": "Rule 19.2.1\n\nRequired\n\nPrecautions shall be taken in order to prevent the contents of a header \n9le being included more than once"
  },
  {
    "rule": "Rule 19.2.2\n\nRequired\n\nThe #include directive shall be followed by either a <9lename> or \n\"9lename\" sequence"
  },
  {
    "rule": "Rule 19.2.3\n\nRequired\n\nThe ' or \" or \\ characters and the /* or // character sequences shall not \noccur in a header 9le name\n\n234\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n\fMacro replacement   [cpp.replace]\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\ng\nf\no\ny\nr\na\nm\nm\nu\nS\n\n:\n\ni\n\nA\nx\nd\nn\ne\np\np\nA"
  },
  {
    "rule": "Rule 19.3.1\n\nAdvisory\n\nThe # and ## preprocessor operators should not be used"
  },
  {
    "rule": "Rule 19.3.2\n\nRequired\n\nA macro parameter immediately following a # operator shall not be \nimmediately followed by a ## operator"
  },
  {
    "rule": "Rule 19.3.3\n\nRequired\n\nThe argument to a mixed-use macro parameter shall not be subject to \nfurther expansion"
  },
  {
    "rule": "Rule 19.3.4\n\nRequired\n\nParentheses shall be used to ensure macro arguments are expanded \nappropriately"
  },
  {
    "rule": "Rule 19.3.5\n\nRequired\n\nTokens that look like a preprocessing directive shall not occur within a \nmacro argument\n\nPragma directive   [cpp.pragma]"
  },
  {
    "rule": "Rule 19.6.1\n\nAdvisory\n\nThe #pragma directive and the _Pragma operator should not be used\n\nLanguage support library\n\nCommon de2nitions   [support.types]"
  },
  {
    "rule": "Rule 21.2.1\n\nRequired\n\nThe library functions atof, atoi, atol and atoll from <cstdlib> shall not be \nused"
  },
  {
    "rule": "Rule 21.2.2\n\nRequired\n\nThe string handling functions from <cstring>, <cstdlib>, <cwchar> and \n<cinttypes> shall not be used"
  },
  {
    "rule": "Rule 21.2.3\n\nRequired\n\nThe library function system from <cstdlib> shall not be used"
  },
  {
    "rule": "Rule 21.2.4\n\nRequired\n\nThe macro oCsetof shall not be used\n\nDynamic memory management   [support.dynamic]"
  },
  {
    "rule": "Rule 21.6.1\n\nAdvisory\n\nDynamic memory should not be used"
  },
  {
    "rule": "Rule 21.6.2\n\nRequired\n\nDynamic memory shall be managed automatically"
  },
  {
    "rule": "Rule 21.6.3\n\nRequired\n\nAdvanced memory management shall not be used"
  },
  {
    "rule": "Rule 21.6.4\n\nRequired\n\nIf a project de9nes either a sized or unsized version of a global \noperator delete, then both shall be de9ned"
  },
  {
    "rule": "Rule 21.6.5\n\nRequired\n\nA pointer to an incomplete class type shall not be deleted\n\nOther runtime support   [support.runtime]"
  },
  {
    "rule": "Rule 21.10.1 Required\n\nThe features of <cstdarg> shall not be used"
  },
  {
    "rule": "Rule 21.10.2 Required\n\nThe standard header 9le <csetjmp> shall not be used"
  },
  {
    "rule": "Rule 21.10.3 Required\n\nThe facilities provided by the standard header 9le <csignal> shall not be \nused\n\n235\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n\fA\np\np\ne\nn\nd\nx\nA\n\ni\n\n:\n\nS\nu\nm\nm\na\nr\ny\no\nf\ng\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\ns\n\nDiagnostics library\n\nAssertions   [assertions]"
  },
  {
    "rule": "Rule 22.3.1\n\nRequired\n\nThe assert macro shall not be used with a constant-expression\n\nError numbers   [errno]"
  },
  {
    "rule": "Rule 22.4.1\n\nRequired\n\nThe literal value zero shall be the only value assigned to errno\n\nGeneral utilities library\n\nSmart pointers   [smartptr]"
  },
  {
    "rule": "Rule 23.11.1 Advisory\n\nThe raw pointer constructors of std::shared_ptr and std::unique_ptr \nshould not be used\n\nStrings library\n\nNull-terminated sequence utilities   [c.strings]"
  },
  {
    "rule": "Rule 24.5.1\n\nRequired\n\nThe character handling functions from <cctype> and <cwctype> shall not\n be used"
  },
  {
    "rule": "Rule 24.5.2\n\nRequired\n\nThe C++ Standard Library functions memcpy, memmove and memcmp \nfrom <cstring> shall not be used\n\nLocalization library\n\nC library locales   [c.locales]"
  },
  {
    "rule": "Rule 25.5.1\n\nRequired\n\nThe setlocale and std::locale::global functions shall not be called"
  },
  {
    "rule": "Rule 25.5.2 Mandatory\n\nThe pointers returned by the C++ Standard Library functions localeconv, \ngetenv, setlocale or strerror must only be used as if they have pointer to \nconst-quali9ed type"
  },
  {
    "rule": "Rule 25.5.3 Mandatory\n\nThe pointer returned by the C++ Standard Library functions asctime, \nctime, gmtime, localtime, localeconv, getenv, setlocale or strerror must \nnot be used following a subsequent call to the same function\n\nContainers library\n\nSequence containers   [sequences]"
  },
  {
    "rule": "Rule 26.3.1\n\nAdvisory\n\nstd::vector should not be specialized with bool\n\nAlgorithms library\n\nAlgorithms requirements   [algorithms.requirements]"
  },
  {
    "rule": "Rule 28.3.1\n\nRequired\n\nPredicates shall not have persistent side eCects\n\n236\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n \n\fMutating sequence operations   [alg.modifying.operations]"
  },
  {
    "rule": "Rule 28.6.1\n\nRequired\n\nThe argument to std::move shall be a non-const lvalue"
  },
  {
    "rule": "Rule 28.6.2\n\nRequired\n\nForwarding references and std::forward shall be used together"
  },
  {
    "rule": "Rule 28.6.3\n\nRequired\n\nAn object shall not be used while in a potentially moved-from state"
  },
  {
    "rule": "Rule 28.6.4\n\nRequired\n\nThe result of std::remove, std::remove_if, std::unique and empty shall be \nused\n\nInput/output library\n\nMISRA   [misra]"
  },
  {
    "rule": "Rule 30.0.1\n\nRequired\n\nThe C Library input/output functions shall not be used"
  },
  {
    "rule": "Rule 30.0.2\n\nRequired\n\nReads and writes on the same 9le stream shall be separated by a \npositioning operation\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\ng\nf\no\ny\nr\na\nm\nm\nu\nS\n\n:\n\ni\n\nA\nx\nd\nn\ne\np\np\nA\n\n237\n\n \n \n \n \n\fAppendix B Guideline attributes\n\nRule"
  },
  {
    "rule": "Rule 0.0.1"
  },
  {
    "rule": "Rule 0.0.2"
  },
  {
    "rule": "Rule 0.1.1"
  },
  {
    "rule": "Rule 0.1.2"
  },
  {
    "rule": "Rule 0.2.1"
  },
  {
    "rule": "Rule 0.2.2"
  },
  {
    "rule": "Rule 0.2.3"
  },
  {
    "rule": "Rule 0.2.4\n\nDir 0.3.1\n\nDir 0.3.2"
  },
  {
    "rule": "Rule 4.1.1"
  },
  {
    "rule": "Rule 4.1.2"
  },
  {
    "rule": "Rule 4.1.3"
  },
  {
    "rule": "Rule 4.6.1"
  },
  {
    "rule": "Rule 5.0.1"
  },
  {
    "rule": "Rule 5.7.1\n\nDir 5.7.2"
  },
  {
    "rule": "Rule 5.7.3"
  },
  {
    "rule": "Rule 5.10.1"
  },
  {
    "rule": "Rule 5.13.1"
  },
  {
    "rule": "Rule 5.13.2"
  },
  {
    "rule": "Rule 5.13.3"
  },
  {
    "rule": "Rule 5.13.4"
  },
  {
    "rule": "Rule 5.13.5"
  },
  {
    "rule": "Rule 5.13.6"
  },
  {
    "rule": "Rule 5.13.7"
  },
  {
    "rule": "Rule 6.0.1"
  },
  {
    "rule": "Rule 6.0.2"
  },
  {
    "rule": "Rule 6.0.3"
  },
  {
    "rule": "Rule 6.0.4"
  },
  {
    "rule": "Rule 6.2.1"
  },
  {
    "rule": "Rule 6.2.2"
  },
  {
    "rule": "Rule 6.2.3"
  },
  {
    "rule": "Rule 6.2.4"
  },
  {
    "rule": "Rule 6.4.1"
  },
  {
    "rule": "Rule 6.4.2"
  },
  {
    "rule": "Rule 6.4.3"
  },
  {
    "rule": "Rule 6.5.1"
  },
  {
    "rule": "Rule 6.5.2"
  },
  {
    "rule": "Rule 6.7.1"
  },
  {
    "rule": "Rule 6.7.2\n\nCategory\n\nRequired\n\nAdvisory\n\nAdvisory\n\nRequired\n\nAdvisory\n\nRequired\n\nAdvisory\n\nAdvisory\n\nAdvisory\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nAdvisory\n\nRequired\n\nRequired\n\nAnalysis\n\nDecidable, Single Translation Unit\n\nUndecidable, System\n\nUndecidable, System\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, System\n\nUndecidable, System\n\nDecidable, Single Translation Unit\n\nUndecidable, System\n\nUndecidable, System\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, System\n\nDecidable, System\n\nDecidable, System\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n238\n\n\fRule"
  },
  {
    "rule": "Rule 6.8.1"
  },
  {
    "rule": "Rule 6.8.2"
  },
  {
    "rule": "Rule 6.8.3"
  },
  {
    "rule": "Rule 6.8.4"
  },
  {
    "rule": "Rule 6.9.1"
  },
  {
    "rule": "Rule 6.9.2"
  },
  {
    "rule": "Rule 7.0.1"
  },
  {
    "rule": "Rule 7.0.2"
  },
  {
    "rule": "Rule 7.0.3"
  },
  {
    "rule": "Rule 7.0.4"
  },
  {
    "rule": "Rule 7.0.5"
  },
  {
    "rule": "Rule 7.0.6"
  },
  {
    "rule": "Rule 7.11.1"
  },
  {
    "rule": "Rule 7.11.2"
  },
  {
    "rule": "Rule 7.11.3"
  },
  {
    "rule": "Rule 8.0.1"
  },
  {
    "rule": "Rule 8.1.1"
  },
  {
    "rule": "Rule 8.1.2"
  },
  {
    "rule": "Rule 8.2.1"
  },
  {
    "rule": "Rule 8.2.2"
  },
  {
    "rule": "Rule 8.2.3"
  },
  {
    "rule": "Rule 8.2.4"
  },
  {
    "rule": "Rule 8.2.5"
  },
  {
    "rule": "Rule 8.2.6"
  },
  {
    "rule": "Rule 8.2.7"
  },
  {
    "rule": "Rule 8.2.8"
  },
  {
    "rule": "Rule 8.2.9"
  },
  {
    "rule": "Rule 8.2.10"
  },
  {
    "rule": "Rule 8.2.11"
  },
  {
    "rule": "Rule 8.3.1"
  },
  {
    "rule": "Rule 8.3.2"
  },
  {
    "rule": "Rule 8.7.1"
  },
  {
    "rule": "Rule 8.7.2"
  },
  {
    "rule": "Rule 8.9.1"
  },
  {
    "rule": "Rule 8.14.1\n\nCategory\n\nRequired\n\nAnalysis\n\nUndecidable, System\n\nMandatory\n\nDecidable, Single Translation Unit\n\nRequired\n\nAdvisory\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nUndecidable, System\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nUndecidable, System\n\nUndecidable, System\n\nUndecidable, System\n\nUndecidable, System"
  },
  {
    "rule": "Rule 8.18.1\n\nMandatory\n\nUndecidable, System"
  },
  {
    "rule": "Rule 8.18.2"
  },
  {
    "rule": "Rule 8.19.1"
  },
  {
    "rule": "Rule 8.20.1"
  },
  {
    "rule": "Rule 9.2.1"
  },
  {
    "rule": "Rule 9.3.1"
  },
  {
    "rule": "Rule 9.4.1"
  },
  {
    "rule": "Rule 9.4.2\n\nAdvisory\n\nAdvisory\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nLicensed to: gunjanjain\n22 Apr 2025\n\ns\ne\nt\nu\nb\ni\nr\nt\nt\na\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\ni\n\nB\nx\nd\nn\ne\np\np\nA\n\n239\n\n \n \n \n\fA\np\np\ne\nn\nd\nx\nB\n\ni\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\na\nt\nt\nr\ni\nb\nu\nt\ne\ns\n\n240\n\nRule"
  },
  {
    "rule": "Rule 9.5.1"
  },
  {
    "rule": "Rule 9.5.2"
  },
  {
    "rule": "Rule 9.6.1"
  },
  {
    "rule": "Rule 9.6.2"
  },
  {
    "rule": "Rule 9.6.3"
  },
  {
    "rule": "Rule 9.6.4"
  },
  {
    "rule": "Rule 9.6.5"
  },
  {
    "rule": "Rule 10.0.1"
  },
  {
    "rule": "Rule 10.1.1"
  },
  {
    "rule": "Rule 10.1.2"
  },
  {
    "rule": "Rule 10.2.1"
  },
  {
    "rule": "Rule 10.2.2"
  },
  {
    "rule": "Rule 10.2.3"
  },
  {
    "rule": "Rule 10.3.1"
  },
  {
    "rule": "Rule 10.4.1"
  },
  {
    "rule": "Rule 11.3.1"
  },
  {
    "rule": "Rule 11.3.2"
  },
  {
    "rule": "Rule 11.6.1\n\nCategory\n\nAdvisory\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nAdvisory\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nAdvisory\n\nRequired\n\nAdvisory\n\nAdvisory\n\nAdvisory\n\nAnalysis\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nUndecidable, System\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit"
  },
  {
    "rule": "Rule 11.6.2\n\nMandatory\n\nUndecidable, System"
  },
  {
    "rule": "Rule 11.6.3"
  },
  {
    "rule": "Rule 12.2.1"
  },
  {
    "rule": "Rule 12.2.2"
  },
  {
    "rule": "Rule 12.2.3"
  },
  {
    "rule": "Rule 12.3.1"
  },
  {
    "rule": "Rule 13.1.1"
  },
  {
    "rule": "Rule 13.1.2"
  },
  {
    "rule": "Rule 13.3.1"
  },
  {
    "rule": "Rule 13.3.2"
  },
  {
    "rule": "Rule 13.3.3"
  },
  {
    "rule": "Rule 13.3.4"
  },
  {
    "rule": "Rule 14.1.1"
  },
  {
    "rule": "Rule 15.0.1"
  },
  {
    "rule": "Rule 15.0.2"
  },
  {
    "rule": "Rule 15.1.1"
  },
  {
    "rule": "Rule 15.1.2"
  },
  {
    "rule": "Rule 15.1.3"
  },
  {
    "rule": "Rule 15.1.4"
  },
  {
    "rule": "Rule 15.1.5\n\nDir 15.8.1"
  },
  {
    "rule": "Rule 16.5.1"
  },
  {
    "rule": "Rule 16.5.2"
  },
  {
    "rule": "Rule 16.6.1"
  },
  {
    "rule": "Rule 17.8.1\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nAdvisory\n\nRequired\n\nAdvisory\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, System\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nUndecidable, System\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n\fs\ne\nt\nu\nb\ni\nr\nt\nt\na\ne\nn\n\ni\nl\n\ni\n\ne\nd\nu\nG\n\n:\n\ni\n\nB\nx\nd\nn\ne\np\np\nA\n\nRule"
  },
  {
    "rule": "Rule 18.1.1"
  },
  {
    "rule": "Rule 18.1.2"
  },
  {
    "rule": "Rule 18.3.1"
  },
  {
    "rule": "Rule 18.3.2"
  },
  {
    "rule": "Rule 18.3.3"
  },
  {
    "rule": "Rule 18.4.1"
  },
  {
    "rule": "Rule 18.5.1"
  },
  {
    "rule": "Rule 18.5.2"
  },
  {
    "rule": "Rule 19.0.1"
  },
  {
    "rule": "Rule 19.0.2"
  },
  {
    "rule": "Rule 19.0.3"
  },
  {
    "rule": "Rule 19.0.4"
  },
  {
    "rule": "Rule 19.1.1"
  },
  {
    "rule": "Rule 19.1.2"
  },
  {
    "rule": "Rule 19.1.3"
  },
  {
    "rule": "Rule 19.2.1"
  },
  {
    "rule": "Rule 19.2.2"
  },
  {
    "rule": "Rule 19.2.3"
  },
  {
    "rule": "Rule 19.3.1"
  },
  {
    "rule": "Rule 19.3.2"
  },
  {
    "rule": "Rule 19.3.3"
  },
  {
    "rule": "Rule 19.3.4"
  },
  {
    "rule": "Rule 19.3.5"
  },
  {
    "rule": "Rule 19.6.1"
  },
  {
    "rule": "Rule 21.2.1"
  },
  {
    "rule": "Rule 21.2.2"
  },
  {
    "rule": "Rule 21.2.3"
  },
  {
    "rule": "Rule 21.2.4\n\nCategory\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nAdvisory\n\nRequired\n\nRequired\n\nAdvisory\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAnalysis\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nUndecidable, System\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit"
  },
  {
    "rule": "Rule 21.6.1\n\nAdvisory\n\nUndecidable, Single Translation Unit"
  },
  {
    "rule": "Rule 21.6.2"
  },
  {
    "rule": "Rule 21.6.3"
  },
  {
    "rule": "Rule 21.6.4"
  },
  {
    "rule": "Rule 21.6.5"
  },
  {
    "rule": "Rule 21.10.1"
  },
  {
    "rule": "Rule 21.10.2"
  },
  {
    "rule": "Rule 21.10.3"
  },
  {
    "rule": "Rule 22.3.1"
  },
  {
    "rule": "Rule 22.4.1"
  },
  {
    "rule": "Rule 23.11.1"
  },
  {
    "rule": "Rule 24.5.1"
  },
  {
    "rule": "Rule 24.5.2"
  },
  {
    "rule": "Rule 25.5.1\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, System\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit"
  },
  {
    "rule": "Rule 25.5.2\n\nMandatory\n\nDecidable, Single Translation Unit\n\n241\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n\fA\np\np\ne\nn\nd\nx\nB\n\ni\n\n:\n\nG\nu\nd\ne\n\ni\n\nl\ni\n\nn\ne\na\nt\nt\nr\ni\nb\nu\nt\ne\ns\n\n242\n\nRule\n\nCategory\n\nAnalysis"
  },
  {
    "rule": "Rule 25.5.3\n\nMandatory\n\nUndecidable, System"
  },
  {
    "rule": "Rule 26.3.1"
  },
  {
    "rule": "Rule 28.3.1"
  },
  {
    "rule": "Rule 28.6.1"
  },
  {
    "rule": "Rule 28.6.2"
  },
  {
    "rule": "Rule 28.6.3"
  },
  {
    "rule": "Rule 28.6.4"
  },
  {
    "rule": "Rule 30.0.1"
  },
  {
    "rule": "Rule 30.0.2\n\nAdvisory\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nRequired\n\nDecidable, Single Translation Unit\n\nUndecidable, System\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nDecidable, Single Translation Unit\n\nUndecidable, System\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n \n\fAppendix C Glossary\n\nCallback\n\nA callback is a function that is called indirectly via a function pointer or a handle.\n\nDataCow anomaly\n\nThe state of a variable at a point in a program can be described using the following terms:\n\n\u25cf Unde9ned (U) \u2014 the value of the variable is indeterminate; and\n\n\u25cf Referenced (R) \u2014 the variable is used in some way (e.g. in an expression); and\n\n\u25cf De9ned (D) \u2014 the variable is explicitly initialized or assigned a value.\n\nGiven the above, the following data+ow anomalies can be de9ned:\n\n\u25cf UR data^ow anomaly \u2014 variable not assigned a value before the speci9ed use; and\n\n\u25cf DU data^ow anomaly \u2014 variable is assigned a value that is never subsequently used; and\n\n\u25cf DD data^ow anomaly \u2014 variable is assigned a value twice with no intermediate use.\n\nDD dataCow anomaly\n\nSee data+ow anomaly.\n\nDeclaration\n\nA declaration introduces the name of an entity into a translation unit (see [basic.def]/1). \n\nAn entity may be declared several times. The 9rst declaration of an entity in a translation unit is called \nan introduction. All subsequent declarations are called redeclarations. \n\nA de%nition is a declaration, as described in [basic.def]/2.\n\nDe2nition\n\nSee declaration.\n\nDirectly enclose\n\nSee enclose.\n\nDU dataCow anomaly\n\nSee data+ow anomaly.\n\nEnclose\n\nA statement S1 directly encloses a statement S2 if:\n\n\u25cf S1 is a labeled-statement, and S2 is the contained statement; or\n\n\u25cf S1 is a compound-statement, and S2 is any statement of its statement-seq; or\n\n\u25cf S1 is a selection-statement, and S2 is any of its statements (but not its init-statement); or\n\n\u25cf S1 is an iteration-statement, and S2 is the contained statement (but not an init-statement).\n\nA statement S1 encloses a statement S2 if:\n\n\u25cf S1 directly encloses S2; or\n\n\u25cf S1 directly encloses a statement S3 and S3 encloses S2.\n\n243\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n\fA\np\np\ne\nn\nd\nx\nC\n\ni\n\n:\n\nl\n\nG\no\ns\ns\na\nr\ny\n\nGeneral manager\n\nA manager class, as de9ned in"
  },
  {
    "rule": "Rule 15.0.1.\n\nHeader 2le\n\nA header %le is considered to be any 9le that is included during preprocessing (for example via the \n#include directive), regardless of its name or su[x.\n\nInfeasible path\n\nInfeasible paths occur where there is a syntactic path to a code fragment, but the semantics ensure \nthat the control ^ow path will not be executed. For example: \n\nif ( u32 < 0 )\n{\n  // An unsigned value will never be negative,\n  // so code in this block will never be executed.\n}\n\nIntroduction\n\nSee declaration.\n\nManager class\n\nA class that is either a scoped manager, a unique manager, or a general manager as de9ned in"
  },
  {
    "rule": "Rule\n15.0.1.\n\nNDR\n\nNDR is an abbreviation for no diagnostic required.\n\nODR\n\nODR is an abbreviation for the one-de%nition rule.\n\nPersistent side eDect\n\nA side eAect is said to be persistent at a particular point in execution if it might have an eCect on the \nexecution state at that point. All of the following  side eAects  are  persistent  at a given point in the \nprogram:\n\n\u25cf Modifying a 9le, stream, etc.;\n\n\u25cf Modifying an object, including via a pointer or reference;\n\n\u25cf Accessing a volatile object;\n\n\u25cf Raising an exception that transfers control outside of the current function.\n\nWhen a function is called, it may have side effects. Modifying a file or accessing a volatile object are \npersistent as viewed by the calling function. However any objects modified by the called function,  \nwhose lifetimes have ended by the time it returns, do not aCect the caller\u2019s execution state. Any  side  \neAects arising from modifying such objects are not persistent from the point of view of the caller. \n\nThe determination of whether a function has persistent side effects takes no consideration of the \npossible values for parameters or other non-local objects.\n\nPolymorphic class\n\nA polymorphic class is a class that declares or inherits a virtual function.\n\n244\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n \n \n\fy\nr\na\ns\ns\no\nG\n\nl\n\n:\n\ni\n\nC\nx\nd\nn\ne\np\np\nA\n\nRAII\n\nRAII is an abbreviation for Resource Acquisition Is Initialization, which is a programming idiom for scope-\nbased resource management that binds the ownership of a resource to the lifetime of an object \u2014 the \nresource is acquired during construction and released during destruction.\n\nRedeclaration\n\nSee declaration.\n\nScoped manager\n\nA manager class, as de9ned in"
  },
  {
    "rule": "Rule 15.0.1.\n\nTransient lambda\n\nA lambda is transient when:\n\n\u25cf It is immediately invoked; or\n\n\u25cf It is passed to a function that does not store it.\n\nA function does not store a lambda when:\n\n\u25cf The function is de9ned in the same translation unit as the lambda; and\n\n\u25cf The lambda is only copied or moved when it is passed as an argument; and\n\n\u25cf The function only calls the lambda and/or passes the lambda to another function that does not \n\nstore it.\n\nUR dataCow anomaly\n\nSee data+ow anomaly.\n\nUnique manager\n\nA manager class, as de9ned in"
  },
  {
    "rule": "Rule 15.0.1.\n\nUse / used / using\n\nAn object is used if:\n\n\u25cf It is the subject of a cast; or\n\n\u25cf It is explicitly initialized at declaration time; or\n\n\u25cf It is an operand in an expression; or\n\n\u25cf It is referenced.\n\nA function is used as de9ned in"
  },
  {
    "rule": "Rule 0.2.4.\n\nA type is used as de9ned in"
  },
  {
    "rule": "Rule 0.2.3.\n\nUnscoped enumeration type\n\nA type created with the enum keyword that is not created as enum class or enum struct. Values of \nsuch a type will be subject to integral promotion.\n\nUnused\n\nAn entity is unused if it is not used.\n\nLicensed to: gunjanjain\n22 Apr 2025\n\n245\n\n \n \n\fISBN 978-1-911700-10-4 paperback\nISBN 978-1-911700-11-1 PDF\n\nLicensed to: gunjanjain\n22 Apr 2025"
  }
]